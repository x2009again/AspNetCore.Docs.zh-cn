<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#37197;&#32622; ASP.NET Core &#20197;&#20351;&#29992;&#20195;&#29702;&#26381;&#21153;&#22120;&#21644;&#36127;&#36733;&#22343;&#34913;&#22120; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#37197;&#32622; ASP.NET Core &#20197;&#20351;&#29992;&#20195;&#29702;&#26381;&#21153;&#22120;&#21644;&#36127;&#36733;&#22343;&#34913;&#22120; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="host-and-deploy/proxy-load-balancer">
<h1 id="configure-aspnet-core-to-work-with-proxy-servers-and-load-balancers">配置 ASP.NET Core 以使用代理服务器和负载均衡器</h1>

<p>作者：<a href="https://github.com/Tratcher">Chris Ross</a></p>
<div range="&gt;= aspnetcore-3.0">
<p>在 ASP.NET Core 推荐配置中，应用使用 IIS/ASP.NET Core 模块、Nginx 或 Apache 进行托管。 代理服务器、负载均衡器和其他网络设备通常会在请求到达应用之前隐藏有关请求的信息：</p>
<ul>
<li>当通过 HTTP 代理 HTTPS 请求时，原方案 (HTTPS) 将丢失，并且必须在标头中转接。</li>
<li>由于应用收到来自代理的请求，而不是 Internet 或公司网络上请求的真实源，因此原始客户端 IP 地址也必须在标头中转接。</li>
</ul>
<p>此信息在请求处理中可能很重要，例如在重定向、身份验证、链接生成、策略评估和客户端地理位置中。</p>
<h2 id="forwarded-headers">转接头</h2>
<p>按照约定，代理转接 HTTP 标头中的信息。</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>X-Forwarded-For</td>
<td>保存代理链中关于发起请求的客户端和后续代理的信息。 该参数可能包含 IP 地址（以及可选端口号）。 在代理服务器链中，第一个参数表示最初发出请求的客户端。 后续代理标识符以此类推。 链中的最后一个代理不在参数列表中。 最后一个代理的 IP 地址以及可选的端口号可用作传输层的远程 IP 地址。</td>
</tr>
<tr>
<td>X-Forwarded-Proto</td>
<td>原方案的值 (HTTP/HTTPS)。 如果请求已遍历多个代理，则该值也可以是方案列表。</td>
</tr>
<tr>
<td>X-Forwarded-Host</td>
<td>主机标头字段的原始值。 代理通常不会修改主机标头。 有关特权提升漏洞的信息，请参阅 <a href="https://github.com/aspnet/Announcements/issues/295">Microsoft 安全公告 CVE-2018-0787</a>，该漏洞影响代理未验证或将主机标头限制为已知正确值的系统。</td>
</tr>
</tbody>
</table>
<p>转接头中间件 (&lt;xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersMiddleware&gt;) 读取这些标头并填充 &lt;xref:Microsoft.AspNetCore.Http.HttpContext&gt; 上的关联字段。</p>
<p>中间件更新：</p>
<ul>
<li><a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress">HttpContext.Connection.RemoteIpAddress</a>：使用 <code>X-Forwarded-For</code> 标头值设置。 影响中间件如何设置 <code>RemoteIpAddress</code> 的其他设置。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>。</li>
<li><a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Scheme">HttpContext.Request.Scheme</a>：使用 <code>X-Forwarded-Proto</code> 标头值设置。</li>
<li><a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Host">HttpContext.Request.Host</a>：使用 <code>X-Forwarded-Host</code> 标头值设置。</li>
</ul>
<p>可以配置转接头中间件<a href="#forwarded-headers-middleware-options">默认设置</a>。 默认设置为：</p>
<ul>
<li>应用和请求源之间只有一个代理**。</li>
<li>仅将环回地址配置为已知代理和已知网络。</li>
<li>转接头被命名为 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code>。</li>
</ul>
<p>并非所有网络设备均可在没有其他配置的情况下添加 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头。 如果代理请求在到达应用时未包含这些标头，请查阅设备制造商提供的指导。 如果设备使用 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 以外的其他标头名称，请设置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt; 选项，使其与设备所用的标头名称相匹配。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>和<a href="#configuration-for-a-proxy-that-uses-different-header-names">配置使用不同标头名称的代理</a>。</p>
<h2 id="iisiis-express-and-aspnet-core-module">IIS/IIS Express 和 ASP.NET Core 模块</h2>
<p>当应用托管在 IIS 和 ASP.NET Core 模块后方的<a class="xref" href="iis/index.html#out-of-process-hosting-model">进程外</a>时，转接头中间件由 <a class="xref" href="iis/index.html#enable-the-iisintegration-components">IIS 集成中间件</a>默认启用。 由于转接头的信任问题（例如，<a href="https://www.iplocation.net/ip-spoofing">IP 欺骗</a>），转接头中间件被激活为首先在中间件管道中运行，并具有特定于 ASP.NET Core 模块的受限配置。 中间件配置为转接 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头，并且被限制到单个本地 localhost 代理。 如果需要其他配置，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>。</p>
<h2 id="other-proxy-server-and-load-balancer-scenarios">其他代理服务器和负载均衡器方案</h2>
<p>除在<a class="xref" href="iis/index.html#out-of-process-hosting-model">进程外</a>托管时使用 <a class="xref" href="iis/index.html#enable-the-iisintegration-components">IIS 集成</a>之外，不会默认启用转接头中间件。 必须启用应用的转接头中间件才能处理带有 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 的转接头。 启用中间件后，如果没有为中间件指定 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt;，那么默认的 <a href="xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders">ForwardedHeadersOptions.ForwardedHeaders</a> 是 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。</p>
<p>为中间件配置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt; 以转接 <code>Startup.ConfigureServices</code> 中的 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头。</p>
<p><a name="fhmo"></a></p>
<h3 id="forwarded-headers-middleware-order">转接头中间件顺序</h3>
<p>转接头中间件应在其他中间件之前运行。 此顺序可确保依赖于转接头信息的中间件可以使用标头值进行处理。 转接头中间件可以在诊断和错误处理之后运行，但必须在调用 <code>UseHsts</code> 之前运行：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>或者，在诊断之前调用 <code>UseForwardedHeaders</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>如果没有在 <code>Startup.ConfigureServices</code> 中指定任何 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt;，或未使用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 直接指定到扩展方法，则要转接的默认标头为 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。 必须为 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders&gt; 属性配置要转接的标头。</p>
</div>
<h2 id="nginx-configuration">Nginx 配置</h2>
<p>要转发 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头，请参阅 <a class="xref" href="linux-nginx.html#configure-nginx">使用 Nginx 在 Linux 上托管 ASP.NET Core</a>。 有关详细信息，请参阅 <a href="https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/">NGINX：使用转发标头</a>。</p>
<h2 id="apache-configuration">Apache 配置</h2>
<p><code>X-Forwarded-For</code> 将会自动添加（请参阅 <a href="https://httpd.apache.org/docs/2.4/mod/mod_proxy.html#x-headers">Apache 模块 mod_proxy：反向代理请求标头</a>）。 要了解如何转发 <code>X-Forwarded-Proto</code> 标头，请参阅 <a class="xref" href="linux-apache.html#configure-apache">使用 Apache 在 Linux 上托管 ASP.NET Core</a>。</p>
<h2 id="forwarded-headers-middleware-options">转接头中间件选项</h2>
<p>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt; 控制转接头中间件的行为。 以下示例更改了默认值：</p>
<ul>
<li>将转接头中的条目数量限制为 <code>2</code>。</li>
<li>添加已知的代理地址 <code>127.0.10.1</code>。</li>
<li>将转接头名称从默认的 <code>X-Forwarded-For</code> 更改为 <code>X-Forwarded-For-My-Custom-Header-Name</code>。</li>
</ul>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardLimit = 2;
    options.KnownProxies.Add(IPAddress.Parse(&quot;127.0.10.1&quot;));
    options.ForwardedForHeaderName = &quot;X-Forwarded-For-My-Custom-Header-Name&quot;;
});
</code></pre>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.AllowedHosts&gt;</td>
<td>通过 <code>X-Forwarded-Host</code> 标头将主机限制为提供的值。<ul><li>使用 ordinal-ignore-case 比较值。</li><li>必须排除端口号。</li><li>如果列表为空，则允许使用所有主机。</li><li>顶级通配符 <code>*</code> 允许所有非空主机。</li><li>子域通配符允许使用，但不匹配根域。 例如，<code>*.contoso.com</code> 匹配子域 <code>foo.contoso.com</code>，但不匹配根域 <code>contoso.com</code>。</li><li>允许使用 Unicode 主机名，但应转换为 <a href="https://tools.ietf.org/html/rfc3492">Punycode</a> 进行匹配。</li><li><a href="https://tools.ietf.org/html/rfc4291">IPv6 地址</a>必须包括边界方括号，而且必须位于<a href="https://tools.ietf.org/html/rfc4291#section-2.2">常规窗体</a>（例如，<code>[ABCD:EF01:2345:6789:ABCD:EF01:2345:6789]</code>）中。 IPv6 地址并非专门用于检查不同格式之间的逻辑相等性，也不执行标准化。</li><li>未能限制允许的主机可能会允许攻击者访问该服务生成的欺骗链接。</li></ul>默认值为空的 <code>IList&lt;string&gt;</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedForHeaderName">ForwardedHeadersDefaults.XForwardedForHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-For</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-For</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders&gt;</td>
<td>标识应处理的转发器。 对于应用的字段的列表，请参阅 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders 枚举</a>。 分配给此属性的典型值为 <code>ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto</code>。<br><br>默认值是 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHostHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedHostHeaderName">ForwardedHeadersDefaults.XForwardedHostHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-Host</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-Host</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedProtoHeaderName">ForwardedHeadersDefaults.XForwardedProtoHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-Proto</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-Proto</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardLimit&gt;</td>
<td>限制所处理的标头中的条目数。 设置为 <code>null</code> 以禁用此限制，但仅应在已配置 <code>KnownProxies</code> 或 <code>KnownNetworks</code> 的情况下执行此操作。 设置非 <code>null</code> 值是一种预防措施（但不是保证），防止错误配置的代理和恶意请求从网络的侧通道到达。<br><br>转接头中间件按照从右向左的相反顺序处理标头。 如果使用默认值 (<code>1</code>)，则只会处理标头最右侧的值，除非增加 <code>ForwardLimit</code> 的值。<br><br>默认值为 <code>1</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.KnownNetworks&gt;</td>
<td>从中接受转接头的已知网络的地址范围。 使用无类别域际路由选择 (CIDR) 表示法提供 IP 范围。<br><br>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。 有关详细信息，请参阅<a href="#configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</a>部分。<br><br>默认值是 <code>IList</code>&lt;&lt;xref:Microsoft.AspNetCore.HttpOverrides.IPNetwork&gt;&gt;，其中包含 <code>IPAddress.Loopback</code> 的单个条目。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.KnownProxies&gt;</td>
<td>从中接受转接头的已知代理的地址。 使用 <code>KnownProxies</code> 指定精确的 IP 地址匹配。<br><br>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。 有关详细信息，请参阅<a href="#configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</a>部分。<br><br>默认值是 <code>IList</code>&lt;&lt;xref:System.Net.IPAddress&gt;&gt;，其中包含 <code>IPAddress.IPv6Loopback</code> 的单个条目。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalForHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalForHeaderName">ForwardedHeadersDefaults.XOriginalForHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-For</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalHostHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalHostHeaderName">ForwardedHeadersDefaults.XOriginalHostHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-Host</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalProtoHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalProtoHeaderName">ForwardedHeadersDefaults.XOriginalProtoHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-Proto</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.RequireHeaderSymmetry&gt;</td>
<td>要求正在处理的 <a href="xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders">ForwardedHeadersOptions.ForwardedHeaders</a> 之间的标头值数量保持同步。<br><br>ASP.NET Core 1.x 默认值是 <code>true</code>。 ASP.NET Core 2.0 默认值是 <code>false</code>。</td>
</tr>
</tbody>
</table>
<h2 id="scenarios-and-use-cases">方案与使用案例</h2>
<h3 id="when-it-isnt-possible-to-add-forwarded-headers-and-all-requests-are-secure">无法添加转接头并且所有请求都安全的情况</h3>
<p>在某些情况下，可能无法将转接头添加到代理到应用的请求中。 如果代理强制将所有公共外部请求执行为 HTTPS，则在使用任何类型的中间件之前，可以在 <code>Startup.Configure</code> 中手动设置该方案：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    context.Request.Scheme = &quot;https&quot;;
    return next();
});
</code></pre>
<p>此代码可以通过环境变量或者开发环境或过渡环境中的其他配置设置来禁用。</p>
<h3 id="deal-with-path-base-and-proxies-that-change-the-request-path">处理改变请求路径的基路径和代理</h3>
<p>一些代理可完整地传递路径，但是会删除应用基路径以便路由可正常工作。 <a href="xref:Microsoft.AspNetCore.Builder.UsePathBaseExtensions.UsePathBase*">UsePathBaseExtensions.UsePathBase</a> 中间件将路径拆分为 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Path">HttpRequest.Path</a>，将应用基路径拆分为 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.PathBase">HttpRequest.PathBase</a>。</p>
<p>如果 <code>/foo</code> 是作为 <code>/foo/api/1</code> 传递的代理路径的应用基路径，则中间件使用以下命令将 <code>Request.PathBase</code> 设置为 <code>/foo</code>，将 <code>Request.Path</code> 设置为 <code>/api/1</code>：</p>
<pre><code class="lang-csharp">app.UsePathBase(&quot;/foo&quot;);
</code></pre>
<p>当再次反向调用中间件时，将重新应用原始路径和基路径。 要详细了解中间件处理顺序，请参阅 <a class="xref" href="../fundamentals/middleware/index.html">ASP.NET Core 中间件</a>。</p>
<p>如果代理剪裁路径（例如，将 <code>/foo/api/1</code> 转接到 <code>/api/1</code>），请通过设置请求的 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.PathBase">PathBase</a> 属性来修复重定向和链接：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    context.Request.PathBase = new PathString(&quot;/foo&quot;);
    return next();
});
</code></pre>
<p>如果代理要添加路径数据，请使用 &lt;xref:Microsoft.AspNetCore.Http.PathString.StartsWithSegments*&gt; 并分配给 &lt;xref:Microsoft.AspNetCore.Http.HttpRequest.Path&gt; 属性，从而放弃部分路径以修复重定向和链接：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    if (context.Request.Path.StartsWithSegments(&quot;/foo&quot;, out var remainder))
    {
        context.Request.Path = remainder;
    }

    return next();
});
</code></pre>
<h3 id="configuration-for-a-proxy-that-uses-different-header-names">配置使用不同标头名称的代理</h3>
<p>如果代理不使用名为 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 的标头来转发代理地址/端口和原始架构信息，则设置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt; 选项，使其与代理所用的标头名称相匹配：</p>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardedForHeaderName = &quot;Header_Name_Used_By_Proxy_For_X-Forwarded-For_Header&quot;;
    options.ForwardedProtoHeaderName = &quot;Header_Name_Used_By_Proxy_For_X-Forwarded-Proto_Header&quot;;
});
</code></pre>
<h3 id="configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</h3>
<p>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code> 或 <code>::ffff:a00:1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。</p>
<p>在以下示例中，提供转接头的网络地址以 IPv6 格式添加到 <code>KnownNetworks</code> 列表中。</p>
<p>IPv4 地址：<code>10.11.12.1/8</code></p>
<p>转换后的 IPv6 地址：<code>::ffff:10.11.12.1</code><br>
转换后的前缀长度：104</p>
<p>也可以提供十六进制格式的地址（<code>10.11.12.1</code> 以 IPv6 格式表示为 <code>::ffff:0a0b:0c01</code>）。 将 IPv4 地址转换为 IPv6 时，将 96 添加到 CIDR 前缀长度（示例中的 <code>8</code>）以说明其他 <code>::ffff:</code> IPv6 前缀 (8 + 96 = 104)。</p>
<pre><code class="lang-csharp">// To access IPNetwork and IPAddress, add the following namespaces:
// using System.Net;
// using Microsoft.AspNetCore.HttpOverrides;
services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardedHeaders =
        ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
    options.KnownNetworks.Add(new IPNetwork(
        IPAddress.Parse(&quot;::ffff:10.11.12.1&quot;), 104));
});
</code></pre>
<h2 id="forward-the-scheme-for-linux-and-non-iis-reverse-proxies">转发 Linux 和非 IIS 反向代理的方案</h2>
<p>如果将站点部署到 Azure Linux 应用服务、Azure Linux 虚拟机 (VM)，或者部署到除 IIS 之外的任何其他反向代理之后，调用 &lt;xref:Microsoft.AspNetCore.Builder.HttpsPolicyBuilderExtensions.UseHttpsRedirection*&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.HstsBuilderExtensions.UseHsts*&gt; 的应用都会使站点进入无限循环。 反向代理终止 TLS，并且 Kestrel 未发现正确的请求方案。 由于 OAuth 和 OIDC 生成了错误的重定向，因此它们在此配置中也会出现故障。 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilderIISExtensions.UseIISIntegration*&gt; 在 IIS 之后运行时会添加和配置转接头中间件，但 Linux（Apache 或 Nginx 集成）没有匹配的自动配置。</p>
<p>要从非 IIS 方案中的代理中转发方案，请添加并配置转接头中间件。 在 <code>Startup.ConfigureServices</code> 中，使用以下代码：</p>
<pre><code class="lang-csharp">// using Microsoft.AspNetCore.HttpOverrides;

if (string.Equals(
    Environment.GetEnvironmentVariable(&quot;ASPNETCORE_FORWARDEDHEADERS_ENABLED&quot;), 
    &quot;true&quot;, StringComparison.OrdinalIgnoreCase))
{
    services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
    {
        options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | 
            ForwardedHeaders.XForwardedProto;
        // Only loopback proxies are allowed by default.
        // Clear that restriction because forwarders are enabled by explicit 
        // configuration.
        options.KnownNetworks.Clear();
        options.KnownProxies.Clear();
    });
}
</code></pre>
<h2 id="certificate-forwarding">转发证书</h2>
<h3 id="azure">Azure</h3>
<p>若要为证书转发配置 Azure 应用服务，请参阅<a href="/azure/app-service/app-service-web-configure-tls-mutual-auth">为 Azure 应用服务配置 TLS 相互身份验证</a>。 以下指南与配置 ASP.NET Core 应用相关。</p>
<p>在 <code>Startup.Configure</code> 中，在调用 <code>app.UseAuthentication();</code> 前添加以下代码：</p>
<pre><code class="lang-csharp">app.UseCertificateForwarding();
</code></pre>
<p>配置证书转发中间件，以指定 Azure 使用的标头名称。 在 <code>Startup.ConfigureServices</code> 中，添加以下代码来配置中间件从中生成证书的标头：</p>
<pre><code class="lang-csharp">services.AddCertificateForwarding(options =&gt;
    options.CertificateHeader = &quot;X-ARR-ClientCert&quot;);
</code></pre>
<h3 id="other-web-proxies">其他 Web 代理</h3>
<p>如果使用的代理不是 IIS 或 Azure 应用服务的应用程序请求路由 (ARR)，请配置代理，以便转发其在 HTTP 标头中收到的证书。 在 <code>Startup.Configure</code> 中，在调用 <code>app.UseAuthentication();</code> 前添加以下代码：</p>
<pre><code class="lang-csharp">app.UseCertificateForwarding();
</code></pre>
<p>配置证书转发中间件，以指定标头名称。 在 <code>Startup.ConfigureServices</code> 中，添加以下代码来配置中间件从中生成证书的标头：</p>
<pre><code class="lang-csharp">services.AddCertificateForwarding(options =&gt;
    options.CertificateHeader = &quot;YOUR_CERTIFICATE_HEADER_NAME&quot;);
</code></pre>
<p>如果代理不在对证书进行 base64 编码（与 Nginx 的情况一样），请设置 <code>HeaderConverter</code> 选项。 请看下面 <code>Startup.ConfigureServices</code> 中的示例：</p>
<pre><code class="lang-csharp">services.AddCertificateForwarding(options =&gt;
{
    options.CertificateHeader = &quot;YOUR_CUSTOM_HEADER_NAME&quot;;
    options.HeaderConverter = (headerValue) =&gt; 
    {
        var clientCertificate = 
           /* some conversion logic to create an X509Certificate2 */
        return clientCertificate;
    }
});
</code></pre>
<h2 id="troubleshoot">疑难解答</h2>
<p>如果未按预期转接标头，请启用<a class="xref" href="../fundamentals/logging/index.html">日志记录</a>。 如果日志没有提供足够的信息来解决问题，请枚举服务器收到的请求标头。 使用内联中间件将请求标头写入应用程序响应或记录标头。</p>
<p>要将标头写入应用的响应，请在 <code>Startup.Configure</code> 中调用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 后立即放置以下终端内联中间件：</p>
<pre><code class="lang-csharp">app.Run(async (context) =&gt;
{
    context.Response.ContentType = &quot;text/plain&quot;;

    // Request method, scheme, and path
    await context.Response.WriteAsync(
        $&quot;Request Method: {context.Request.Method}{Environment.NewLine}&quot;);
    await context.Response.WriteAsync(
        $&quot;Request Scheme: {context.Request.Scheme}{Environment.NewLine}&quot;);
    await context.Response.WriteAsync(
        $&quot;Request Path: {context.Request.Path}{Environment.NewLine}&quot;);

    // Headers
    await context.Response.WriteAsync($&quot;Request Headers:{Environment.NewLine}&quot;);

    foreach (var header in context.Request.Headers)
    {
        await context.Response.WriteAsync($&quot;{header.Key}: &quot; +
            $&quot;{header.Value}{Environment.NewLine}&quot;);
    }

    await context.Response.WriteAsync(Environment.NewLine);

    // Connection: RemoteIp
    await context.Response.WriteAsync(
        $&quot;Request RemoteIp: {context.Connection.RemoteIpAddress}&quot;);
});
</code></pre>
<p>可以写入日志，而不是响应正文。 借助写入日志，站点可在调试时正常运行。</p>
<p>要写入日志而不是响应正文，请执行以下操作：</p>
<ul>
<li>将 <code>ILogger&lt;Startup&gt;</code> 注入到 <code>Startup</code> 类中，如<a class="xref" href="../fundamentals/logging/index.html#create-logs-in-startup">在启动时创建日志</a>中所述。</li>
<li>在 <code>Startup.Configure</code> 中调用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 之后，立即放置以下内联中间件。</li>
</ul>
<pre><code class="lang-csharp">app.Use(async (context, next) =&gt;
{
    // Request method, scheme, and path
    _logger.LogDebug(&quot;Request Method: {Method}&quot;, context.Request.Method);
    _logger.LogDebug(&quot;Request Scheme: {Scheme}&quot;, context.Request.Scheme);
    _logger.LogDebug(&quot;Request Path: {Path}&quot;, context.Request.Path);

    // Headers
    foreach (var header in context.Request.Headers)
    {
        _logger.LogDebug(&quot;Header: {Key}: {Value}&quot;, header.Key, header.Value);
    }

    // Connection: RemoteIp
    _logger.LogDebug(&quot;Request RemoteIp: {RemoteIpAddress}&quot;, 
        context.Connection.RemoteIpAddress);

    await next();
});
</code></pre>
<p>处理时，<code>X-Forwarded-{For|Proto|Host}</code> 值将移至 <code>X-Original-{For|Proto|Host}</code>。 如果给定标头中有多个值，则转接头中间件按照从右向左的相反顺序处理标头。 默认 <code>ForwardLimit</code> 为 <code>1</code>（一），因此只会处理标头最右侧的值，除非增加 <code>ForwardLimit</code> 的值。</p>
<p>在处理转接头之前，请求的原始远程 IP 必须与 <code>KnownProxies</code> 或 <code>KnownNetworks</code> 列表中的条目匹配。 这通过不接受来自不受信任的代理的转发器来限制标头欺骗。 检测到未知代理时，日志记录会指出代理的地址：</p>
<pre><code class="lang-console">September 20th 2018, 15:49:44.168 Unknown proxy: 10.0.0.100:54321
</code></pre>
<p>在上述示例中，10.0.0.100 是代理服务器。 如果该服务器是受信任的代理，请将服务器的 IP 地址添加到 <code>Startup.ConfigureServices</code> 中的 <code>KnownProxies</code>（或将受信任的网络添加到 <code>KnownNetworks</code>）。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>部分。</p>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.KnownProxies.Add(IPAddress.Parse(&quot;10.0.0.100&quot;));
});
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>仅允许受信任的代理和网络转接头。 否则，可能会受到 <a href="https://www.iplocation.net/ip-spoofing">IP 欺骗</a>攻击。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="web-farm.html">在 Web 场中托管 ASP.NET Core</a></li>
<li><a href="https://github.com/aspnet/Announcements/issues/295">Microsoft 安全公告 CVE-2018-0787：ASP.NET Core 特权提升漏洞</a></li>
</ul>
</div>
<div range="&lt; aspnetcore-3.0">
<p>在 ASP.NET Core 推荐配置中，应用使用 IIS/ASP.NET Core 模块、Nginx 或 Apache 进行托管。 代理服务器、负载均衡器和其他网络设备通常会在请求到达应用之前隐藏有关请求的信息：</p>
<ul>
<li>当通过 HTTP 代理 HTTPS 请求时，原方案 (HTTPS) 将丢失，并且必须在标头中转接。</li>
<li>由于应用收到来自代理的请求，而不是 Internet 或公司网络上请求的真实源，因此原始客户端 IP 地址也必须在标头中转接。</li>
</ul>
<p>此信息在请求处理中可能很重要，例如在重定向、身份验证、链接生成、策略评估和客户端地理位置中。</p>
<h2 id="forwarded-headers">转接头</h2>
<p>按照约定，代理转接 HTTP 标头中的信息。</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>X-Forwarded-For</td>
<td>保存代理链中关于发起请求的客户端和后续代理的信息。 该参数可能包含 IP 地址（以及可选端口号）。 在代理服务器链中，第一个参数表示最初发出请求的客户端。 后续代理标识符以此类推。 链中的最后一个代理不在参数列表中。 最后一个代理的 IP 地址以及可选的端口号可用作传输层的远程 IP 地址。</td>
</tr>
<tr>
<td>X-Forwarded-Proto</td>
<td>原方案的值 (HTTP/HTTPS)。 如果请求已遍历多个代理，则该值也可以是方案列表。</td>
</tr>
<tr>
<td>X-Forwarded-Host</td>
<td>主机标头字段的原始值。 代理通常不会修改主机标头。 有关特权提升漏洞的信息，请参阅 <a href="https://github.com/aspnet/Announcements/issues/295">Microsoft 安全公告 CVE-2018-0787</a>，该漏洞影响代理未验证或将主机标头限制为已知正确值的系统。</td>
</tr>
</tbody>
</table>
<p>来自 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.HttpOverrides/">Microsoft.AspNetCore.HttpOverrides</a> 包的转接头中间件读取这些标头，并填充 &lt;xref:Microsoft.AspNetCore.Http.HttpContext&gt; 上的关联字段。</p>
<p>中间件更新：</p>
<ul>
<li><a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress">HttpContext.Connection.RemoteIpAddress</a>：使用 <code>X-Forwarded-For</code> 标头值设置。 影响中间件如何设置 <code>RemoteIpAddress</code> 的其他设置。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>。</li>
<li><a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Scheme">HttpContext.Request.Scheme</a>：使用 <code>X-Forwarded-Proto</code> 标头值设置。</li>
<li><a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Host">HttpContext.Request.Host</a>：使用 <code>X-Forwarded-Host</code> 标头值设置。</li>
</ul>
<p>可以配置转接头中间件<a href="#forwarded-headers-middleware-options">默认设置</a>。 默认设置为：</p>
<ul>
<li>应用和请求源之间只有一个代理**。</li>
<li>仅将环回地址配置为已知代理和已知网络。</li>
<li>转接头被命名为 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code>。</li>
</ul>
<p>并非所有网络设备均可在没有其他配置的情况下添加 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头。 如果代理请求在到达应用时未包含这些标头，请查阅设备制造商提供的指导。 如果设备使用 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 以外的其他标头名称，请设置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt; 选项，使其与设备所用的标头名称相匹配。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>和<a href="#configuration-for-a-proxy-that-uses-different-header-names">配置使用不同标头名称的代理</a>。</p>
<h2 id="iisiis-express-and-aspnet-core-module">IIS/IIS Express 和 ASP.NET Core 模块</h2>
<p>当应用托管在 IIS 和 ASP.NET Core 模块后方的<a class="xref" href="iis/index.html#out-of-process-hosting-model">进程外</a>时，转接头中间件由 <a class="xref" href="iis/index.html#enable-the-iisintegration-components">IIS 集成中间件</a>默认启用。 由于转接头的信任问题（例如，<a href="https://www.iplocation.net/ip-spoofing">IP 欺骗</a>），转接头中间件被激活为首先在中间件管道中运行，并具有特定于 ASP.NET Core 模块的受限配置。 中间件配置为转接 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头，并且被限制到单个本地 localhost 代理。 如果需要其他配置，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>。</p>
<h2 id="other-proxy-server-and-load-balancer-scenarios">其他代理服务器和负载均衡器方案</h2>
<p>除在<a class="xref" href="iis/index.html#out-of-process-hosting-model">进程外</a>托管时使用 <a class="xref" href="iis/index.html#enable-the-iisintegration-components">IIS 集成</a>之外，不会默认启用转接头中间件。 必须启用应用的转接头中间件才能处理带有 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 的转接头。 启用中间件后，如果没有为中间件指定 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt;，那么默认的 <a href="xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders">ForwardedHeadersOptions.ForwardedHeaders</a> 是 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。</p>
<p>为中间件配置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt; 以转接 <code>Startup.ConfigureServices</code> 中的 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头。 调用其他中间件之前，先调用 <code>Startup.Configure</code> 中的 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 方法：</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
    {
        options.ForwardedHeaders = 
            ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseForwardedHeaders();

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
    }

    app.UseStaticFiles();
    // In ASP.NET Core 1.x, replace the following line with: app.UseIdentity();
    app.UseAuthentication();
    app.UseMvc();
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>如果没有在 <code>Startup.ConfigureServices</code> 中指定任何 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt;，或未使用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 直接指定到扩展方法，则要转接的默认标头为 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。 必须为 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders&gt; 属性配置要转接的标头。</p>
</div>
<h2 id="nginx-configuration">Nginx 配置</h2>
<p>要转发 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 标头，请参阅 <a class="xref" href="linux-nginx.html#configure-nginx">使用 Nginx 在 Linux 上托管 ASP.NET Core</a>。 有关详细信息，请参阅 <a href="https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/">NGINX：使用转发标头</a>。</p>
<h2 id="apache-configuration">Apache 配置</h2>
<p><code>X-Forwarded-For</code> 将会自动添加（请参阅 <a href="https://httpd.apache.org/docs/2.4/mod/mod_proxy.html#x-headers">Apache 模块 mod_proxy：反向代理请求标头</a>）。 要了解如何转发 <code>X-Forwarded-Proto</code> 标头，请参阅 <a class="xref" href="linux-apache.html#configure-apache">使用 Apache 在 Linux 上托管 ASP.NET Core</a>。</p>
<h2 id="forwarded-headers-middleware-options">转接头中间件选项</h2>
<p>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions&gt; 控制转接头中间件的行为。 以下示例更改了默认值：</p>
<ul>
<li>将转接头中的条目数量限制为 <code>2</code>。</li>
<li>添加已知的代理地址 <code>127.0.10.1</code>。</li>
<li>将转接头名称从默认的 <code>X-Forwarded-For</code> 更改为 <code>X-Forwarded-For-My-Custom-Header-Name</code>。</li>
</ul>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardLimit = 2;
    options.KnownProxies.Add(IPAddress.Parse(&quot;127.0.10.1&quot;));
    options.ForwardedForHeaderName = &quot;X-Forwarded-For-My-Custom-Header-Name&quot;;
});
</code></pre>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.AllowedHosts&gt;</td>
<td>通过 <code>X-Forwarded-Host</code> 标头将主机限制为提供的值。<ul><li>使用 ordinal-ignore-case 比较值。</li><li>必须排除端口号。</li><li>如果列表为空，则允许使用所有主机。</li><li>顶级通配符 <code>*</code> 允许所有非空主机。</li><li>子域通配符允许使用，但不匹配根域。 例如，<code>*.contoso.com</code> 匹配子域 <code>foo.contoso.com</code>，但不匹配根域 <code>contoso.com</code>。</li><li>允许使用 Unicode 主机名，但应转换为 <a href="https://tools.ietf.org/html/rfc3492">Punycode</a> 进行匹配。</li><li><a href="https://tools.ietf.org/html/rfc4291">IPv6 地址</a>必须包括边界方括号，而且必须位于<a href="https://tools.ietf.org/html/rfc4291#section-2.2">常规窗体</a>（例如，<code>[ABCD:EF01:2345:6789:ABCD:EF01:2345:6789]</code>）中。 IPv6 地址并非专门用于检查不同格式之间的逻辑相等性，也不执行标准化。</li><li>未能限制允许的主机可能会允许攻击者访问该服务生成的欺骗链接。</li></ul>默认值为空的 <code>IList&lt;string&gt;</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedForHeaderName">ForwardedHeadersDefaults.XForwardedForHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-For</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-For</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders&gt;</td>
<td>标识应处理的转发器。 对于应用的字段的列表，请参阅 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders 枚举</a>。 分配给此属性的典型值为 <code>ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto</code>。<br><br>默认值是 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders">ForwardedHeaders.None</a>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHostHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedHostHeaderName">ForwardedHeadersDefaults.XForwardedHostHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-Host</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-Host</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XForwardedProtoHeaderName">ForwardedHeadersDefaults.XForwardedProtoHeaderName</a> 指定的标头。 如果代理/转发器不使用 <code>X-Forwarded-Proto</code> 标头，但使用一些其他标头来转发信息，则使用此选项。<br><br>默认值为 <code>X-Forwarded-Proto</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardLimit&gt;</td>
<td>限制所处理的标头中的条目数。 设置为 <code>null</code> 以禁用此限制，但仅应在已配置 <code>KnownProxies</code> 或 <code>KnownNetworks</code> 的情况下执行此操作。 设置非 <code>null</code> 值是一种预防措施（但不是保证），防止错误配置的代理和恶意请求从网络的侧通道到达。<br><br>转接头中间件按照从右向左的相反顺序处理标头。 如果使用默认值 (<code>1</code>)，则只会处理标头最右侧的值，除非增加 <code>ForwardLimit</code> 的值。<br><br>默认值为 <code>1</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.KnownNetworks&gt;</td>
<td>从中接受转接头的已知网络的地址范围。 使用无类别域际路由选择 (CIDR) 表示法提供 IP 范围。<br><br>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。 有关详细信息，请参阅<a href="#configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</a>部分。<br><br>默认值是 <code>IList</code>&lt;&lt;xref:Microsoft.AspNetCore.HttpOverrides.IPNetwork&gt;&gt;，其中包含 <code>IPAddress.Loopback</code> 的单个条目。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.KnownProxies&gt;</td>
<td>从中接受转接头的已知代理的地址。 使用 <code>KnownProxies</code> 指定精确的 IP 地址匹配。<br><br>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。 有关详细信息，请参阅<a href="#configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</a>部分。<br><br>默认值是 <code>IList</code>&lt;&lt;xref:System.Net.IPAddress&gt;&gt;，其中包含 <code>IPAddress.IPv6Loopback</code> 的单个条目。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalForHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalForHeaderName">ForwardedHeadersDefaults.XOriginalForHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-For</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalHostHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalHostHeaderName">ForwardedHeadersDefaults.XOriginalHostHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-Host</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.OriginalProtoHeaderName&gt;</td>
<td>使用由此属性指定的标头，而不是由 <a href="xref:Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersDefaults.XOriginalProtoHeaderName">ForwardedHeadersDefaults.XOriginalProtoHeaderName</a> 指定的标头。<br><br>默认值为 <code>X-Original-Proto</code>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.RequireHeaderSymmetry&gt;</td>
<td>要求正在处理的 <a href="xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedHeaders">ForwardedHeadersOptions.ForwardedHeaders</a> 之间的标头值数量保持同步。<br><br>ASP.NET Core 1.x 默认值是 <code>true</code>。 ASP.NET Core 2.0 默认值是 <code>false</code>。</td>
</tr>
</tbody>
</table>
<h2 id="scenarios-and-use-cases">方案与使用案例</h2>
<h3 id="when-it-isnt-possible-to-add-forwarded-headers-and-all-requests-are-secure">无法添加转接头并且所有请求都安全的情况</h3>
<p>在某些情况下，可能无法将转接头添加到代理到应用的请求中。 如果代理强制将所有公共外部请求执行为 HTTPS，则在使用任何类型的中间件之前，可以在 <code>Startup.Configure</code> 中手动设置该方案：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    context.Request.Scheme = &quot;https&quot;;
    return next();
});
</code></pre>
<p>此代码可以通过环境变量或者开发环境或过渡环境中的其他配置设置来禁用。</p>
<h3 id="deal-with-path-base-and-proxies-that-change-the-request-path">处理改变请求路径的基路径和代理</h3>
<p>一些代理可完整地传递路径，但是会删除应用基路径以便路由可正常工作。 <a href="xref:Microsoft.AspNetCore.Builder.UsePathBaseExtensions.UsePathBase*">UsePathBaseExtensions.UsePathBase</a> 中间件将路径拆分为 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.Path">HttpRequest.Path</a>，将应用基路径拆分为 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.PathBase">HttpRequest.PathBase</a>。</p>
<p>如果 <code>/foo</code> 是作为 <code>/foo/api/1</code> 传递的代理路径的应用基路径，则中间件使用以下命令将 <code>Request.PathBase</code> 设置为 <code>/foo</code>，将 <code>Request.Path</code> 设置为 <code>/api/1</code>：</p>
<pre><code class="lang-csharp">app.UsePathBase(&quot;/foo&quot;);
</code></pre>
<p>当再次反向调用中间件时，将重新应用原始路径和基路径。 要详细了解中间件处理顺序，请参阅 <a class="xref" href="../fundamentals/middleware/index.html">ASP.NET Core 中间件</a>。</p>
<p>如果代理剪裁路径（例如，将 <code>/foo/api/1</code> 转接到 <code>/api/1</code>），请通过设置请求的 <a href="xref:Microsoft.AspNetCore.Http.HttpRequest.PathBase">PathBase</a> 属性来修复重定向和链接：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    context.Request.PathBase = new PathString(&quot;/foo&quot;);
    return next();
});
</code></pre>
<p>如果代理要添加路径数据，请使用 &lt;xref:Microsoft.AspNetCore.Http.PathString.StartsWithSegments*&gt; 并分配给 &lt;xref:Microsoft.AspNetCore.Http.HttpRequest.Path&gt; 属性，从而放弃部分路径以修复重定向和链接：</p>
<pre><code class="lang-csharp">app.Use((context, next) =&gt;
{
    if (context.Request.Path.StartsWithSegments(&quot;/foo&quot;, out var remainder))
    {
        context.Request.Path = remainder;
    }

    return next();
});
</code></pre>
<h3 id="configuration-for-a-proxy-that-uses-different-header-names">配置使用不同标头名称的代理</h3>
<p>如果代理不使用名为 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 的标头来转发代理地址/端口和原始架构信息，则设置 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedForHeaderName&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersOptions.ForwardedProtoHeaderName&gt; 选项，使其与代理所用的标头名称相匹配：</p>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardedForHeaderName = &quot;Header_Name_Used_By_Proxy_For_X-Forwarded-For_Header&quot;;
    options.ForwardedProtoHeaderName = &quot;Header_Name_Used_By_Proxy_For_X-Forwarded-Proto_Header&quot;;
});
</code></pre>
<h3 id="configuration-for-an-ipv4-address-represented-as-an-ipv6-address">对表示为 IPv6 地址的 IPv4 地址进行配置</h3>
<p>如果服务器使用双模式套接字，则采用 IPv6 格式提供 IPv4 地址（例如，IPv4 格式的 <code>10.0.0.1</code> 以 IPv6 格式表示为 <code>::ffff:10.0.0.1</code> 或 <code>::ffff:a00:1</code>）。 请参阅 <a href="xref:System.Net.IPAddress.MapToIPv6*">IPAddress.MapToIPv6</a>。 通过查看 <a href="xref:Microsoft.AspNetCore.Http.ConnectionInfo.RemoteIpAddress*">HttpContext.Connection.RemoteIpAddress</a> 来确定是否需要采用此格式。</p>
<p>在以下示例中，提供转接头的网络地址以 IPv6 格式添加到 <code>KnownNetworks</code> 列表中。</p>
<p>IPv4 地址：<code>10.11.12.1/8</code></p>
<p>转换后的 IPv6 地址：<code>::ffff:10.11.12.1</code><br>
转换后的前缀长度：104</p>
<p>也可以提供十六进制格式的地址（<code>10.11.12.1</code> 以 IPv6 格式表示为 <code>::ffff:0a0b:0c01</code>）。 将 IPv4 地址转换为 IPv6 时，将 96 添加到 CIDR 前缀长度（示例中的 <code>8</code>）以说明其他 <code>::ffff:</code> IPv6 前缀 (8 + 96 = 104)。</p>
<pre><code class="lang-csharp">// To access IPNetwork and IPAddress, add the following namespaces:
// using System.Net;
// using Microsoft.AspNetCore.HttpOverrides;
services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.ForwardedHeaders =
        ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
    options.KnownNetworks.Add(new IPNetwork(
        IPAddress.Parse(&quot;::ffff:10.11.12.1&quot;), 104));
});
</code></pre>
<h2 id="forward-the-scheme-for-linux-and-non-iis-reverse-proxies">转发 Linux 和非 IIS 反向代理的方案</h2>
<p>如果将站点部署到 Azure Linux 应用服务、Azure Linux 虚拟机 (VM)，或者部署到除 IIS 之外的任何其他反向代理之后，调用 &lt;xref:Microsoft.AspNetCore.Builder.HttpsPolicyBuilderExtensions.UseHttpsRedirection*&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.HstsBuilderExtensions.UseHsts*&gt; 的应用都会使站点进入无限循环。 反向代理终止 TLS，并且 Kestrel 未发现正确的请求方案。 由于 OAuth 和 OIDC 生成了错误的重定向，因此它们在此配置中也会出现故障。 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilderIISExtensions.UseIISIntegration*&gt; 在 IIS 之后运行时会添加和配置转接头中间件，但 Linux（Apache 或 Nginx 集成）没有匹配的自动配置。</p>
<p>要从非 IIS 方案中的代理中转发方案，请添加并配置转接头中间件。 在 <code>Startup.ConfigureServices</code> 中，使用以下代码：</p>
<pre><code class="lang-csharp">// using Microsoft.AspNetCore.HttpOverrides;

if (string.Equals(
    Environment.GetEnvironmentVariable(&quot;ASPNETCORE_FORWARDEDHEADERS_ENABLED&quot;), 
    &quot;true&quot;, StringComparison.OrdinalIgnoreCase))
{
    services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
    {
        options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | 
            ForwardedHeaders.XForwardedProto;
        // Only loopback proxies are allowed by default.
        // Clear that restriction because forwarders are enabled by explicit 
        // configuration.
        options.KnownNetworks.Clear();
        options.KnownProxies.Clear();
    });
}
</code></pre>
<h2 id="troubleshoot">疑难解答</h2>
<p>如果未按预期转接标头，请启用<a class="xref" href="../fundamentals/logging/index.html">日志记录</a>。 如果日志没有提供足够的信息来解决问题，请枚举服务器收到的请求标头。 使用内联中间件将请求标头写入应用程序响应或记录标头。</p>
<p>要将标头写入应用的响应，请在 <code>Startup.Configure</code> 中调用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 后立即放置以下终端内联中间件：</p>
<pre><code class="lang-csharp">app.Run(async (context) =&gt;
{
    context.Response.ContentType = &quot;text/plain&quot;;

    // Request method, scheme, and path
    await context.Response.WriteAsync(
        $&quot;Request Method: {context.Request.Method}{Environment.NewLine}&quot;);
    await context.Response.WriteAsync(
        $&quot;Request Scheme: {context.Request.Scheme}{Environment.NewLine}&quot;);
    await context.Response.WriteAsync(
        $&quot;Request Path: {context.Request.Path}{Environment.NewLine}&quot;);

    // Headers
    await context.Response.WriteAsync($&quot;Request Headers:{Environment.NewLine}&quot;);

    foreach (var header in context.Request.Headers)
    {
        await context.Response.WriteAsync($&quot;{header.Key}: &quot; +
            $&quot;{header.Value}{Environment.NewLine}&quot;);
    }

    await context.Response.WriteAsync(Environment.NewLine);

    // Connection: RemoteIp
    await context.Response.WriteAsync(
        $&quot;Request RemoteIp: {context.Connection.RemoteIpAddress}&quot;);
});
</code></pre>
<p>可以写入日志，而不是响应正文。 借助写入日志，站点可在调试时正常运行。</p>
<p>要写入日志而不是响应正文，请执行以下操作：</p>
<ul>
<li>将 <code>ILogger&lt;Startup&gt;</code> 注入到 <code>Startup</code> 类中，如<a class="xref" href="../fundamentals/logging/index.html#create-logs-in-startup">在启动时创建日志</a>中所述。</li>
<li>在 <code>Startup.Configure</code> 中调用 &lt;xref:Microsoft.AspNetCore.Builder.ForwardedHeadersExtensions.UseForwardedHeaders*&gt; 之后，立即放置以下内联中间件。</li>
</ul>
<pre><code class="lang-csharp">app.Use(async (context, next) =&gt;
{
    // Request method, scheme, and path
    _logger.LogDebug(&quot;Request Method: {Method}&quot;, context.Request.Method);
    _logger.LogDebug(&quot;Request Scheme: {Scheme}&quot;, context.Request.Scheme);
    _logger.LogDebug(&quot;Request Path: {Path}&quot;, context.Request.Path);

    // Headers
    foreach (var header in context.Request.Headers)
    {
        _logger.LogDebug(&quot;Header: {Key}: {Value}&quot;, header.Key, header.Value);
    }

    // Connection: RemoteIp
    _logger.LogDebug(&quot;Request RemoteIp: {RemoteIpAddress}&quot;, 
        context.Connection.RemoteIpAddress);

    await next();
});
</code></pre>
<p>处理时，<code>X-Forwarded-{For|Proto|Host}</code> 值将移至 <code>X-Original-{For|Proto|Host}</code>。 如果给定标头中有多个值，则转接头中间件按照从右向左的相反顺序处理标头。 默认 <code>ForwardLimit</code> 为 <code>1</code>（一），因此只会处理标头最右侧的值，除非增加 <code>ForwardLimit</code> 的值。</p>
<p>在处理转接头之前，请求的原始远程 IP 必须与 <code>KnownProxies</code> 或 <code>KnownNetworks</code> 列表中的条目匹配。 这通过不接受来自不受信任的代理的转发器来限制标头欺骗。 检测到未知代理时，日志记录会指出代理的地址：</p>
<pre><code class="lang-console">September 20th 2018, 15:49:44.168 Unknown proxy: 10.0.0.100:54321
</code></pre>
<p>在上述示例中，10.0.0.100 是代理服务器。 如果该服务器是受信任的代理，请将服务器的 IP 地址添加到 <code>Startup.ConfigureServices</code> 中的 <code>KnownProxies</code>（或将受信任的网络添加到 <code>KnownNetworks</code>）。 有关详细信息，请参阅<a href="#forwarded-headers-middleware-options">转接头中间件选项</a>部分。</p>
<pre><code class="lang-csharp">services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;
{
    options.KnownProxies.Add(IPAddress.Parse(&quot;10.0.0.100&quot;));
});
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>仅允许受信任的代理和网络转接头。 否则，可能会受到 <a href="https://www.iplocation.net/ip-spoofing">IP 欺骗</a>攻击。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="web-farm.html">在 Web 场中托管 ASP.NET Core</a></li>
<li><a href="https://github.com/aspnet/Announcements/issues/295">Microsoft 安全公告 CVE-2018-0787：ASP.NET Core 特权提升漏洞</a></li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
