<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core 3.0 &#30340;&#26032;&#22686;&#21151;&#33021; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core 3.0 &#30340;&#26032;&#22686;&#21151;&#33021; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="aspnetcore-3.0">
<h1 id="whats-new-in-aspnet-core-30">ASP.NET Core 3.0 的新增功能</h1>

<p>本文重点介绍 ASP.NET Core 3.0 中最重要的更改，并提供相关文档的链接。</p>
<h2 id="blazor">Blazor</h2>
<p>Blazor 是 ASP.NET Core 中的新框架，用于使用 .NET 生成交互式客户端 Web UI：</p>
<ul>
<li>使用 C# 代替 JavaScript 来创建丰富的交互式 UI。</li>
<li>共享使用 .NET 编写的服务器端和客户端应用逻辑。</li>
<li>将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。</li>
</ul>
<p>Blazor 框架支持的方案：</p>
<ul>
<li>可重用的 UI 组件（Razor 组件）</li>
<li>客户端路由</li>
<li>组件布局</li>
<li>对依赖项注入的支持</li>
<li>窗体和验证</li>
<li>用 Razor 类库构建组件库</li>
<li>JavaScript 互操作</li>
</ul>
<p>有关详细信息，请参阅 <a class="xref" href="../blazor/index.html">ASP.NET Core Blazor 简介</a>。</p>
<h3 id="blazor-server">Blazor Server</h3>
<p>Blazor 将组件呈现逻辑从 UI 更新的应用方式中分离出来。 Blazor Server在 ASP.NET Core 应用中支持在服务器上托管 Razor 组件。 可通过 SignalR 连接处理 UI 更新。 ASP.NET Core 3.0 支持 Blazor Server。</p>
<h3 id="no-locblazor-webassembly-preview">Blazor WebAssembly（预览版）</h3>
<p>还可以使用基于 WebAssembly 的 .NET 运行时直接在浏览器中运行 Blazor 应用。 Blazor WebAssembly 处于预览版阶段，ASP.NET Core 3.0 不提供支持。 ASP.NET Core 的未来版本将支持 Blazor WebAssembly。</p>
<h3 id="no-locrazor-components">Razor 组件</h3>
<p>Blazor 应用是基于组件构建的。 组件是自包含的用户界面 (UI) 块，例如页、对话框或窗体。 组件是定义 UI 呈现逻辑和客户端事件处理程序的普通 .NET 类。 无需 JavaScript 即可创建丰富的交互式 Web 应用。</p>
<p>通常使用 Razor 语法（HTML 和 C# 的自然混合）创建 Blazor 中的组件。 Razor 组件与 Razor Pages 和 MVC 视图类似，因为它们都使用 Razor。 与基于请求-响应模型的页和视图不同，组件专门用于处理 UI 构成。</p>
<h2 id="grpc">gRPC</h2>
<p><a href="https://grpc.io/">gRPC</a>：</p>
<ul>
<li><p>是一个流行的高性能 RPC（远程过程调用）框架。</p>
</li>
<li><p>提供固定的协定优先方法进行 API 开发。</p>
</li>
<li><p>使用的新式技术如下：</p>
<ul>
<li>用于传输的 HTTP/2。</li>
<li>作为接口描述语言的协议缓冲区。</li>
<li>二进制序列化格式。</li>
</ul>
</li>
<li><p>提供如下功能：</p>
<ul>
<li>身份验证</li>
<li>双向流式处理和流控制。</li>
<li>取消和超时。</li>
</ul>
</li>
</ul>
<p>ASP.NET Core 3.0 中的 gRPC 功能包括：</p>
<ul>
<li><a href="https://www.nuget.org/packages/Grpc.AspNetCore">Grpc.AspNetCore</a>：用于托管 gRPC 服务的 ASP.NET Core 框架。 ASP.NET Core 上的 gRPC 与标准 ASP.NET Core 功能（例如日志记录、依赖关系注入 (DI)、身份验证和授权）集成。</li>
<li><a href="https://www.nuget.org/packages/Grpc.Net.Client">Grpc.Net.Client</a>：基于熟悉的 <code>HttpClient</code> 构建的 .NET Core 的 gRPC 客户端。</li>
<li><a href="https://www.nuget.org/packages/Grpc.Net.ClientFactory">Grpc.Net.ClientFactory</a>：gRPC 客户端与 <code>HttpClientFactory</code> 的集成。</li>
</ul>
<p>有关详细信息，请参阅 <a class="xref" href="../grpc/index.html">.NET Core 上的 gRPC 的简介</a>。</p>
<h2 id="signalr">SignalR</h2>
<p>有关迁移说明，请参阅<a class="xref" href="../migration/22-to-30.html#signalr">更新 </a> 代码SignalR。 SignalR 现在使用 <code>System.Text.Json</code> 来序列化/反序列化 JSON 消息。 有关还原基于 <code>Newtonsoft.Json</code> 的序列化程序的说明，请参阅<a class="xref" href="../migration/22-to-30.html#switch-to-newtonsoftjson">切换到 Newtonsoft.Json</a>。</p>
<p>在 SignalR 的 JavaScript 和 .NET 客户端中，添加了自动重新连接支持。 默认情况下，客户端会立即尝试重新连接，并根据需要分别在 2 秒、10 秒和 30 秒后重试。 如果客户端成功重新连接，则会收到新的连接 ID。 选择启用自动重新连接：</p>
<pre><code class="lang-javascript">const connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .withAutomaticReconnect()
    .build();
</code></pre>
<p>可以通过传递基于毫秒的持续时间数组来指定重新连接间隔：</p>
<pre><code class="lang-javascript">.withAutomaticReconnect([0, 3000, 5000, 10000, 15000, 30000])
//.withAutomaticReconnect([0, 2000, 10000, 30000]) The default intervals.
</code></pre>
<p>可以通过传入自定义实现来完全控制重新连接间隔。</p>
<p>如果在上一次重新连接间隔后重新连接失败：</p>
<ul>
<li>客户端认为连接处于脱机状态。</li>
<li>客户端将停止尝试重新连接。</li>
</ul>
<p>尝试重新连接时，更新应用 UI，通知用户正在尝试重新连接。</p>
<p>为了在连接中断时提供 UI 反馈，SignalR 客户端 API 已扩展为包含以下事件处理程序：</p>
<ul>
<li><code>onreconnecting</code>：使开发人员有机会禁用 UI 或允许用户了解应用程序处于脱机状态。</li>
<li><code>onreconnected</code>：使开发人员有机会在重新建立连接后更新 UI。</li>
</ul>
<p>以下代码在尝试连接时使用 <code>onreconnecting</code> 更新 UI：</p>
<pre><code class="lang-javascript">connection.onreconnecting((error) =&gt; {
    const status = `Connection lost due to error &quot;${error}&quot;. Reconnecting.`;
    document.getElementById(&quot;messageInput&quot;).disabled = true;
    document.getElementById(&quot;sendButton&quot;).disabled = true;
    document.getElementById(&quot;connectionStatus&quot;).innerText = status;
});
</code></pre>
<p>以下代码在连接时使用 <code>onreconnected</code> 更新 UI：</p>
<pre><code class="lang-javascript">connection.onreconnected((connectionId) =&gt; {
    const status = `Connection reestablished. Connected.`;
    document.getElementById(&quot;messageInput&quot;).disabled = false;
    document.getElementById(&quot;sendButton&quot;).disabled = false;
    document.getElementById(&quot;connectionStatus&quot;).innerText = status;
});
</code></pre>
<p>当中心方法要求授权时，SignalR 3.0 和更高版本为授权处理程序提供了一个自定义资源。 资源是 <code>HubInvocationContext</code> 的一个实例。 <code>HubInvocationContext</code> 包括：</p>
<ul>
<li><code>HubCallerContext</code></li>
<li>正在调用的中心方法的名称。</li>
<li>中心方法的参数。</li>
</ul>
<p>请考虑以下通过 Azure Active Directory 允许多个组织登录的聊天室应用示例。 拥有 Microsoft 帐户的任何人都可以登录到聊天，但只有所属组织的成员才能阻止用户或查看用户的聊天历史记录。 该应用可以限制特定用户的某些功能。</p>
<pre><code class="lang-csharp">public class DomainRestrictedRequirement :
    AuthorizationHandler&lt;DomainRestrictedRequirement, HubInvocationContext&gt;,
    IAuthorizationRequirement
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        DomainRestrictedRequirement requirement,
        HubInvocationContext resource)
    {
        if (context.User?.Identity?.Name == null)
        {
            return Task.CompletedTask;
        }

        if (IsUserAllowedToDoThis(resource.HubMethodName, context.User.Identity.Name))
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }

    private bool IsUserAllowedToDoThis(string hubMethodName, string currentUsername)
    {
        if (hubMethodName.Equals(&quot;banUser&quot;, StringComparison.OrdinalIgnoreCase))
        {
            return currentUsername.Equals(&quot;bob42@jabbr.net&quot;, StringComparison.OrdinalIgnoreCase);
        }

        return currentUsername.EndsWith(&quot;@jabbr.net&quot;, StringComparison.OrdinalIgnoreCase));
    }
}
</code></pre>
<p>在前面的代码中，<code>DomainRestrictedRequirement</code> 作为自定义 <code>IAuthorizationRequirement</code>。 由于正在传入 <code>HubInvocationContext</code> 资源参数，因此内部逻辑可以：</p>
<ul>
<li>检查在其中调用中心的上下文。</li>
<li>做出允许用户执行单个中心方法的决策。</li>
</ul>
<p>可以通过代码在运行时检查的策略的名称来标记单个中心方法。 当客户端尝试调用单个中心方法时，<code>DomainRestrictedRequirement</code> 处理程序将运行并控制对方法的访问。 基于 <code>DomainRestrictedRequirement</code> 控制访问的方式：</p>
<ul>
<li>所有已登录的用户都可以调用 <code>SendMessage</code> 方法。</li>
<li>只有使用 <code>@jabbr.net</code> 电子邮件地址登录的用户才能查看用户的历史记录。</li>
<li>只有 <code>bob42@jabbr.net</code> 才能阻止用户进入聊天室。</li>
</ul>
<pre><code class="lang-csharp">[Authorize]
public class ChatHub : Hub
{
    public void SendMessage(string message)
    {
    }

    [Authorize(&quot;DomainRestricted&quot;)]
    public void BanUser(string username)
    {
    }

    [Authorize(&quot;DomainRestricted&quot;)]
    public void ViewUserHistory(string username)
    {
    }
}
</code></pre>
<p>创建 <code>DomainRestricted</code> 策略可能涉及：</p>
<ul>
<li>在 Startup.cs 中，添加新策略。</li>
<li>提供自定义 <code>DomainRestrictedRequirement</code> 要求作为参数。</li>
<li>向授权中间件注册 <code>DomainRestricted</code>。</li>
</ul>
<pre><code class="lang-csharp">services
    .AddAuthorization(options =&gt;
    {
        options.AddPolicy(&quot;DomainRestricted&quot;, policy =&gt;
        {
            policy.Requirements.Add(new DomainRestrictedRequirement());
        });
    });
</code></pre>
<p>SignalR 中心使用<a class="xref" href="../fundamentals/routing.html">终结点路由</a>。 以前 SignalR 中心连接是显式完成的：</p>
<pre><code class="lang-csharp">app.UseSignalR(routes =&gt;
{
    routes.MapHub&lt;ChatHub&gt;(&quot;hubs/chat&quot;);
});
</code></pre>
<p>在以前的版本中，开发人员需要将控制器、Razor 页面和中心连接到各种位置。 显式连接会生成一系列几乎相同的路由段：</p>
<pre><code class="lang-csharp">app.UseSignalR(routes =&gt;
{
    routes.MapHub&lt;ChatHub&gt;(&quot;hubs/chat&quot;);
});

app.UseRouting(routes =&gt;
{
    routes.MapRazorPages();
});
</code></pre>
<p>可以通过终结点路由来路由 SignalR 3.0 中心。 通过终结点路由，通常可以在 <code>UseRouting</code> 中配置所有路由：</p>
<pre><code class="lang-csharp">app.UseRouting(routes =&gt;
{
    routes.MapRazorPages();
    routes.MapHub&lt;ChatHub&gt;(&quot;hubs/chat&quot;);
});
</code></pre>
<p>ASP.NET Core 3.0 SignalR 添加了：</p>
<p>客户端到服务器的流式处理。 使用客户端到服务器的流式处理时，服务器端方法可以获取 <code>IAsyncEnumerable&lt;T&gt;</code> 或 <code>ChannelReader&lt;T&gt;</code> 的实例。 在下面的 C# 示例中，中心上的 <code>UploadStream</code> 方法将从客户端接收字符串流：</p>
<pre><code class="lang-csharp">public async Task UploadStream(IAsyncEnumerable&lt;string&gt; stream)
{
    await foreach (var item in stream)
    {
        // process content
    }
}
</code></pre>
<p>.NET 客户端应用程序可以将 <code>IAsyncEnumerable&lt;T&gt;</code> 或 <code>ChannelReader&lt;T&gt;</code> 实例作为上述 <code>UploadStream</code> 中心方法的 <code>stream</code> 参数传递。</p>
<p><code>for</code> 循环完成并且本地函数退出后，将发送流完成：</p>
<pre><code class="lang-csharp">async IAsyncEnumerable&lt;string&gt; clientStreamData()
{
    for (var i = 0; i &lt; 5; i++)
    {
        var data = await FetchSomeData();
        yield return data;
    }
}

await connection.SendAsync(&quot;UploadStream&quot;, clientStreamData());
</code></pre>
<p>JavaScript 客户端应用将 SignalR <code>Subject</code>（或 <a href="https://rxjs.dev/api/index/class/Subject">RxJS 主题</a>）用于上面的 <code>UploadStream</code> 中心方法的 <code>stream</code> 参数。</p>
<pre><code class="lang-javascript">let subject = new signalR.Subject();
await connection.send(&quot;StartStream&quot;, &quot;MyAsciiArtStream&quot;, subject);
</code></pre>
<p>当字符串被捕获并准备发送给服务器时，JavaScript 代码可以使用 <code>subject.next</code> 方法处理字符串。</p>
<pre><code class="lang-javascript">subject.next(&quot;example&quot;);
subject.complete();
</code></pre>
<p>使用类似于上述两个代码片段的代码，可创建实时流式处理体验。</p>
<h2 id="new-json-serialization">新的 JSON 序列化</h2>
<p>ASP.NET Core 3.0 现在默认使用 &lt;xref:System.Text.Json&gt; 进行 JSON 序列化：</p>
<ul>
<li>以异步方式读取和写入 JSON。</li>
<li>针对 UTF-8 文本进行了优化。</li>
<li>通常比 <code>Newtonsoft.Json</code> 性能更高。</li>
</ul>
<p>若要将 Json.NET 添加到 ASP.NET Core 3.0，请参阅<a class="xref" href="../web-api/advanced/formatting.html#add-newtonsoftjson-based-json-format-support">添加基于 Newtonsoft.Json 的 JSON 格式支持</a>。</p>
<h2 id="new-no-locrazor-directives">新的 Razor 指令</h2>
<p>下面的列表包含新的 Razor 指令：</p>
<ul>
<li><a class="xref" href="../mvc/views/razor.html#attribute"><code>@attribute</code></a>：<code>@attribute</code> 指令将给定的属性应用于生成的页或视图的类。 例如 <code>@attribute [Authorize]</code>。</li>
<li><a class="xref" href="../mvc/views/razor.html#implements"><code>@implements</code></a>：<code>@implements</code> 指令为生成的类实现接口。 例如 <code>@implements IDisposable</code>。</li>
</ul>
<h2 id="no-locidentityserver4-supports-authentication-and-authorization-for-web-apis-and-spas">IdentityServer4 支持 Web API 和 SPA 的身份验证和授权</h2>
<p>ASP.NET Core 3.0 使用 Web API 授权的支持在单页应用 (SPA) 中提供身份验证。 ASP.NET Core Identity 与 <a href="https://identityserver.io/">IdentityServer4</a> 结合使用，前者用于验证和存储用户身份信息，后者用于实现 OpenID Connect。</p>
<p>IdentityServer4 是适用于 ASP.NET Core 3.0 的 OpenID Connect 和 OAuth 2.0 框架。 它提供了以下安全功能：</p>
<ul>
<li>身份验证即服务 (AaaS)</li>
<li>跨多个应用程序类型的单一登录/注销 (SSO)</li>
<li>API 的访问控制</li>
<li>Federation Gateway</li>
</ul>
<p>有关详细信息，请参阅 <a href="http://docs.identityserver.io/en/latest/index.html">IdentityServer4 文档</a>或 <a class="xref" href="../security/authentication/identity-api-authorization.html">SPA 的身份验证和授权</a>。</p>
<h2 id="certificate-and-kerberos-authentication">证书和 Kerberos 身份验证</h2>
<p>证书身份验证需要：</p>
<ul>
<li>将服务器配置为接受证书。</li>
<li>在 <code>Startup.Configure</code> 中添加身份验证中间件。</li>
<li>将证书身份验证服务添加到 <code>Startup.ConfigureServices</code>。</li>
</ul>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(
        CertificateAuthenticationDefaults.AuthenticationScheme)
            .AddCertificate();
    // Other service configuration removed.
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseAuthentication();
    // Other app configuration removed.
}
</code></pre>
<p>用于证书身份验证的选项包括执行以下操作的能力：</p>
<ul>
<li>接受自签名证书。</li>
<li>检查证书吊销。</li>
<li>检查提供证书中是否有正确的使用标志。</li>
</ul>
<p>默认的用户主体是从证书属性构造的。 用户主体包含允许补充或替换主体的事件。 有关详细信息，请参阅 <a class="xref" href="../security/authentication/certauth.html">在 ASP.NET Core 中配置证书身份验证</a>。</p>
<p><a href="/windows-server/security/windows-authentication/windows-authentication-overview">Windows 身份验证</a>已扩展到 Linux 和 macOS。 在以前的版本中，Windows 身份验证限制为 <a class="xref" href="../host-and-deploy/iis/index.html">IIS</a> 和 <a class="xref" href="../fundamentals/servers/httpsys.html">HttpSys</a>。 在 ASP.NET Core 3.0 中，<a class="xref" href="../fundamentals/servers/kestrel.html">Kestrel</a> 能够在 Windows、Linux 和 macOS 上对已加入 Windows 域的主机使用 Negotiate、<a href="/windows-server/security/kerberos/kerberos-authentication-overview">Kerberos</a> 和 <a href="/windows-server/security/kerberos/ntlm-overview">NTLM</a>。 Kestrel 对这些身份验证方案的支持由 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Negotiate">Microsoft.AspNetCore.Authentication.Negotiate NuGet</a> 包提供。 对于其他身份验证服务，请配置身份验证应用范围，然后配置服务：</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(NegotiateDefaults.AuthenticationScheme)
        .AddNegotiate();
    // Other service configuration removed.
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseAuthentication();
    // Other app configuration removed.
}
</code></pre>
<p>主机要求：</p>
<ul>
<li>Windows 主机必须将<a href="/windows/win32/ad/service-principal-names">主体名称</a> (SPN) 添加到托管应用的用户帐户。</li>
<li>Linux 和 macOS 计算机必须加入域。
<ul>
<li>必须为 Web 进程创建 SPN。</li>
<li>必须在主机上生成并配置 <a href="/archive/blogs/pie/all-you-need-to-know-about-keytab-files">Keytab 文件</a>。</li>
</ul>
</li>
</ul>
<p>有关详细信息，请参阅 <a class="xref" href="../security/authentication/windowsauth.html">在 ASP.NET Core 中配置 Windows 身份验证</a>。</p>
<h2 id="template-changes">模板更改</h2>
<p>Web UI 模板（Razor Pages、具有控制器和视图的 MVC）已删除以下内容：</p>
<ul>
<li>cookie 同意 UI 不再包括在内。 若要在 ASP.NET Core 3.0 模板生成的应用中启用 cookie 同意功能，请参阅 <a class="xref" href="../security/gdpr.html">ASP.NET Core 中一般数据保护条例 (GDPR) 支持</a>。</li>
<li>脚本和相关静态资产现在作为本地文件（而不是使用 CDN）进行引用。 有关详细信息，<a href="https://github.com/dotnet/AspNetCore.Docs/issues/14350">脚本和相关静态资产现在基于当前环境作为本地文件（而不是使用 CDN）进行引用 (aspnet/AspNetCore.Docs #14350)</a>。</li>
</ul>
<p>Angular 模板已更新，以便使用 Angular 8。</p>
<p>默认情况下，Razor 类库 (RCL) 模板默认为 Razor 组件开发。 Visual Studio 中的新模板选项提供了对页面和视图的模板支持。 在命令行界面中通过模板创建 RCL 时，请传递 <code>--support-pages-and-views</code> 选项 (<code>dotnet new razorclasslib --support-pages-and-views</code>)。</p>
<h2 id="generic-host">泛型主机</h2>
<p>ASP.NET Core 3.0 模板使用 <a class="xref" href="../fundamentals/host/generic-host.html">ASP.NET Core 中的 .NET 通用主机</a>。 以前版本使用 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder&gt;。 使用 .NET Core 泛型主机 (&lt;xref:Microsoft.Extensions.Hosting.HostBuilder&gt;) 可以更好地将 ASP.NET Core 应用与非 Web 特定的其他服务器方案集成。 有关详细信息，请参阅 <a class="xref" href="../migration/22-to-30.html?view=aspnetcore-2.2#hostbuilder-replaces-webhostbuilder">HostBuilder 替换 WebHostBuilder</a>。</p>
<h3 id="host-configuration">主机配置</h3>
<p>在 ASP.NET Core 3.0 版本之前，为 Web 主机的主机配置加载了前缀为 <code>ASPNETCORE_</code> 的环境变量。 在 3.0 中，对于带有 <code>CreateDefaultBuilder</code> 的主机配置，使用 <code>AddEnvironmentVariables</code> 加载以 <code>DOTNET_</code> 为前缀的环境变量。</p>
<h3 id="changes-to-startup-constructor-injection">对启动构造函数注入的更改</h3>
<p>泛型主机仅支持以下类型的 <code>Startup</code> 构造函数注入：</p>
<ul>
<li>&lt;xref:Microsoft.Extensions.Hosting.IHostEnvironment&gt;</li>
<li><code>IWebHostEnvironment</code></li>
<li>&lt;xref:Microsoft.Extensions.Configuration.IConfiguration&gt;</li>
</ul>
<p>所有服务仍可以直接作为 <code>Startup.Configure</code> 方法的参数注入。 有关详细信息，请参阅<a href="https://github.com/aspnet/Announcements/issues/353">泛型主机限制启动构造函数注入 (aspnet/Announcements #353)</a>。</p>
<h2 id="kestrel">Kestrel</h2>
<ul>
<li>已更新 Kestrel 配置以迁移到泛型主机。 在 3.0 中，Kestrel 是在 <code>ConfigureWebHostDefaults</code> 提供的 Web 主机生成器上配置的。</li>
<li>已从 Kestrel 中删除连接适配器，并将其替换为连接中间件，这与 ASP.NET Core 管道中的 HTTP 中间件类似，但适用于较低级别的连接。</li>
<li>Kestrel 传输层已作为 <code>Connections.Abstractions</code> 中的公共接口公开。</li>
<li>通过将尾随标题移到新集合中，已解决了标头和尾部之间的歧义。</li>
<li>线程不足会导致应用崩溃，而同步 I/O API（例如 <code>HttpRequest.Body.Read</code>）是导致线程不足的常见原因。 在 3.0 中，默认情况下禁用 <code>AllowSynchronousIO</code>。</li>
</ul>
<p>有关详细信息，请参阅 <a class="xref" href="../migration/22-to-30.html#kestrel">从 ASP.NET Core 2.2 迁移到3。0</a>。</p>
<h2 id="http2-enabled-by-default">默认情况下启用 HTTP/2</h2>
<p>默认情况下，在 HTTPS 终结点的 Kestrel 中启用 HTTP/2。 当操作系统支持 HTTP/2 时，对 IIS 或 HTTP.sys 启用 HTTP/2 支持。</p>
<h2 id="eventcounters-on-request">根据请求提供事件计数器</h2>
<p>托管事件源 <code>Microsoft.AspNetCore.Hosting</code> 发出以下与传入请求有关的新 &lt;xref:System.Diagnostics.Tracing.EventCounter&gt; 类型：</p>
<ul>
<li><code>requests-per-second</code></li>
<li><code>total-requests</code></li>
<li><code>current-requests</code></li>
<li><code>failed-requests</code></li>
</ul>
<h2 id="endpoint-routing">终结点路由</h2>
<p>增强了终结点路由，终结点路由可以让框架（例如 MVC）与中间件配合使用：</p>
<ul>
<li>中间件和终结点的顺序可在 <code>Startup.Configure</code> 的请求处理管道中进行配置。</li>
<li>终结点和中间件与其他基于 ASP.NET Core 的技术（如运行状况检查）很好地结合。</li>
<li>终结点可以在中间件和 MVC 中实现策略，例如 CORS 或授权。</li>
<li>可以将筛选器和属性置于控制器的方法中。</li>
</ul>
<p>有关详细信息，请参阅 <a class="xref" href="../fundamentals/routing.html#routing-basics">ASP.NET Core 中的路由</a>。</p>
<h2 id="health-checks">运行状况检查</h2>
<p>运行状况检查将终结点路由与泛型主机一起使用。 在 <code>Startup.Configure</code> 内，使用终结点 URL 或相对路径在终结点生成器上调用 <code>MapHealthChecks</code>：</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapHealthChecks(&quot;/health&quot;);
});
</code></pre>
<p>运行状况检查终结点可以：</p>
<ul>
<li>指定一个或多个允许的主机/端口。</li>
<li>需要授权。</li>
<li>需要 CORS。</li>
</ul>
<p>有关详细信息，请参阅以下文章：</p>
<ul>
<li><a class="xref" href="../migration/22-to-30.html#health-checks">从 ASP.NET Core 2.2 迁移到3。0</a></li>
<li><a class="xref" href="../host-and-deploy/health-checks.html">ASP.NET Core 中的运行状况检查</a></li>
</ul>
<h2 id="pipes-on-httpcontext">HttpContext 上的管道</h2>
<p>现在可以使用 &lt;xref:System.IO.Pipelines&gt; API 读取请求正文和写入响应正文。 必须向 <!-- <xref:Microsoft.AspNetCore.Http.HttpRequest.BodyReader> --> <code>HttpRequest.BodyReader</code> 属性提供可用于读取请求正文的 &lt;xref:System.IO.Pipelines.PipeReader&gt;。 必须向 <!-- <xref:Microsoft.AspNetCore.Http.> --> <code>HttpResponse.BodyWriter</code> 属性提供可用于写入响应正文的 &lt;xref:System.IO.Pipelines.PipeWriter&gt;。 <code>HttpRequest.BodyReader</code> 是 <code>HttpRequest.Body</code> 流的模拟。 <code>HttpResponse.BodyWriter</code> 是 <code>HttpResponse.Body</code> 流的模拟。</p>
<!-- indirectly related, https://github.com/dotnet/docs/pull/14414 won't be published by 9/23  -->
<h2 id="improved-error-reporting-in-iis">改进了 IIS 中的错误报告</h2>
<p>在 IIS 中托管 ASP.NET Core 应用时出现的启动错误现在会生成更丰富的诊断数据。 如果适用，这些错误将报告给具有堆栈跟踪的 Windows 事件日志。 此外，所有警告、错误和未经处理的异常都将记录到 Windows 事件日志中。</p>
<h2 id="worker-service-and-worker-sdk">辅助角色服务和辅助角色 SDK</h2>
<p>.NET Core 3.0 引入了新的辅助角色服务应用模板。 可根据此模板开始在 .NET Core 中编写长期运行的服务。</p>
<p>有关详情，请参阅：</p>
<ul>
<li><a href="https://devblogs.microsoft.com/aspnet/net-core-workers-as-windows-services/">作为 Windows 服务的 .NET Core 辅助角色</a></li>
<li><a class="xref" href="../fundamentals/host/hosted-services.html">在 ASP.NET Core 中使用托管服务实现后台任务</a></li>
<li><a class="xref" href="../host-and-deploy/windows-service.html">在 Windows 服务中托管 ASP.NET Core</a></li>
</ul>
<h2 id="forwarded-headers-middleware-improvements">转接标头中间件改进</h2>
<p>在以前版本的 ASP.NET Core 中，在部署到 Azure Linux 或除 IIS 以外的任何反向代理后，调用 &lt;xref:Microsoft.AspNetCore.Builder.HstsBuilderExtensions.UseHsts*&gt; 和 &lt;xref:Microsoft.AspNetCore.Builder.HttpsPolicyBuilderExtensions.UseHttpsRedirection*&gt; 会出现问题。 <a class="xref" href="../host-and-deploy/proxy-load-balancer.html#forward-the-scheme-for-linux-and-non-iis-reverse-proxies">转发 Linux 和非 IIS 反向代理的方案</a>记录了以前版本的修复。</p>
<p>此方案已在 ASP.NET Core 3.0 中修复。 如果 <code>ASPNETCORE_FORWARDEDHEADERS_ENABLED</code> 环境变量设置为 <code>true</code>，则主机启用<a class="xref" href="../host-and-deploy/proxy-load-balancer.html#forwarded-headers-middleware-options">转接的标头中间件</a>。 在容器映像中，<code>ASPNETCORE_FORWARDEDHEADERS_ENABLED</code> 设置为 <code>true</code>。</p>
<h2 id="performance-improvements">性能改进</h2>
<p>ASP.NET Core 3.0 包含了许多改进，可减少内存使用量并提高吞吐量：</p>
<ul>
<li>降低了使用内置的依赖项注入容器来实现作用域服务时的内存使用量。</li>
<li>减少跨框架的分配，包括中间件方案和路由。</li>
<li>降低了 WebSocket 连接的内存使用量。</li>
<li>减少 HTTPS 连接的内存使用量并提高了其吞吐量。</li>
<li>新的优化和完全异步 JSON 序列化程序。</li>
<li>减少了窗体分析的内存使用量并提高了其吞吐量。</li>
</ul>
<h2 id="aspnet-core-30-only-runs-on-net-core-30">ASP.NET Core 3.0 仅在 .NET Core 3.0 上运行</h2>
<p>从 ASP.NET Core 3.0 开始，.NET Framework 不再是受支持的目标框架。 面向 .NET Framework 的项目可以使用 <a href="https://dotnet.microsoft.com/download/dotnet-core/2.1">.NET Core 2.1 LTS 版本</a>以完全受支持的方式继续。 超过 .NET Core 2.1 的 3 年 LTS 期之后，将无限期地向大多数 ASP.NET Core 2.1.x 相关包提供支持。</p>
<p>有关迁移信息，请参阅<a href="/dotnet/core/porting/">将代码从 .NET Framework 移植到 .NET Core</a>。</p>
<h2 id="use-the-aspnet-core-shared-framework">使用 ASP.NET Core 共享框架</h2>
<p><a class="xref" href="../fundamentals/metapackage-app.html">Microsoft.AspNetCore.App metapackage</a> 中包含的 ASP.NET Core 3.0 共享框架不再需要项目文件中有一个显式 <code>&lt;PackageReference /&gt;</code> 元素。 使用项目文件中的 <code>Microsoft.NET.Sdk.Web</code> SDK 时，会自动引用共享框架：</p>
<pre><code class="lang-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;
</code></pre>
<h2 id="assemblies-removed-from-the-aspnet-core-shared-framework">从 ASP.NET Core 共享框架中删除的程序集</h2>
<p>从 ASP.NET Core 3.0 共享框架中删除的最值得注意的程序集有：</p>
<ul>
<li><a href="https://www.nuget.org/packages/Newtonsoft.Json/">Newtonsoft.Json</a> (Json.NET)。 若要将 Json.NET 添加到 ASP.NET Core 3.0，请参阅<a class="xref" href="../web-api/advanced/formatting.html#add-newtonsoftjson-based-json-format-support">添加基于 Newtonsoft.Json 的 JSON 格式支持</a>。 ASP.NET Core 3.0 引入了 <code>System.Text.Json</code> 以读取和写入 JSON。 有关详细信息，请参阅本文档中的<a href="#new-json-serialization">新 JSON 序列化</a>。</li>
<li><a href="/ef/core/">Entity Framework Core</a></li>
</ul>
<p>有关从共享框架中删除的程序集的完整列表，请参阅<a href="https://github.com/dotnet/AspNetCore/issues/3755">从 Microsoft.AspNetCore.App 3.0 中删除的程序集</a>。 有关此更改的动机的详细信息，请参阅 <a href="https://github.com/aspnet/Announcements/issues/325">3.0 中对 Microsoft.AspNetCore.App 所做的重大变更</a>和<a href="https://devblogs.microsoft.com/aspnet/a-first-look-at-changes-coming-in-asp-net-core-3-0/">首先查看 ASP.NET Core 3.0 中的变更</a>。</p>
<!-- 
## Additional information
For the complete list of changes, see the [ASP.NET Core 3.0 Release Notes](WHERE IS THIS????).
-->
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
