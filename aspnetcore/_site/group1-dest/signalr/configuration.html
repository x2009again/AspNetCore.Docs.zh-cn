<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core SignalR &#37197;&#32622; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core SignalR &#37197;&#32622; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="signalr/configuration">
<h1 id="aspnet-core-no-locsignalr-configuration">ASP.NET Core SignalR 配置</h1>

<div range="&gt;= aspnetcore-5.0">
<h2 id="jsonmessagepack-serialization-options">JSON/MessagePack 序列化选项</h2>
<p>ASP.NET Core SignalR 支持两个用于编码消息的协议： <a href="https://www.json.org/">JSON</a> 和 <a href="https://msgpack.org/index.html">MessagePack</a>。 每个协议都具有序列化配置选项。</p>
<p>可以使用 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.jsonprotocoldependencyinjectionextensions.addjsonprotocol">AddJsonProtocol</a> 扩展方法在服务器上配置 JSON 序列化。 <code>AddJsonProtocol</code>可在<a href="/dotnet/api/microsoft.extensions.dependencyinjection.signalrdependencyinjectionextensions.addsignalr">添加 SignalR </a>后添加 <code>Startup.ConfigureServices</code> 。 <code>AddJsonProtocol</code>方法采用接收对象的委托 <code>options</code> 。 该对象上的 <a href="/dotnet/api/microsoft.aspnetcore.signalr.jsonhubprotocoloptions.payloadserializeroptions">PayloadSerializerOptions</a> 属性是一个 <code>System.Text.Json</code> &lt;xref:System.Text.Json.JsonSerializerOptions&gt; 对象，该对象可用于配置自变量和返回值的序列化。 有关详细信息，请参阅 <a href="/dotnet/api/system.text.json"> 文档</a>中的System.Text.Js。</p>
<p>例如，若要将序列化程序配置为不更改属性名称的大小写（而不是默认的 &quot;camelCase&quot; 名称），请使用中的以下代码 <code>Startup.ConfigureServices</code> ：</p>
<pre><code class="lang-csharp">services.AddSignalR()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null
    });
</code></pre>
<p>在 .NET 客户端中， <code>AddJsonProtocol</code> <a href="/dotnet/api/microsoft.aspnetcore.signalr.client.hubconnectionbuilder">HubConnectionBuilder</a>上存在相同的扩展方法。 <code>Microsoft.Extensions.DependencyInjection</code>必须导入命名空间才能解析扩展方法：</p>
<pre><code class="lang-csharp">// At the top of the file:
using Microsoft.Extensions.DependencyInjection;

// When constructing your connection:
var connection = new HubConnectionBuilder()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null;
    })
    .Build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 JSON 序列化。</p>
</div>
<h3 id="switch-to-newtonsoftjson">切换到 Newtonsoft.Js</h3>
<p>如果需要的功能 <code>Newtonsoft.Json</code> 在中不受支持 <code>System.Text.Json</code> ，请参阅 <a class="xref" href="../migration/22-to-30.html#switch-to-newtonsoftjson">切换到 Newtonsoft.Js</a>。</p>
<h3 id="messagepack-serialization-options">MessagePack 序列化选项</h3>
<p>可以通过向 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.msgpackprotocoldependencyinjectionextensions.addmessagepackprotocol">AddMessagePackProtocol</a> 调用提供委托来配置 MessagePack 序列化。 有关更多详细信息，请参阅<a class="xref" href="messagepackhubprotocol.html">中 SignalR 的 MessagePack</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 MessagePack 序列化。</p>
</div>
<h2 id="configure-server-options">配置服务器选项</h2>
<p>下表描述了用于配置中心的选项 SignalR ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ClientTimeoutInterval</code></td>
<td>30 秒</td>
<td>如果客户端未收到消息 (在此时间间隔内包含 keep-alive) ，服务器将认为客户端已断开连接。 由于实现方式的原因，客户端实际标记为断开连接可能需要更长的时间。 建议值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>如果客户端在此时间间隔内未发送初始握手消息，连接将关闭。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>如果服务器未在此时间间隔内发送消息，则会自动发送 ping 消息，使连接保持打开状态。 更改时 <code>KeepAliveInterval</code> ，请更改 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 客户端上的设置。 建议 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>SupportedProtocols</code></td>
<td>所有已安装的协议</td>
<td>此中心支持的协议。 默认情况下，将允许在服务器上注册的所有协议，但可以从此列表中删除协议，以禁用各个集线器的特定协议。</td>
</tr>
<tr>
<td><code>EnableDetailedErrors</code></td>
<td><code>false</code></td>
<td>如果为，则在 <code>true</code> 集线器方法中引发异常时，详细的异常消息将返回到客户端。 默认值为 <code>false</code> ，因为这些异常消息可能包含敏感信息。</td>
</tr>
<tr>
<td><code>StreamBufferCapacity</code></td>
<td><code>10</code></td>
<td>可为客户端上载流缓冲的最大项数。 如果达到此限制，则会阻止处理调用，直到服务器处理流项。</td>
</tr>
<tr>
<td><code>MaximumReceiveMessageSize</code></td>
<td>32 KB</td>
<td>单个传入集线器消息的最大大小。</td>
</tr>
<tr>
<td><code>MaximumParallelInvocationsPerClient</code></td>
<td>1</td>
<td>每个客户端可以在进行排队之前并行调用的最大集线器方法数。</td>
</tr>
</tbody>
</table>
<p>可以通过在中提供对调用的选项委托，为所有中心配置选项 <code>AddSignalR</code> <code>Startup.ConfigureServices</code> 。</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR(hubOptions =&gt;
    {
        hubOptions.EnableDetailedErrors = true;
        hubOptions.KeepAliveInterval = TimeSpan.FromMinutes(1);
    });
}
</code></pre>
<p>单个集线器的选项用于替代和中提供的全局选项 <code>AddSignalR</code> ，可以使用进行配置 &lt;xref:Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions*&gt; ：</p>
<pre><code class="lang-csharp">services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;
{
    options.EnableDetailedErrors = true;
});
</code></pre>
<h3 id="advanced-http-configuration-options">高级 HTTP 配置选项</h3>
<p>用于 <code>HttpConnectionDispatcherOptions</code> 配置与传输和内存缓冲区管理相关的高级设置。 这些选项通过将委托传递给中的<a href="/dotnet/api/microsoft.aspnetcore.builder.hubendpointroutebuilderextensions.maphub">MapHub &lt;T&gt; </a>来配置 <code>Startup.Configure</code> 。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;, options =&gt;
        {
            options.Transports =
                HttpTransportType.WebSockets |
                HttpTransportType.LongPolling;
        });
    });
}
</code></pre>
<p>下表描述了用于配置 ASP.NET Core SignalR 的高级 HTTP 选项的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationMaxBufferSize</code></td>
<td>32 KB</td>
<td>在应用反压之前，服务器从客户端接收的最大字节数。 增大此值后，服务器可以更快地接收更大的消息，而无需应用反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>AuthorizationData</code></td>
<td>从应用于 Hub 类的属性中自动收集的数据 <code>Authorize</code> 。</td>
<td>用于确定客户端是否有权连接到集线器的 <a href="/dotnet/api/microsoft.aspnetcore.authorization.iauthorizedata">IAuthorizeData</a> 对象的列表。</td>
</tr>
<tr>
<td><code>TransportMaxBufferSize</code></td>
<td>32 KB</td>
<td>在观察反压之前，服务器要发送的最大字节数。 增大此值后，服务器可以更快地缓冲更大的消息，而无需等待反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>Transports</code></td>
<td>所有传输均已启用。</td>
<td>值的位标志枚举 <code>HttpTransportType</code> ，可限制客户端可用于连接的传输。</td>
</tr>
<tr>
<td><code>LongPolling</code></td>
<td>请参阅下文。</td>
<td>特定于长轮询传输的其他选项。</td>
</tr>
<tr>
<td><code>WebSockets</code></td>
<td>请参阅下文。</td>
<td>特定于 Websocket 传输的其他选项。</td>
</tr>
<tr>
<td><code>MinimumProtocolVersion</code></td>
<td>0</td>
<td>指定 negotiate 协议的最低版本。 这用于将客户端限制到较新的版本。</td>
</tr>
</tbody>
</table>
<p>长轮询传输具有可使用属性配置的其他选项 <code>LongPolling</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PollTimeout</code></td>
<td>90秒</td>
<td>服务器在终止单个轮询请求之前等待发送到客户端的消息的最长时间。 减小此值将导致客户端更频繁地发出新的投票请求。</td>
</tr>
</tbody>
</table>
<p>WebSocket 传输具有可使用属性配置的其他选项 <code>WebSockets</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>服务器关闭后，如果客户端在此时间间隔内未能关闭，则连接将终止。</td>
</tr>
<tr>
<td><code>SubProtocolSelector</code></td>
<td><code>null</code></td>
<td>一个委托，可用于将 <code>Sec-WebSocket-Protocol</code> 标头设置为自定义值。 委托接收客户端请求的值作为输入，并且应返回所需的值。</td>
</tr>
</tbody>
</table>
<h2 id="configure-client-options">配置客户端选项</h2>
<p>可以在 <code>HubConnectionBuilder</code> .net 和 JavaScript 客户端) 中可用的类型 (上配置客户端选项。 它在 Java 客户端中也可用，但 <code>HttpHubConnectionBuilder</code> 子类是包含生成器配置选项的内容，也是其 <code>HubConnection</code> 本身。</p>
<h3 id="configure-logging">配置日志记录</h3>
<p>使用方法在 .NET 客户端中配置日志记录 <code>ConfigureLogging</code> 。 日志提供程序和筛选器的注册方式与服务器上相同。 有关详细信息，请参阅 <a class="xref" href="../fundamentals/logging/index.html">ASP.NET Core 文档中的日志记录</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>若要注册日志记录提供程序，必须安装所需的包。 有关完整列表，请参阅文档的 <a class="xref" href="../fundamentals/logging/index.html#built-in-logging-providers">内置日志记录提供程序</a> 部分。</p>
</div>
<p>例如，若要启用控制台日志记录，请安装 <code>Microsoft.Extensions.Logging.Console</code> NuGet 包。 调用 <code>AddConsole</code> 扩展方法：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;)
    .ConfigureLogging(logging =&gt; {
        logging.SetMinimumLevel(LogLevel.Information);
        logging.AddConsole();
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，存在类似的 <code>configureLogging</code> 方法。 提供一个 <code>LogLevel</code> 值，该值指示要生成的日志消息的最小级别。 日志将写入浏览器控制台窗口中。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(signalR.LogLevel.Information)
    .build();
</code></pre>
<p><code>LogLevel</code>您还可以提供一个 <code>string</code> 表示日志级别名称的值，而不是一个值。 当 SignalR 你在无法访问常量的环境中配置日志记录时，这非常有用 <code>LogLevel</code> 。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(&quot;warn&quot;)
    .build();
</code></pre>
<p>下表列出了可用的日志级别。 为 <code>configureLogging</code> 设置将记录的 <strong>最小</strong> 日志级别而提供的值。 将记录在此级别上记录的消息 <strong>或在表中列出的级别</strong> 。</p>
<table>
<thead>
<tr>
<th>String</th>
<th>LogLevel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trace</code></td>
<td><code>LogLevel.Trace</code></td>
</tr>
<tr>
<td><code>debug</code></td>
<td><code>LogLevel.Debug</code></td>
</tr>
<tr>
<td><code>info</code> <strong>或</strong> <code>information</code></td>
<td><code>LogLevel.Information</code></td>
</tr>
<tr>
<td><code>warn</code> <strong>或</strong> <code>warning</code></td>
<td><code>LogLevel.Warning</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td><code>LogLevel.Error</code></td>
</tr>
<tr>
<td><code>critical</code></td>
<td><code>LogLevel.Critical</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td><code>LogLevel.None</code></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>若要完全禁用日志记录，请 <code>signalR.LogLevel.None</code> 在方法中指定 <code>configureLogging</code> 。</p>
</div>
<p>有关日志记录的详细信息，请参阅<a class="xref" href="diagnostics.html"> SignalR 诊断文档</a>。</p>
<p>SignalRJava 客户端使用<a href="https://www.slf4j.org/">SLF4J</a>库进行日志记录。 这是一个高级日志记录 API，它允许库的用户通过引入特定的日志记录依赖项来选择自己的特定日志记录实现。 下面的代码段演示如何将用于 <code>java.util.logging</code> SignalR Java 客户端。</p>
<pre><code class="lang-gradle">implementation 'org.slf4j:slf4j-jdk14:1.7.25'
</code></pre>
<p>如果未在依赖项中配置日志记录，SLF4J 将加载默认的非操作记录器，并提供以下警告消息：</p>
<pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>可以安全地忽略此情况。</p>
<h3 id="configure-allowed-transports">配置允许的传输</h3>
<p>使用的传输 SignalR 可在 <code>WithUrl</code> JavaScript) 的调用 (中进行配置 <code>withUrl</code> 。 的值的按位 &quot;或&quot; <code>HttpTransportType</code> 可用于将客户端限制为仅使用指定的传输。 默认情况下，将启用所有传输。</p>
<p>例如，禁用 Server-Sent 事件传输，但允许 Websocket 和长轮询连接：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, HttpTransportType.WebSockets | HttpTransportType.LongPolling)
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>transport</code> 在提供的选项对象上设置字段来配置传输 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling })
    .build();
</code></pre>
<p>此版本的 Java 客户端 websocket 是唯一可用的传输。</p>
<p>在 Java 客户端中，通过中的方法选择了传输 <code>withTransport</code> <code>HttpHubConnectionBuilder</code> 。 Java 客户端默认使用 Websocket 传输。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withTransport(TransportEnum.WEBSOCKETS)
    .build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>SignalRJava 客户端尚不支持传输回退。</p>
</div>
<h3 id="configure-bearer-authentication">配置持有者身份验证</h3>
<p>若要与请求一起提供身份验证数据 SignalR ，请使用 <code>AccessTokenProvider</code> <code>accessTokenFactory</code> JavaScript) 中 (选项来指定返回所需访问令牌的函数。 在 .NET 客户端中，此访问令牌作为 HTTP &quot;持有者身份验证&quot; 令牌传入 (使用 <code>Authorization</code>) 类型的标头 <code>Bearer</code> 。 在 JavaScript 客户端中，访问令牌用作持有者令牌， <strong>但</strong> 在某些情况下，浏览器 api 会限制在 Server-Sent 事件和 websocket 请求)  (具体应用标头的能力。 在这些情况下，访问令牌作为查询字符串值提供 <code>access_token</code> 。</p>
<p>在 .NET 客户端中， <code>AccessTokenProvider</code> 可使用中的选项委托指定选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.AccessTokenProvider = async () =&gt; {
            // Get and return the access token.
        };
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>accessTokenFactory</code> 在中设置 &quot;选项&quot; 对象上的字段来配置访问令牌 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        accessTokenFactory: () =&gt; {
            // Get and return the access token.
            // This function can return a JavaScript Promise if asynchronous
            // logic is required to retrieve the access token.
        }
    })
    .build();
</code></pre>
<p>在 SignalR Java 客户端中，可以通过向 <a href="/java/api/com.microsoft.signalr._http_hub_connection_builder?view=aspnet-signalr-java">HttpHubConnectionBuilder</a>提供访问令牌工厂来配置用于身份验证的持有者令牌。 使用<a href="/java/api/com.microsoft.signalr._http_hub_connection_builder.withaccesstokenprovider?view=aspnet-signalr-java#com_microsoft_signalr__http_hub_connection_builder_withAccessTokenProvider_Single_String__">withAccessTokenFactory</a>提供<a href="https://github.com/ReactiveX/RxJava">RxJava</a> <a href="https://reactivex.io/documentation/single.html">Single &lt;String&gt; </a>。 如果调用了 <a href="https://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#defer-java.util.concurrent.Callable-">单延迟</a>，你可以编写逻辑来为客户端生成访问令牌。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withAccessTokenProvider(Single.defer(() -&gt; {
        // Your logic here.
        return Single.just(&quot;An Access Token&quot;);
    })).build();
</code></pre>
<h3 id="configure-timeout-and-keep-alive-options">配置超时和 keep-alive 选项</h3>
<p>用于配置超时和保持活动状态的其他选项可用于 <code>HubConnection</code> 对象本身：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
<p>在 .NET 客户端中，超时值指定为 <code>TimeSpan</code> 值。</p>
</section>
<section id="tabpanel_CeZOj-G++Q_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>serverTimeoutInMilliseconds</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onclose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>keepAliveIntervalInMilliseconds</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getServerTimeout</code> / <code>setServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onClose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>withHandshakeResponseTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并触发 <code>onClose</code> 事件。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>getKeepAliveInterval</code> / <code>setKeepAliveInterval</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
</div>
<h3 id="configure-additional-options">配置其他选项</h3>
<p>可以在中的 <code>WithUrl</code> <code>withUrl</code> JavaScript) 方法 (上 <code>HubConnectionBuilder</code> 或在 <code>HttpHubConnectionBuilder</code> Java 客户端中的各种配置 api 上配置其他选项：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-1_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>.NET 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>SkipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>ClientCertificates</code></td>
<td>空</td>
<td>要发送以对请求进行身份验证的 TLS 证书的集合。</td>
</tr>
<tr>
<td><code>Cookies</code></td>
<td>空</td>
<td>cookie要随每个 http 请求一起发送的 http 的集合。</td>
</tr>
<tr>
<td><code>Credentials</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的凭据。</td>
</tr>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>仅 Websocket。 客户端在关闭之后等待服务器确认关闭请求的最长时间。 如果服务器在这段时间内没有确认关闭，客户端将断开连接。</td>
</tr>
<tr>
<td><code>Headers</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
<tr>
<td><code>HttpMessageHandlerFactory</code></td>
<td><code>null</code></td>
<td>一个委托，可用于配置或替换 <code>HttpMessageHandler</code> 用于发送 HTTP 请求的。 不用于 WebSocket 连接。 此委托必须返回非 null 值，并接收默认值作为参数。 修改该默认值的设置并将其返回，或返回一个新的 <code>HttpMessageHandler</code> 实例。 <strong>当替换处理程序时，请确保从提供的处理程序复制您要保留的设置，否则，所配置的选项 (如 Cookie s 和标头) 将不会应用于新的处理程序。</strong></td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td><code>null</code></td>
<td>发送 HTTP 请求时要使用的 HTTP 代理。</td>
</tr>
<tr>
<td><code>UseDefaultCredentials</code></td>
<td><code>false</code></td>
<td>设置此布尔值可发送 HTTP 和 Websocket 请求的默认凭据。 这样就可以使用 Windows 身份验证。</td>
</tr>
<tr>
<td><code>WebSocketConfiguration</code></td>
<td><code>null</code></td>
<td>可用于配置其他 WebSocket 选项的委托。 接收可用于配置选项的 <a href="/dotnet/api/system.net.websockets.clientwebsocketoptions">ClientWebSocketOptions</a> 实例。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-1_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>JavaScript 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accessTokenFactory</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>transport</code></td>
<td><code>null</code></td>
<td>一个 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType&gt; 值，该值指定用于连接的传输。</td>
</tr>
<tr>
<td><code>headers</code></td>
<td><code>null</code></td>
<td>每个 HTTP 请求发送的标头的字典。 在浏览器中发送标头对于 Websocket 或流不起作用 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType.ServerSentEvents&gt; 。</td>
</tr>
<tr>
<td><code>logMessageContent</code></td>
<td><code>null</code></td>
<td>设置为 <code>true</code> 可记录客户端发送和接收的消息的字节数/字符数。</td>
</tr>
<tr>
<td><code>skipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withCredentials</code></td>
<td><code>true</code></td>
<td>指定是否将凭据与 CORS 请求一起发送。 Azure App Service cookie 将用于粘滞会话，并且需要启用此选项才能正常工作。 有关 CORS 的详细信息 SignalR ，请参阅 <a class="xref" href="security.html#cross-origin-resource-sharing">ASP.NET Core 中的安全注意事项 SignalR</a> 。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-1_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>Java 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>withAccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>shouldSkipNegotiate</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withHeader</code> <code>withHeaders</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
</tbody>
</table>
</section>
</div>

<p>在 .NET 客户端中，可以通过提供给的 options 委托来修改这些选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.Headers[&quot;Foo&quot;] = &quot;Bar&quot;;
        options.SkipNegotiation = true;
        options.Transports = HttpTransportType.WebSockets;
        options.Cookies.Add(new Cookie(/* ... */);
        options.ClientCertificates.Add(/* ... */);
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，可以在提供给的 JavaScript 对象中提供这些选项 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        // &quot;Foo: Bar&quot; will not be sent with WebSockets or Server-Sent Events requests
        headers: { &quot;Foo&quot;: &quot;Bar&quot; },
        transport: signalR.HttpTransportType.LongPolling 
    })
    .build();
</code></pre>
<p>在 Java 客户端中，这些选项可以在 <code>HttpHubConnectionBuilder</code> 从 <code>HubConnectionBuilder.create(&quot;HUB URL&quot;)</code></p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
        .withHeader(&quot;Foo&quot;, &quot;Bar&quot;)
        .shouldSkipNegotiate(true)
        .withHandshakeResponseTimeout(30*1000)
        .build();
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../tutorials/signalr.html">ASP.NET Core SignalR 入门</a></li>
<li><a class="xref" href="hubs.html">在 ASP.NET Core 中使用中心 SignalR</a></li>
<li><a class="xref" href="javascript-client.html">ASP.NET Core SignalR JavaScript 客户端</a></li>
<li><a class="xref" href="dotnet-client.html">ASP.NET Core SignalR .Net 客户端</a></li>
<li><a class="xref" href="messagepackhubprotocol.html">使用中的 MessagePack Hub 协议 SignalR 进行 ASP.NET Core</a></li>
<li><a class="xref" href="supported-platforms.html">ASP.NET Core SignalR 支持的平台</a></li>
</ul>
</div>
<div range="= aspnetcore-3.1">
<h2 id="jsonmessagepack-serialization-options">JSON/MessagePack 序列化选项</h2>
<p>ASP.NET Core SignalR 支持两个用于编码消息的协议： <a href="https://www.json.org/">JSON</a> 和 <a href="https://msgpack.org/index.html">MessagePack</a>。 每个协议都具有序列化配置选项。</p>
<p>可以使用 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.jsonprotocoldependencyinjectionextensions.addjsonprotocol">AddJsonProtocol</a> 扩展方法在服务器上配置 JSON 序列化。 <code>AddJsonProtocol</code>可在<a href="/dotnet/api/microsoft.extensions.dependencyinjection.signalrdependencyinjectionextensions.addsignalr">添加 SignalR </a>后添加 <code>Startup.ConfigureServices</code> 。 <code>AddJsonProtocol</code>方法采用接收对象的委托 <code>options</code> 。 该对象上的 <a href="/dotnet/api/microsoft.aspnetcore.signalr.jsonhubprotocoloptions.payloadserializeroptions">PayloadSerializerOptions</a> 属性是一个 <code>System.Text.Json</code> &lt;xref:System.Text.Json.JsonSerializerOptions&gt; 对象，该对象可用于配置自变量和返回值的序列化。 有关详细信息，请参阅 <a href="/dotnet/api/system.text.json"> 文档</a>中的System.Text.Js。</p>
<p>例如，若要将序列化程序配置为不更改属性名称的大小写（而不是默认的 &quot;camelCase&quot; 名称），请使用中的以下代码 <code>Startup.ConfigureServices</code> ：</p>
<pre><code class="lang-csharp">services.AddSignalR()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null
    });
</code></pre>
<p>在 .NET 客户端中， <code>AddJsonProtocol</code> <a href="/dotnet/api/microsoft.aspnetcore.signalr.client.hubconnectionbuilder">HubConnectionBuilder</a>上存在相同的扩展方法。 <code>Microsoft.Extensions.DependencyInjection</code>必须导入命名空间才能解析扩展方法：</p>
<pre><code class="lang-csharp">// At the top of the file:
using Microsoft.Extensions.DependencyInjection;

// When constructing your connection:
var connection = new HubConnectionBuilder()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null;
    })
    .Build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 JSON 序列化。</p>
</div>
<h3 id="switch-to-newtonsoftjson">切换到 Newtonsoft.Js</h3>
<p>如果需要的功能 <code>Newtonsoft.Json</code> 在中不受支持 <code>System.Text.Json</code> ，请参阅 <a class="xref" href="../migration/22-to-30.html#switch-to-newtonsoftjson">切换到 Newtonsoft.Js</a>。</p>
<h3 id="messagepack-serialization-options">MessagePack 序列化选项</h3>
<p>可以通过向 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.msgpackprotocoldependencyinjectionextensions.addmessagepackprotocol">AddMessagePackProtocol</a> 调用提供委托来配置 MessagePack 序列化。 有关更多详细信息，请参阅<a class="xref" href="messagepackhubprotocol.html">中 SignalR 的 MessagePack</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 MessagePack 序列化。</p>
</div>
<h2 id="configure-server-options">配置服务器选项</h2>
<p>下表描述了用于配置中心的选项 SignalR ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ClientTimeoutInterval</code></td>
<td>30 秒</td>
<td>如果客户端未收到消息 (在此时间间隔内包含 keep-alive) ，服务器将认为客户端已断开连接。 由于实现方式的原因，客户端实际标记为断开连接可能需要更长的时间。 建议值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>如果客户端在此时间间隔内未发送初始握手消息，连接将关闭。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>如果服务器未在此时间间隔内发送消息，则会自动发送 ping 消息，使连接保持打开状态。 更改时 <code>KeepAliveInterval</code> ，请更改 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 客户端上的设置。 建议 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>SupportedProtocols</code></td>
<td>所有已安装的协议</td>
<td>此中心支持的协议。 默认情况下，将允许在服务器上注册的所有协议，但可以从此列表中删除协议，以禁用各个集线器的特定协议。</td>
</tr>
<tr>
<td><code>EnableDetailedErrors</code></td>
<td><code>false</code></td>
<td>如果为，则在 <code>true</code> 集线器方法中引发异常时，详细的异常消息将返回到客户端。 默认值为 <code>false</code> ，因为这些异常消息可能包含敏感信息。</td>
</tr>
<tr>
<td><code>StreamBufferCapacity</code></td>
<td><code>10</code></td>
<td>可为客户端上载流缓冲的最大项数。 如果达到此限制，则会阻止处理调用，直到服务器处理流项。</td>
</tr>
<tr>
<td><code>MaximumReceiveMessageSize</code></td>
<td>32 KB</td>
<td>单个传入集线器消息的最大大小。</td>
</tr>
</tbody>
</table>
<p>可以通过在中提供对调用的选项委托，为所有中心配置选项 <code>AddSignalR</code> <code>Startup.ConfigureServices</code> 。</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR(hubOptions =&gt;
    {
        hubOptions.EnableDetailedErrors = true;
        hubOptions.KeepAliveInterval = TimeSpan.FromMinutes(1);
    });
}
</code></pre>
<p>单个集线器的选项用于替代和中提供的全局选项 <code>AddSignalR</code> ，可以使用进行配置 &lt;xref:Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions*&gt; ：</p>
<pre><code class="lang-csharp">services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;
{
    options.EnableDetailedErrors = true;
});
</code></pre>
<h3 id="advanced-http-configuration-options">高级 HTTP 配置选项</h3>
<p>用于 <code>HttpConnectionDispatcherOptions</code> 配置与传输和内存缓冲区管理相关的高级设置。 这些选项通过将委托传递给中的<a href="/dotnet/api/microsoft.aspnetcore.builder.hubendpointroutebuilderextensions.maphub">MapHub &lt;T&gt; </a>来配置 <code>Startup.Configure</code> 。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;, options =&gt;
        {
            options.Transports =
                HttpTransportType.WebSockets |
                HttpTransportType.LongPolling;
        });
    });
}
</code></pre>
<p>下表描述了用于配置 ASP.NET Core SignalR 的高级 HTTP 选项的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationMaxBufferSize</code></td>
<td>32 KB</td>
<td>在应用反压之前，服务器从客户端接收的最大字节数。 增大此值后，服务器可以更快地接收更大的消息，而无需应用反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>AuthorizationData</code></td>
<td>从应用于 Hub 类的属性中自动收集的数据 <code>Authorize</code> 。</td>
<td>用于确定客户端是否有权连接到集线器的 <a href="/dotnet/api/microsoft.aspnetcore.authorization.iauthorizedata">IAuthorizeData</a> 对象的列表。</td>
</tr>
<tr>
<td><code>TransportMaxBufferSize</code></td>
<td>32 KB</td>
<td>在观察反压之前，服务器要发送的最大字节数。 增大此值后，服务器可以更快地缓冲更大的消息，而无需等待反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>Transports</code></td>
<td>所有传输均已启用。</td>
<td>值的位标志枚举 <code>HttpTransportType</code> ，可限制客户端可用于连接的传输。</td>
</tr>
<tr>
<td><code>LongPolling</code></td>
<td>请参阅下文。</td>
<td>特定于长轮询传输的其他选项。</td>
</tr>
<tr>
<td><code>WebSockets</code></td>
<td>请参阅下文。</td>
<td>特定于 Websocket 传输的其他选项。</td>
</tr>
<tr>
<td><code>MinimumProtocolVersion</code></td>
<td>0</td>
<td>指定 negotiate 协议的最低版本。 这用于将客户端限制到较新的版本。</td>
</tr>
</tbody>
</table>
<p>长轮询传输具有可使用属性配置的其他选项 <code>LongPolling</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PollTimeout</code></td>
<td>90秒</td>
<td>服务器在终止单个轮询请求之前等待发送到客户端的消息的最长时间。 减小此值将导致客户端更频繁地发出新的投票请求。</td>
</tr>
</tbody>
</table>
<p>WebSocket 传输具有可使用属性配置的其他选项 <code>WebSockets</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>服务器关闭后，如果客户端在此时间间隔内未能关闭，则连接将终止。</td>
</tr>
<tr>
<td><code>SubProtocolSelector</code></td>
<td><code>null</code></td>
<td>一个委托，可用于将 <code>Sec-WebSocket-Protocol</code> 标头设置为自定义值。 委托接收客户端请求的值作为输入，并且应返回所需的值。</td>
</tr>
</tbody>
</table>
<h2 id="configure-client-options">配置客户端选项</h2>
<p>可以在 <code>HubConnectionBuilder</code> .net 和 JavaScript 客户端) 中可用的类型 (上配置客户端选项。 它在 Java 客户端中也可用，但 <code>HttpHubConnectionBuilder</code> 子类是包含生成器配置选项的内容，也是其 <code>HubConnection</code> 本身。</p>
<h3 id="configure-logging">配置日志记录</h3>
<p>使用方法在 .NET 客户端中配置日志记录 <code>ConfigureLogging</code> 。 日志提供程序和筛选器的注册方式与服务器上相同。 有关详细信息，请参阅 <a class="xref" href="../fundamentals/logging/index.html">ASP.NET Core 文档中的日志记录</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>若要注册日志记录提供程序，必须安装所需的包。 有关完整列表，请参阅文档的 <a class="xref" href="../fundamentals/logging/index.html#built-in-logging-providers">内置日志记录提供程序</a> 部分。</p>
</div>
<p>例如，若要启用控制台日志记录，请安装 <code>Microsoft.Extensions.Logging.Console</code> NuGet 包。 调用 <code>AddConsole</code> 扩展方法：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;)
    .ConfigureLogging(logging =&gt; {
        logging.SetMinimumLevel(LogLevel.Information);
        logging.AddConsole();
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，存在类似的 <code>configureLogging</code> 方法。 提供一个 <code>LogLevel</code> 值，该值指示要生成的日志消息的最小级别。 日志将写入浏览器控制台窗口中。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(signalR.LogLevel.Information)
    .build();
</code></pre>
<p><code>LogLevel</code>您还可以提供一个 <code>string</code> 表示日志级别名称的值，而不是一个值。 当 SignalR 你在无法访问常量的环境中配置日志记录时，这非常有用 <code>LogLevel</code> 。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(&quot;warn&quot;)
    .build();
</code></pre>
<p>下表列出了可用的日志级别。 为 <code>configureLogging</code> 设置将记录的 <strong>最小</strong> 日志级别而提供的值。 将记录在此级别上记录的消息 <strong>或在表中列出的级别</strong> 。</p>
<table>
<thead>
<tr>
<th>String</th>
<th>LogLevel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trace</code></td>
<td><code>LogLevel.Trace</code></td>
</tr>
<tr>
<td><code>debug</code></td>
<td><code>LogLevel.Debug</code></td>
</tr>
<tr>
<td><code>info</code> <strong>或</strong> <code>information</code></td>
<td><code>LogLevel.Information</code></td>
</tr>
<tr>
<td><code>warn</code> <strong>或</strong> <code>warning</code></td>
<td><code>LogLevel.Warning</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td><code>LogLevel.Error</code></td>
</tr>
<tr>
<td><code>critical</code></td>
<td><code>LogLevel.Critical</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td><code>LogLevel.None</code></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>若要完全禁用日志记录，请 <code>signalR.LogLevel.None</code> 在方法中指定 <code>configureLogging</code> 。</p>
</div>
<p>有关日志记录的详细信息，请参阅<a class="xref" href="diagnostics.html"> SignalR 诊断文档</a>。</p>
<p>SignalRJava 客户端使用<a href="https://www.slf4j.org/">SLF4J</a>库进行日志记录。 这是一个高级日志记录 API，它允许库的用户通过引入特定的日志记录依赖项来选择自己的特定日志记录实现。 下面的代码段演示如何将用于 <code>java.util.logging</code> SignalR Java 客户端。</p>
<pre><code class="lang-gradle">implementation 'org.slf4j:slf4j-jdk14:1.7.25'
</code></pre>
<p>如果未在依赖项中配置日志记录，SLF4J 将加载默认的非操作记录器，并提供以下警告消息：</p>
<pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>可以安全地忽略此情况。</p>
<h3 id="configure-allowed-transports">配置允许的传输</h3>
<p>使用的传输 SignalR 可在 <code>WithUrl</code> JavaScript) 的调用 (中进行配置 <code>withUrl</code> 。 的值的按位 &quot;或&quot; <code>HttpTransportType</code> 可用于将客户端限制为仅使用指定的传输。 默认情况下，将启用所有传输。</p>
<p>例如，禁用 Server-Sent 事件传输，但允许 Websocket 和长轮询连接：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, HttpTransportType.WebSockets | HttpTransportType.LongPolling)
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>transport</code> 在提供的选项对象上设置字段来配置传输 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling })
    .build();
</code></pre>
<p>此版本的 Java 客户端 websocket 是唯一可用的传输。</p>
<p>在 Java 客户端中，通过中的方法选择了传输 <code>withTransport</code> <code>HttpHubConnectionBuilder</code> 。 Java 客户端默认使用 Websocket 传输。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withTransport(TransportEnum.WEBSOCKETS)
    .build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>SignalRJava 客户端尚不支持传输回退。</p>
</div>
<h3 id="configure-bearer-authentication">配置持有者身份验证</h3>
<p>若要与请求一起提供身份验证数据 SignalR ，请使用 <code>AccessTokenProvider</code> <code>accessTokenFactory</code> JavaScript) 中 (选项来指定返回所需访问令牌的函数。 在 .NET 客户端中，此访问令牌作为 HTTP &quot;持有者身份验证&quot; 令牌传入 (使用 <code>Authorization</code>) 类型的标头 <code>Bearer</code> 。 在 JavaScript 客户端中，访问令牌用作持有者令牌， <strong>但</strong> 在某些情况下，浏览器 api 会限制在 Server-Sent 事件和 websocket 请求)  (具体应用标头的能力。 在这些情况下，访问令牌作为查询字符串值提供 <code>access_token</code> 。</p>
<p>在 .NET 客户端中， <code>AccessTokenProvider</code> 可使用中的选项委托指定选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.AccessTokenProvider = async () =&gt; {
            // Get and return the access token.
        };
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>accessTokenFactory</code> 在中设置 &quot;选项&quot; 对象上的字段来配置访问令牌 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        accessTokenFactory: () =&gt; {
            // Get and return the access token.
            // This function can return a JavaScript Promise if asynchronous
            // logic is required to retrieve the access token.
        }
    })
    .build();
</code></pre>
<p>在 SignalR Java 客户端中，可以通过向 <a href="/java/api/com.microsoft.signalr._http_hub_connection_builder?view=aspnet-signalr-java">HttpHubConnectionBuilder</a>提供访问令牌工厂来配置用于身份验证的持有者令牌。 使用<a href="/java/api/com.microsoft.signalr._http_hub_connection_builder.withaccesstokenprovider?view=aspnet-signalr-java#com_microsoft_signalr__http_hub_connection_builder_withAccessTokenProvider_Single_String__">withAccessTokenFactory</a>提供<a href="https://github.com/ReactiveX/RxJava">RxJava</a> <a href="https://reactivex.io/documentation/single.html">Single &lt;String&gt; </a>。 如果调用了 <a href="https://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#defer-java.util.concurrent.Callable-">单延迟</a>，你可以编写逻辑来为客户端生成访问令牌。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withAccessTokenProvider(Single.defer(() -&gt; {
        // Your logic here.
        return Single.just(&quot;An Access Token&quot;);
    })).build();
</code></pre>
<h3 id="configure-timeout-and-keep-alive-options">配置超时和 keep-alive 选项</h3>
<p>用于配置超时和保持活动状态的其他选项可用于 <code>HubConnection</code> 对象本身：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-2_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
<p>在 .NET 客户端中，超时值指定为 <code>TimeSpan</code> 值。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-2_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>serverTimeoutInMilliseconds</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onclose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>keepAliveIntervalInMilliseconds</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-2_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getServerTimeout</code> / <code>setServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onClose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>withHandshakeResponseTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并触发 <code>onClose</code> 事件。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>getKeepAliveInterval</code> / <code>setKeepAliveInterval</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
</div>
<h3 id="configure-additional-options">配置其他选项</h3>
<p>可以在中的 <code>WithUrl</code> <code>withUrl</code> JavaScript) 方法 (上 <code>HubConnectionBuilder</code> 或在 <code>HttpHubConnectionBuilder</code> Java 客户端中的各种配置 api 上配置其他选项：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-3_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>.NET 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>SkipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>ClientCertificates</code></td>
<td>空</td>
<td>要发送以对请求进行身份验证的 TLS 证书的集合。</td>
</tr>
<tr>
<td><code>Cookies</code></td>
<td>空</td>
<td>cookie要随每个 http 请求一起发送的 http 的集合。</td>
</tr>
<tr>
<td><code>Credentials</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的凭据。</td>
</tr>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>仅 Websocket。 客户端在关闭之后等待服务器确认关闭请求的最长时间。 如果服务器在这段时间内没有确认关闭，客户端将断开连接。</td>
</tr>
<tr>
<td><code>Headers</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
<tr>
<td><code>HttpMessageHandlerFactory</code></td>
<td><code>null</code></td>
<td>一个委托，可用于配置或替换 <code>HttpMessageHandler</code> 用于发送 HTTP 请求的。 不用于 WebSocket 连接。 此委托必须返回非 null 值，并接收默认值作为参数。 修改该默认值的设置并将其返回，或返回一个新的 <code>HttpMessageHandler</code> 实例。 <strong>当替换处理程序时，请确保从提供的处理程序复制您要保留的设置，否则，所配置的选项 (如 Cookie s 和标头) 将不会应用于新的处理程序。</strong></td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td><code>null</code></td>
<td>发送 HTTP 请求时要使用的 HTTP 代理。</td>
</tr>
<tr>
<td><code>UseDefaultCredentials</code></td>
<td><code>false</code></td>
<td>设置此布尔值可发送 HTTP 和 Websocket 请求的默认凭据。 这样就可以使用 Windows 身份验证。</td>
</tr>
<tr>
<td><code>WebSocketConfiguration</code></td>
<td><code>null</code></td>
<td>可用于配置其他 WebSocket 选项的委托。 接收可用于配置选项的 <a href="/dotnet/api/system.net.websockets.clientwebsocketoptions">ClientWebSocketOptions</a> 实例。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-3_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>JavaScript 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accessTokenFactory</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>transport</code></td>
<td><code>null</code></td>
<td>一个 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType&gt; 值，该值指定用于连接的传输。</td>
</tr>
<tr>
<td><code>logMessageContent</code></td>
<td><code>null</code></td>
<td>设置为 <code>true</code> 可记录客户端发送和接收的消息的字节数/字符数。</td>
</tr>
<tr>
<td><code>skipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-3_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>Java 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>withAccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>shouldSkipNegotiate</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withHeader</code> <code>withHeaders</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
</tbody>
</table>
</section>
</div>

<p>在 .NET 客户端中，可以通过提供给的 options 委托来修改这些选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.Headers[&quot;Foo&quot;] = &quot;Bar&quot;;
        options.Cookies.Add(new Cookie(/* ... */);
        options.ClientCertificates.Add(/* ... */);
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，可以在提供给的 JavaScript 对象中提供这些选项 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        skipNegotiation: true,
        transport: signalR.HttpTransportType.WebSockets
    })
    .build();
</code></pre>
<p>在 Java 客户端中，这些选项可以在 <code>HttpHubConnectionBuilder</code> 从 <code>HubConnectionBuilder.create(&quot;HUB URL&quot;)</code></p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
        .withHeader(&quot;Foo&quot;, &quot;Bar&quot;)
        .shouldSkipNegotiate(true)
        .withHandshakeResponseTimeout(30*1000)
        .build();
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../tutorials/signalr.html">ASP.NET Core SignalR 入门</a></li>
<li><a class="xref" href="hubs.html">在 ASP.NET Core 中使用中心 SignalR</a></li>
<li><a class="xref" href="javascript-client.html">ASP.NET Core SignalR JavaScript 客户端</a></li>
<li><a class="xref" href="dotnet-client.html">ASP.NET Core SignalR .Net 客户端</a></li>
<li><a class="xref" href="messagepackhubprotocol.html">使用中的 MessagePack Hub 协议 SignalR 进行 ASP.NET Core</a></li>
<li><a class="xref" href="supported-platforms.html">ASP.NET Core SignalR 支持的平台</a></li>
</ul>
</div>
<div range="= aspnetcore-3.0">
<h2 id="jsonmessagepack-serialization-options">JSON/MessagePack 序列化选项</h2>
<p>ASP.NET Core SignalR 支持两个用于编码消息的协议： <a href="https://www.json.org/">JSON</a> 和 <a href="https://msgpack.org/index.html">MessagePack</a>。 每个协议都具有序列化配置选项。</p>
<p>可以使用 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.jsonprotocoldependencyinjectionextensions.addjsonprotocol">AddJsonProtocol</a> 扩展方法在服务器上配置 JSON 序列化。 <code>AddJsonProtocol</code>可在<a href="/dotnet/api/microsoft.extensions.dependencyinjection.signalrdependencyinjectionextensions.addsignalr">添加 SignalR </a>后添加 <code>Startup.ConfigureServices</code> 。 <code>AddJsonProtocol</code>方法采用接收对象的委托 <code>options</code> 。 该对象上的 <a href="/dotnet/api/microsoft.aspnetcore.signalr.jsonhubprotocoloptions.payloadserializeroptions">PayloadSerializerOptions</a> 属性是一个 <code>System.Text.Json</code> &lt;xref:System.Text.Json.JsonSerializerOptions&gt; 对象，该对象可用于配置自变量和返回值的序列化。 有关详细信息，请参阅 <a href="/dotnet/api/system.text.json"> 文档</a>中的System.Text.Js。</p>
<p>例如，若要将序列化程序配置为不更改属性名称的大小写（而不是默认的 &quot;camelCase&quot; 名称），请使用中的以下代码 <code>Startup.ConfigureServices</code> ：</p>
<pre><code class="lang-csharp">services.AddSignalR()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null;
    });
</code></pre>
<p>在 .NET 客户端中， <code>AddJsonProtocol</code> <a href="/dotnet/api/microsoft.aspnetcore.signalr.client.hubconnectionbuilder">HubConnectionBuilder</a>上存在相同的扩展方法。 <code>Microsoft.Extensions.DependencyInjection</code>必须导入命名空间才能解析扩展方法：</p>
<pre><code class="lang-csharp">// At the top of the file:
using Microsoft.Extensions.DependencyInjection;

// When constructing your connection:
var connection = new HubConnectionBuilder()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null;
    })
    .Build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 JSON 序列化。</p>
</div>
<h3 id="switch-to-newtonsoftjson">切换到 Newtonsoft.Js</h3>
<p>如果需要的功能 <code>Newtonsoft.Json</code> 在中不受支持 <code>System.Text.Json</code> ，请参阅 <a class="xref" href="../migration/22-to-30.html#switch-to-newtonsoftjson">切换到 Newtonsoft.Js</a>。</p>
<h3 id="messagepack-serialization-options">MessagePack 序列化选项</h3>
<p>可以通过向 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.msgpackprotocoldependencyinjectionextensions.addmessagepackprotocol">AddMessagePackProtocol</a> 调用提供委托来配置 MessagePack 序列化。 有关更多详细信息，请参阅<a class="xref" href="messagepackhubprotocol.html">中 SignalR 的 MessagePack</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 MessagePack 序列化。</p>
</div>
<h2 id="configure-server-options">配置服务器选项</h2>
<p>下表描述了用于配置中心的选项 SignalR ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ClientTimeoutInterval</code></td>
<td>30 秒</td>
<td>如果客户端未收到消息 (在此时间间隔内包含 keep-alive) ，服务器将认为客户端已断开连接。 由于实现方式的原因，客户端实际标记为断开连接可能需要更长的时间。 建议值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>如果客户端在此时间间隔内未发送初始握手消息，连接将关闭。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>如果服务器未在此时间间隔内发送消息，则会自动发送 ping 消息，使连接保持打开状态。 更改时 <code>KeepAliveInterval</code> ，请更改 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 客户端上的设置。 建议 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>SupportedProtocols</code></td>
<td>所有已安装的协议</td>
<td>此中心支持的协议。 默认情况下，将允许在服务器上注册的所有协议，但可以从此列表中删除协议，以禁用各个集线器的特定协议。</td>
</tr>
<tr>
<td><code>EnableDetailedErrors</code></td>
<td><code>false</code></td>
<td>如果为，则在 <code>true</code> 集线器方法中引发异常时，详细的异常消息将返回到客户端。 默认值为 <code>false</code> ，因为这些异常消息可能包含敏感信息。</td>
</tr>
<tr>
<td><code>StreamBufferCapacity</code></td>
<td><code>10</code></td>
<td>可为客户端上载流缓冲的最大项数。 如果达到此限制，则会阻止处理调用，直到服务器处理流项。</td>
</tr>
<tr>
<td><code>MaximumReceiveMessageSize</code></td>
<td>32 KB</td>
<td>单个传入集线器消息的最大大小。</td>
</tr>
</tbody>
</table>
<p>可以通过在中提供对调用的选项委托，为所有中心配置选项 <code>AddSignalR</code> <code>Startup.ConfigureServices</code> 。</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR(hubOptions =&gt;
    {
        hubOptions.EnableDetailedErrors = true;
        hubOptions.KeepAliveInterval = TimeSpan.FromMinutes(1);
    });
}
</code></pre>
<p>单个集线器的选项用于替代和中提供的全局选项 <code>AddSignalR</code> ，可以使用进行配置 &lt;xref:Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions*&gt; ：</p>
<pre><code class="lang-csharp">services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;
{
    options.EnableDetailedErrors = true;
});
</code></pre>
<h3 id="advanced-http-configuration-options">高级 HTTP 配置选项</h3>
<p>用于 <code>HttpConnectionDispatcherOptions</code> 配置与传输和内存缓冲区管理相关的高级设置。 这些选项通过将委托传递给中的<a href="/dotnet/api/microsoft.aspnetcore.builder.hubendpointroutebuilderextensions.maphub">MapHub &lt;T&gt; </a>来配置 <code>Startup.Configure</code> 。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;, options =&gt;
        {
            options.Transports =
                HttpTransportType.WebSockets |
                HttpTransportType.LongPolling;
        });
    });
}
</code></pre>
<p>下表描述了用于配置 ASP.NET Core SignalR 的高级 HTTP 选项的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationMaxBufferSize</code></td>
<td>32 KB</td>
<td>在应用反压之前，服务器从客户端接收的最大字节数。 增大此值后，服务器可以更快地接收更大的消息，而无需应用反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>AuthorizationData</code></td>
<td>从应用于 Hub 类的属性中自动收集的数据 <code>Authorize</code> 。</td>
<td>用于确定客户端是否有权连接到集线器的 <a href="/dotnet/api/microsoft.aspnetcore.authorization.iauthorizedata">IAuthorizeData</a> 对象的列表。</td>
</tr>
<tr>
<td><code>TransportMaxBufferSize</code></td>
<td>32 KB</td>
<td>在观察反压之前，服务器要发送的最大字节数。 增大此值后，服务器可以更快地缓冲更大的消息，而无需等待反压，但会增加内存消耗。</td>
</tr>
<tr>
<td><code>Transports</code></td>
<td>所有传输均已启用。</td>
<td>值的位标志枚举 <code>HttpTransportType</code> ，可限制客户端可用于连接的传输。</td>
</tr>
<tr>
<td><code>LongPolling</code></td>
<td>请参阅下文。</td>
<td>特定于长轮询传输的其他选项。</td>
</tr>
<tr>
<td><code>WebSockets</code></td>
<td>请参阅下文。</td>
<td>特定于 Websocket 传输的其他选项。</td>
</tr>
</tbody>
</table>
<p>长轮询传输具有可使用属性配置的其他选项 <code>LongPolling</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PollTimeout</code></td>
<td>90秒</td>
<td>服务器在终止单个轮询请求之前等待发送到客户端的消息的最长时间。 减小此值将导致客户端更频繁地发出新的投票请求。</td>
</tr>
</tbody>
</table>
<p>WebSocket 传输具有可使用属性配置的其他选项 <code>WebSockets</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>服务器关闭后，如果客户端在此时间间隔内未能关闭，则连接将终止。</td>
</tr>
<tr>
<td><code>SubProtocolSelector</code></td>
<td><code>null</code></td>
<td>一个委托，可用于将 <code>Sec-WebSocket-Protocol</code> 标头设置为自定义值。 委托接收客户端请求的值作为输入，并且应返回所需的值。</td>
</tr>
</tbody>
</table>
<h2 id="configure-client-options">配置客户端选项</h2>
<p>可以在 <code>HubConnectionBuilder</code> .net 和 JavaScript 客户端) 中可用的类型 (上配置客户端选项。 它在 Java 客户端中也可用，但 <code>HttpHubConnectionBuilder</code> 子类是包含生成器配置选项的内容，也是其 <code>HubConnection</code> 本身。</p>
<h3 id="configure-logging">配置日志记录</h3>
<p>使用方法在 .NET 客户端中配置日志记录 <code>ConfigureLogging</code> 。 日志提供程序和筛选器的注册方式与服务器上相同。 有关详细信息，请参阅 <a class="xref" href="../fundamentals/logging/index.html">ASP.NET Core 文档中的日志记录</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>若要注册日志记录提供程序，必须安装所需的包。 有关完整列表，请参阅文档的 <a class="xref" href="../fundamentals/logging/index.html#built-in-logging-providers">内置日志记录提供程序</a> 部分。</p>
</div>
<p>例如，若要启用控制台日志记录，请安装 <code>Microsoft.Extensions.Logging.Console</code> NuGet 包。 调用 <code>AddConsole</code> 扩展方法：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;)
    .ConfigureLogging(logging =&gt; {
        logging.SetMinimumLevel(LogLevel.Information);
        logging.AddConsole();
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，存在类似的 <code>configureLogging</code> 方法。 提供一个 <code>LogLevel</code> 值，该值指示要生成的日志消息的最小级别。 日志将写入浏览器控制台窗口中。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(signalR.LogLevel.Information)
    .build();
</code></pre>
<p><code>LogLevel</code>您还可以提供一个 <code>string</code> 表示日志级别名称的值，而不是一个值。 当 SignalR 你在无法访问常量的环境中配置日志记录时，这非常有用 <code>LogLevel</code> 。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(&quot;warn&quot;)
    .build();
</code></pre>
<p>下表列出了可用的日志级别。 为 <code>configureLogging</code> 设置将记录的 <strong>最小</strong> 日志级别而提供的值。 将记录在此级别上记录的消息 <strong>或在表中列出的级别</strong> 。</p>
<table>
<thead>
<tr>
<th>String</th>
<th>LogLevel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trace</code></td>
<td><code>LogLevel.Trace</code></td>
</tr>
<tr>
<td><code>debug</code></td>
<td><code>LogLevel.Debug</code></td>
</tr>
<tr>
<td><code>info</code> <strong>或</strong> <code>information</code></td>
<td><code>LogLevel.Information</code></td>
</tr>
<tr>
<td><code>warn</code> <strong>或</strong> <code>warning</code></td>
<td><code>LogLevel.Warning</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td><code>LogLevel.Error</code></td>
</tr>
<tr>
<td><code>critical</code></td>
<td><code>LogLevel.Critical</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td><code>LogLevel.None</code></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>若要完全禁用日志记录，请 <code>signalR.LogLevel.None</code> 在方法中指定 <code>configureLogging</code> 。</p>
</div>
<p>有关日志记录的详细信息，请参阅<a class="xref" href="diagnostics.html"> SignalR 诊断文档</a>。</p>
<p>SignalRJava 客户端使用<a href="https://www.slf4j.org/">SLF4J</a>库进行日志记录。 这是一个高级日志记录 API，它允许库的用户通过引入特定的日志记录依赖项来选择自己的特定日志记录实现。 下面的代码段演示如何将用于 <code>java.util.logging</code> SignalR Java 客户端。</p>
<pre><code class="lang-gradle">implementation 'org.slf4j:slf4j-jdk14:1.7.25'
</code></pre>
<p>如果未在依赖项中配置日志记录，SLF4J 将加载默认的非操作记录器，并提供以下警告消息：</p>
<pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>可以安全地忽略此情况。</p>
<h3 id="configure-allowed-transports">配置允许的传输</h3>
<p>使用的传输 SignalR 可在 <code>WithUrl</code> JavaScript) 的调用 (中进行配置 <code>withUrl</code> 。 的值的按位 &quot;或&quot; <code>HttpTransportType</code> 可用于将客户端限制为仅使用指定的传输。 默认情况下，将启用所有传输。</p>
<p>例如，禁用 Server-Sent 事件传输，但允许 Websocket 和长轮询连接：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, HttpTransportType.WebSockets | HttpTransportType.LongPolling)
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>transport</code> 在提供的选项对象上设置字段来配置传输 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling })
    .build();
</code></pre>
<p>此版本的 Java 客户端 websocket 是唯一可用的传输。</p>
<p>在 Java 客户端中，通过中的方法选择了传输 <code>withTransport</code> <code>HttpHubConnectionBuilder</code> 。 Java 客户端默认使用 Websocket 传输。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withTransport(TransportEnum.WEBSOCKETS)
    .build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>SignalRJava 客户端尚不支持传输回退。</p>
</div>
<h3 id="configure-bearer-authentication">配置持有者身份验证</h3>
<p>若要与请求一起提供身份验证数据 SignalR ，请使用 <code>AccessTokenProvider</code> <code>accessTokenFactory</code> JavaScript) 中 (选项来指定返回所需访问令牌的函数。 在 .NET 客户端中，此访问令牌作为 HTTP &quot;持有者身份验证&quot; 令牌传入 (使用 <code>Authorization</code>) 类型的标头 <code>Bearer</code> 。 在 JavaScript 客户端中，访问令牌用作持有者令牌， <strong>但</strong> 在某些情况下，浏览器 api 会限制在 Server-Sent 事件和 websocket 请求)  (具体应用标头的能力。 在这些情况下，访问令牌作为查询字符串值提供 <code>access_token</code> 。</p>
<p>在 .NET 客户端中， <code>AccessTokenProvider</code> 可使用中的选项委托指定选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.AccessTokenProvider = async () =&gt; {
            // Get and return the access token.
        };
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>accessTokenFactory</code> 在中设置 &quot;选项&quot; 对象上的字段来配置访问令牌 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        accessTokenFactory: () =&gt; {
            // Get and return the access token.
            // This function can return a JavaScript Promise if asynchronous
            // logic is required to retrieve the access token.
        }
    })
    .build();
</code></pre>
<p>在 SignalR Java 客户端中，可以通过向 <a href="/java/api/com.microsoft.signalr._http_hub_connection_builder?view=aspnet-signalr-java">HttpHubConnectionBuilder</a>提供访问令牌工厂来配置用于身份验证的持有者令牌。 使用<a href="/java/api/com.microsoft.signalr._http_hub_connection_builder.withaccesstokenprovider?view=aspnet-signalr-java#com_microsoft_signalr__http_hub_connection_builder_withAccessTokenProvider_Single_String__">withAccessTokenFactory</a>提供<a href="https://github.com/ReactiveX/RxJava">RxJava</a> <a href="https://reactivex.io/documentation/single.html">Single &lt;String&gt; </a>。 如果调用了 <a href="https://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#defer-java.util.concurrent.Callable-">单延迟</a>，你可以编写逻辑来为客户端生成访问令牌。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withAccessTokenProvider(Single.defer(() -&gt; {
        // Your logic here.
        return Single.just(&quot;An Access Token&quot;);
    })).build();
</code></pre>
<h3 id="configure-timeout-and-keep-alive-options">配置超时和 keep-alive 选项</h3>
<p>用于配置超时和保持活动状态的其他选项可用于 <code>HubConnection</code> 对象本身：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-4_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
<p>在 .NET 客户端中，超时值指定为 <code>TimeSpan</code> 值。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-4_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>serverTimeoutInMilliseconds</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onclose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>keepAliveIntervalInMilliseconds</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-4_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getServerTimeout</code> / <code>setServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onClose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>withHandshakeResponseTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并触发 <code>onClose</code> 事件。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>getKeepAliveInterval</code> / <code>setKeepAliveInterval</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
</div>
<h3 id="configure-additional-options">配置其他选项</h3>
<p>可以在中的 <code>WithUrl</code> <code>withUrl</code> JavaScript) 方法 (上 <code>HubConnectionBuilder</code> 或在 <code>HttpHubConnectionBuilder</code> Java 客户端中的各种配置 api 上配置其他选项：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-5_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>.NET 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>SkipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>ClientCertificates</code></td>
<td>空</td>
<td>要发送以对请求进行身份验证的 TLS 证书的集合。</td>
</tr>
<tr>
<td><code>Cookies</code></td>
<td>空</td>
<td>cookie要随每个 http 请求一起发送的 http 的集合。</td>
</tr>
<tr>
<td><code>Credentials</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的凭据。</td>
</tr>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>仅 Websocket。 客户端在关闭之后等待服务器确认关闭请求的最长时间。 如果服务器在这段时间内没有确认关闭，客户端将断开连接。</td>
</tr>
<tr>
<td><code>Headers</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
<tr>
<td><code>HttpMessageHandlerFactory</code></td>
<td><code>null</code></td>
<td>一个委托，可用于配置或替换 <code>HttpMessageHandler</code> 用于发送 HTTP 请求的。 不用于 WebSocket 连接。 此委托必须返回非 null 值，并接收默认值作为参数。 修改该默认值的设置并将其返回，或返回一个新的 <code>HttpMessageHandler</code> 实例。 <strong>当替换处理程序时，请确保从提供的处理程序复制您要保留的设置，否则，所配置的选项 (如 Cookie s 和标头) 将不会应用于新的处理程序。</strong></td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td><code>null</code></td>
<td>发送 HTTP 请求时要使用的 HTTP 代理。</td>
</tr>
<tr>
<td><code>UseDefaultCredentials</code></td>
<td><code>false</code></td>
<td>设置此布尔值可发送 HTTP 和 Websocket 请求的默认凭据。 这样就可以使用 Windows 身份验证。</td>
</tr>
<tr>
<td><code>WebSocketConfiguration</code></td>
<td><code>null</code></td>
<td>可用于配置其他 WebSocket 选项的委托。 接收可用于配置选项的 <a href="/dotnet/api/system.net.websockets.clientwebsocketoptions">ClientWebSocketOptions</a> 实例。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-5_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>JavaScript 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accessTokenFactory</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>transport</code></td>
<td><code>null</code></td>
<td>一个 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType&gt; 值，该值指定用于连接的传输。</td>
</tr>
<tr>
<td><code>logMessageContent</code></td>
<td><code>null</code></td>
<td>设置为 <code>true</code> 可记录客户端发送和接收的消息的字节数/字符数。</td>
</tr>
<tr>
<td><code>skipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-5_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>Java 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>withAccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>shouldSkipNegotiate</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withHeader</code> <code>withHeaders</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
</tbody>
</table>
</section>
</div>

<p>在 .NET 客户端中，可以通过提供给的 options 委托来修改这些选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.Headers[&quot;Foo&quot;] = &quot;Bar&quot;;
        options.Cookies.Add(new Cookie(/* ... */);
        options.ClientCertificates.Add(/* ... */);
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，可以在提供给的 JavaScript 对象中提供这些选项 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        skipNegotiation: true,
        transport: signalR.HttpTransportType.WebSockets
    })
    .build();
</code></pre>
<p>在 Java 客户端中，这些选项可以在 <code>HttpHubConnectionBuilder</code> 从 <code>HubConnectionBuilder.create(&quot;HUB URL&quot;)</code></p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
        .withHeader(&quot;Foo&quot;, &quot;Bar&quot;)
        .shouldSkipNegotiate(true)
        .withHandshakeResponseTimeout(30*1000)
        .build();
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../tutorials/signalr.html">ASP.NET Core SignalR 入门</a></li>
<li><a class="xref" href="hubs.html">在 ASP.NET Core 中使用中心 SignalR</a></li>
<li><a class="xref" href="javascript-client.html">ASP.NET Core SignalR JavaScript 客户端</a></li>
<li><a class="xref" href="dotnet-client.html">ASP.NET Core SignalR .Net 客户端</a></li>
<li><a class="xref" href="messagepackhubprotocol.html">使用中的 MessagePack Hub 协议 SignalR 进行 ASP.NET Core</a></li>
<li><a class="xref" href="supported-platforms.html">ASP.NET Core SignalR 支持的平台</a></li>
</ul>
</div>
<div range="= aspnetcore-2.2">
<h2 id="jsonmessagepack-serialization-options">JSON/MessagePack 序列化选项</h2>
<p>ASP.NET Core SignalR 支持两个用于编码消息的协议： <a href="https://www.json.org/">JSON</a> 和 <a href="https://msgpack.org/index.html">MessagePack</a>。 每个协议都具有序列化配置选项。</p>
<p>可以使用<a href="/dotnet/api/microsoft.extensions.dependencyinjection.jsonprotocoldependencyinjectionextensions.addjsonprotocol">AddJsonProtocol</a>扩展方法在服务器上配置 JSON 序列化，该扩展方法可在方法<a href="/dotnet/api/microsoft.extensions.dependencyinjection.signalrdependencyinjectionextensions.addsignalr">添加 SignalR </a>后添加 <code>Startup.ConfigureServices</code> 。 <code>AddJsonProtocol</code>方法采用接收对象的委托 <code>options</code> 。 该对象的 <a href="/dotnet/api/microsoft.aspnetcore.signalr.jsonhubprotocoloptions.payloadserializersettings">PayloadSerializerSettings</a> 属性是一个 JSON.NET <code>JsonSerializerSettings</code> 对象，该对象可用于配置自变量和返回值的序列化。 有关详细信息，请参阅 <a href="https://www.newtonsoft.com/json/help/html/Introduction.htm">JSON.NET 文档</a>。</p>
<p>例如，若要将序列化程序配置为使用 &quot;PascalCase&quot; 属性名称，而不是默认的 &quot;camelCase&quot; 名称，请在中使用以下代码 <code>Startup.ConfigureServices</code> ：</p>
<pre><code class="lang-csharp">services.AddSignalR()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerSettings.ContractResolver =
            new DefaultContractResolver();
    });
</code></pre>
<p>在 .NET 客户端中， <code>AddJsonProtocol</code> <a href="/dotnet/api/microsoft.aspnetcore.signalr.client.hubconnectionbuilder">HubConnectionBuilder</a>上存在相同的扩展方法。 <code>Microsoft.Extensions.DependencyInjection</code>必须导入命名空间才能解析扩展方法：</p>
<pre><code class="lang-csharp">// At the top of the file:
using Microsoft.Extensions.DependencyInjection;

// When constructing your connection:
var connection = new HubConnectionBuilder()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerSettings.ContractResolver =
            new DefaultContractResolver();
    })
    .Build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 JSON 序列化。</p>
</div>
<h3 id="messagepack-serialization-options">MessagePack 序列化选项</h3>
<p>可以通过向 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.msgpackprotocoldependencyinjectionextensions.addmessagepackprotocol">AddMessagePackProtocol</a> 调用提供委托来配置 MessagePack 序列化。 有关更多详细信息，请参阅<a class="xref" href="messagepackhubprotocol.html">中 SignalR 的 MessagePack</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 MessagePack 序列化。</p>
</div>
<h2 id="configure-server-options">配置服务器选项</h2>
<p>下表描述了用于配置中心的选项 SignalR ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ClientTimeoutInterval</code></td>
<td>30 秒</td>
<td>如果客户端未收到消息 (在此时间间隔内包含 keep-alive) ，服务器将认为客户端已断开连接。 由于实现方式的原因，客户端实际标记为断开连接可能需要更长的时间。 建议值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>如果客户端在此时间间隔内未发送初始握手消息，连接将关闭。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>如果服务器未在此时间间隔内发送消息，则会自动发送 ping 消息，使连接保持打开状态。 更改时 <code>KeepAliveInterval</code> ，请更改 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 客户端上的设置。 建议 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>SupportedProtocols</code></td>
<td>所有已安装的协议</td>
<td>此中心支持的协议。 默认情况下，将允许在服务器上注册的所有协议，但可以从此列表中删除协议，以禁用各个集线器的特定协议。</td>
</tr>
<tr>
<td><code>EnableDetailedErrors</code></td>
<td><code>false</code></td>
<td>如果为，则在 <code>true</code> 集线器方法中引发异常时，详细的异常消息将返回到客户端。 默认值为 <code>false</code> ，因为这些异常消息可能包含敏感信息。</td>
</tr>
</tbody>
</table>
<p>可以通过在中提供对调用的选项委托，为所有中心配置选项 <code>AddSignalR</code> <code>Startup.ConfigureServices</code> 。</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR(hubOptions =&gt;
    {
        hubOptions.EnableDetailedErrors = true;
        hubOptions.KeepAliveInterval = TimeSpan.FromMinutes(1);
    });
}
</code></pre>
<p>单个集线器的选项用于替代和中提供的全局选项 <code>AddSignalR</code> ，可以使用进行配置 &lt;xref:Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions*&gt; ：</p>
<pre><code class="lang-csharp">services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;
{
    options.EnableDetailedErrors = true;
});
</code></pre>
<h3 id="advanced-http-configuration-options">高级 HTTP 配置选项</h3>
<p>用于 <code>HttpConnectionDispatcherOptions</code> 配置与传输和内存缓冲区管理相关的高级设置。 这些选项通过将委托传递给中的<a href="/dotnet/api/microsoft.aspnetcore.signalr.hubroutebuilder.maphub">MapHub &lt;T&gt; </a>来配置 <code>Startup.Configure</code> 。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseSignalR((configure) =&gt;
    {
        var desiredTransports =
            HttpTransportType.WebSockets |
            HttpTransportType.LongPolling;

        configure.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;, (options) =&gt;
        {
            options.Transports = desiredTransports;
        });
    });
}
</code></pre>
<p>下表描述了用于配置 ASP.NET Core SignalR 的高级 HTTP 选项的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationMaxBufferSize</code></td>
<td>32 KB</td>
<td>服务器缓冲的客户端接收到的最大字节数。 增大此值可使服务器接收更大的消息，但可能会对内存消耗产生负面影响。</td>
</tr>
<tr>
<td><code>AuthorizationData</code></td>
<td>从应用于 Hub 类的属性中自动收集的数据 <code>Authorize</code> 。</td>
<td>用于确定客户端是否有权连接到集线器的 <a href="/dotnet/api/microsoft.aspnetcore.authorization.iauthorizedata">IAuthorizeData</a> 对象的列表。</td>
</tr>
<tr>
<td><code>TransportMaxBufferSize</code></td>
<td>32 KB</td>
<td>由服务器缓冲的应用发送的最大字节数。 增大此值后，服务器将发送更大的消息，但会对内存消耗产生负面影响。</td>
</tr>
<tr>
<td><code>Transports</code></td>
<td>所有传输均已启用。</td>
<td>值的位标志枚举 <code>HttpTransportType</code> ，可限制客户端可用于连接的传输。</td>
</tr>
<tr>
<td><code>LongPolling</code></td>
<td>请参阅下文。</td>
<td>特定于长轮询传输的其他选项。</td>
</tr>
<tr>
<td><code>WebSockets</code></td>
<td>请参阅下文。</td>
<td>特定于 Websocket 传输的其他选项。</td>
</tr>
</tbody>
</table>
<p>长轮询传输具有可使用属性配置的其他选项 <code>LongPolling</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PollTimeout</code></td>
<td>90秒</td>
<td>服务器在终止单个轮询请求之前等待发送到客户端的消息的最长时间。 减小此值将导致客户端更频繁地发出新的投票请求。</td>
</tr>
</tbody>
</table>
<p>WebSocket 传输具有可使用属性配置的其他选项 <code>WebSockets</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>服务器关闭后，如果客户端在此时间间隔内未能关闭，则连接将终止。</td>
</tr>
<tr>
<td><code>SubProtocolSelector</code></td>
<td><code>null</code></td>
<td>一个委托，可用于将 <code>Sec-WebSocket-Protocol</code> 标头设置为自定义值。 委托接收客户端请求的值作为输入，并且应返回所需的值。</td>
</tr>
</tbody>
</table>
<h2 id="configure-client-options">配置客户端选项</h2>
<p>可以在 <code>HubConnectionBuilder</code> .net 和 JavaScript 客户端) 中可用的类型 (上配置客户端选项。 它在 Java 客户端中也可用，但 <code>HttpHubConnectionBuilder</code> 子类是包含生成器配置选项的内容，也是其 <code>HubConnection</code> 本身。</p>
<h3 id="configure-logging">配置日志记录</h3>
<p>使用方法在 .NET 客户端中配置日志记录 <code>ConfigureLogging</code> 。 日志提供程序和筛选器的注册方式与服务器上相同。 有关详细信息，请参阅 <a class="xref" href="../fundamentals/logging/index.html">ASP.NET Core 文档中的日志记录</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>若要注册日志记录提供程序，必须安装所需的包。 有关完整列表，请参阅文档的 <a class="xref" href="../fundamentals/logging/index.html#built-in-logging-providers">内置日志记录提供程序</a> 部分。</p>
</div>
<p>例如，若要启用控制台日志记录，请安装 <code>Microsoft.Extensions.Logging.Console</code> NuGet 包。 调用 <code>AddConsole</code> 扩展方法：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;)
    .ConfigureLogging(logging =&gt; {
        logging.SetMinimumLevel(LogLevel.Information);
        logging.AddConsole();
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，存在类似的 <code>configureLogging</code> 方法。 提供一个 <code>LogLevel</code> 值，该值指示要生成的日志消息的最小级别。 日志将写入浏览器控制台窗口中。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(signalR.LogLevel.Information)
    .build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>若要完全禁用日志记录，请 <code>signalR.LogLevel.None</code> 在方法中指定 <code>configureLogging</code> 。</p>
</div>
<p>有关日志记录的详细信息，请参阅<a class="xref" href="diagnostics.html"> SignalR 诊断文档</a>。</p>
<p>SignalRJava 客户端使用<a href="https://www.slf4j.org/">SLF4J</a>库进行日志记录。 这是一个高级日志记录 API，它允许库的用户通过引入特定的日志记录依赖项来选择自己的特定日志记录实现。 下面的代码段演示如何将用于 <code>java.util.logging</code> SignalR Java 客户端。</p>
<pre><code class="lang-gradle">implementation 'org.slf4j:slf4j-jdk14:1.7.25'
</code></pre>
<p>如果未在依赖项中配置日志记录，SLF4J 将加载默认的非操作记录器，并提供以下警告消息：</p>
<pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>可以安全地忽略此情况。</p>
<h3 id="configure-allowed-transports">配置允许的传输</h3>
<p>使用的传输 SignalR 可在 <code>WithUrl</code> JavaScript) 的调用 (中进行配置 <code>withUrl</code> 。 的值的按位 &quot;或&quot; <code>HttpTransportType</code> 可用于将客户端限制为仅使用指定的传输。 默认情况下，将启用所有传输。</p>
<p>例如，禁用 Server-Sent 事件传输，但允许 Websocket 和长轮询连接：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, HttpTransportType.WebSockets | HttpTransportType.LongPolling)
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>transport</code> 在提供的选项对象上设置字段来配置传输 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling })
    .build();
</code></pre>
<p>此版本的 Java 客户端 websocket 是唯一可用的传输。</p>
<h3 id="configure-bearer-authentication">配置持有者身份验证</h3>
<p>若要与请求一起提供身份验证数据 SignalR ，请使用 <code>AccessTokenProvider</code> <code>accessTokenFactory</code> JavaScript) 中 (选项来指定返回所需访问令牌的函数。 在 .NET 客户端中，此访问令牌作为 HTTP &quot;持有者身份验证&quot; 令牌传入 (使用 <code>Authorization</code>) 类型的标头 <code>Bearer</code> 。 在 JavaScript 客户端中，访问令牌用作持有者令牌， <strong>但</strong> 在某些情况下，浏览器 api 会限制在 Server-Sent 事件和 websocket 请求)  (具体应用标头的能力。 在这些情况下，访问令牌作为查询字符串值提供 <code>access_token</code> 。</p>
<p>在 .NET 客户端中， <code>AccessTokenProvider</code> 可使用中的选项委托指定选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.AccessTokenProvider = async () =&gt; {
            // Get and return the access token.
        };
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>accessTokenFactory</code> 在中设置 &quot;选项&quot; 对象上的字段来配置访问令牌 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        accessTokenFactory: () =&gt; {
            // Get and return the access token.
            // This function can return a JavaScript Promise if asynchronous
            // logic is required to retrieve the access token.
        }
    })
    .build();
</code></pre>
<p>在 SignalR Java 客户端中，可以通过向 <a href="/java/api/com.microsoft.signalr._http_hub_connection_builder?view=aspnet-signalr-java">HttpHubConnectionBuilder</a>提供访问令牌工厂来配置用于身份验证的持有者令牌。 使用<a href="/java/api/com.microsoft.signalr._http_hub_connection_builder.withaccesstokenprovider?view=aspnet-signalr-java#com_microsoft_signalr__http_hub_connection_builder_withAccessTokenProvider_Single_String__">withAccessTokenFactory</a>提供<a href="https://github.com/ReactiveX/RxJava">RxJava</a> <a href="https://reactivex.io/documentation/single.html">Single &lt;String&gt; </a>。 如果调用了 <a href="https://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#defer-java.util.concurrent.Callable-">单延迟</a>，你可以编写逻辑来为客户端生成访问令牌。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withAccessTokenProvider(Single.defer(() -&gt; {
        // Your logic here.
        return Single.just(&quot;An Access Token&quot;);
    })).build();
</code></pre>
<h3 id="configure-timeout-and-keep-alive-options">配置超时和 keep-alive 选项</h3>
<p>用于配置超时和保持活动状态的其他选项可用于 <code>HubConnection</code> 对象本身：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-6_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
<p>在 .NET 客户端中，超时值指定为 <code>TimeSpan</code> 值。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-6_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>serverTimeoutInMilliseconds</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onclose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>keepAliveIntervalInMilliseconds</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-6_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getServerTimeout</code> / <code>setServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onClose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>withHandshakeResponseTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并触发 <code>onClose</code> 事件。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>getKeepAliveInterval</code> / <code>setKeepAliveInterval</code></td>
<td>15秒 (15000 毫秒)</td>
<td>确定客户端发送 ping 消息的间隔。 如果从客户端发送任何消息，则会将计时器重置为间隔的开始时间。 如果客户端没有在服务器上的设置中发送消息 <code>ClientTimeoutInterval</code> ，则服务器会将客户端视为已断开连接。</td>
</tr>
</tbody>
</table>
</section>
</div>
<h3 id="configure-additional-options">配置其他选项</h3>
<p>可以在中的 <code>WithUrl</code> <code>withUrl</code> JavaScript) 方法 (上 <code>HubConnectionBuilder</code> 或在 <code>HttpHubConnectionBuilder</code> Java 客户端中的各种配置 api 上配置其他选项：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-7_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>.NET 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>SkipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>ClientCertificates</code></td>
<td>空</td>
<td>要发送以对请求进行身份验证的 TLS 证书的集合。</td>
</tr>
<tr>
<td><code>Cookies</code></td>
<td>空</td>
<td>cookie要随每个 http 请求一起发送的 http 的集合。</td>
</tr>
<tr>
<td><code>Credentials</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的凭据。</td>
</tr>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>仅 Websocket。 客户端在关闭之后等待服务器确认关闭请求的最长时间。 如果服务器在这段时间内没有确认关闭，客户端将断开连接。</td>
</tr>
<tr>
<td><code>Headers</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
<tr>
<td><code>HttpMessageHandlerFactory</code></td>
<td><code>null</code></td>
<td>一个委托，可用于配置或替换 <code>HttpMessageHandler</code> 用于发送 HTTP 请求的。 不用于 WebSocket 连接。 此委托必须返回非 null 值，并接收默认值作为参数。 修改该默认值的设置并将其返回，或返回一个新的 <code>HttpMessageHandler</code> 实例。 <strong>当替换处理程序时，请确保从提供的处理程序复制您要保留的设置，否则，所配置的选项 (如 Cookie s 和标头) 将不会应用于新的处理程序。</strong></td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td><code>null</code></td>
<td>发送 HTTP 请求时要使用的 HTTP 代理。</td>
</tr>
<tr>
<td><code>UseDefaultCredentials</code></td>
<td><code>false</code></td>
<td>设置此布尔值可发送 HTTP 和 Websocket 请求的默认凭据。 这样就可以使用 Windows 身份验证。</td>
</tr>
<tr>
<td><code>WebSocketConfiguration</code></td>
<td><code>null</code></td>
<td>可用于配置其他 WebSocket 选项的委托。 接收可用于配置选项的 <a href="/dotnet/api/system.net.websockets.clientwebsocketoptions">ClientWebSocketOptions</a> 实例。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-7_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>JavaScript 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accessTokenFactory</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>transport</code></td>
<td><code>null</code></td>
<td>一个 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType&gt; 值，该值指定用于连接的传输。</td>
</tr>
<tr>
<td><code>logMessageContent</code></td>
<td><code>null</code></td>
<td>设置为 <code>true</code> 可记录客户端发送和接收的消息的字节数/字符数。</td>
</tr>
<tr>
<td><code>skipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-7_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>Java 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>withAccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>shouldSkipNegotiate</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withHeader</code> <code>withHeaders</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
</tbody>
</table>
</section>
</div>

<p>在 .NET 客户端中，可以通过提供给的 options 委托来修改这些选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.Headers[&quot;Foo&quot;] = &quot;Bar&quot;;
        options.Cookies.Add(new Cookie(/* ... */);
        options.ClientCertificates.Add(/* ... */);
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，可以在提供给的 JavaScript 对象中提供这些选项 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        skipNegotiation: true,
        transport: signalR.HttpTransportType.WebSockets
    })
    .build();
</code></pre>
<p>在 Java 客户端中，这些选项可以在 <code>HttpHubConnectionBuilder</code> 从 <code>HubConnectionBuilder.create(&quot;HUB URL&quot;)</code></p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
        .withHeader(&quot;Foo&quot;, &quot;Bar&quot;)
        .shouldSkipNegotiate(true)
        .withHandshakeResponseTimeout(30*1000)
        .build();
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../tutorials/signalr.html">ASP.NET Core SignalR 入门</a></li>
<li><a class="xref" href="hubs.html">在 ASP.NET Core 中使用中心 SignalR</a></li>
<li><a class="xref" href="javascript-client.html">ASP.NET Core SignalR JavaScript 客户端</a></li>
<li><a class="xref" href="dotnet-client.html">ASP.NET Core SignalR .Net 客户端</a></li>
<li><a class="xref" href="messagepackhubprotocol.html">使用中的 MessagePack Hub 协议 SignalR 进行 ASP.NET Core</a></li>
<li><a class="xref" href="supported-platforms.html">ASP.NET Core SignalR 支持的平台</a></li>
</ul>
</div>
<div range="&lt; aspnetcore-2.2">
<h2 id="jsonmessagepack-serialization-options">JSON/MessagePack 序列化选项</h2>
<p>ASP.NET Core SignalR 支持两个用于编码消息的协议： <a href="https://www.json.org/">JSON</a> 和 <a href="https://msgpack.org/index.html">MessagePack</a>。 每个协议都具有序列化配置选项。</p>
<p>可以使用<a href="/dotnet/api/microsoft.extensions.dependencyinjection.jsonprotocoldependencyinjectionextensions.addjsonprotocol">AddJsonProtocol</a>扩展方法在服务器上配置 JSON 序列化，该扩展方法可在方法<a href="/dotnet/api/microsoft.extensions.dependencyinjection.signalrdependencyinjectionextensions.addsignalr">添加 SignalR </a>后添加 <code>Startup.ConfigureServices</code> 。 <code>AddJsonProtocol</code>方法采用接收对象的委托 <code>options</code> 。 该对象的 <a href="/dotnet/api/microsoft.aspnetcore.signalr.jsonhubprotocoloptions.payloadserializersettings">PayloadSerializerSettings</a> 属性是一个 JSON.NET <code>JsonSerializerSettings</code> 对象，该对象可用于配置自变量和返回值的序列化。 有关详细信息，请参阅 <a href="https://www.newtonsoft.com/json/help/html/Introduction.htm">JSON.NET 文档</a>。</p>
<p>例如，若要将序列化程序配置为使用 &quot;PascalCase&quot; 属性名称，而不是默认的 &quot;camelCase&quot; 名称，请在中使用以下代码 <code>Startup.ConfigureServices</code> ：</p>
<pre><code class="lang-csharp">services.AddSignalR()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerSettings.ContractResolver =
            new DefaultContractResolver();
    });
</code></pre>
<p>在 .NET 客户端中， <code>AddJsonProtocol</code> <a href="/dotnet/api/microsoft.aspnetcore.signalr.client.hubconnectionbuilder">HubConnectionBuilder</a>上存在相同的扩展方法。 <code>Microsoft.Extensions.DependencyInjection</code>必须导入命名空间才能解析扩展方法：</p>
<pre><code class="lang-csharp">// At the top of the file:
using Microsoft.Extensions.DependencyInjection;

// When constructing your connection:
var connection = new HubConnectionBuilder()
    .AddJsonProtocol(options =&gt; {
        options.PayloadSerializerSettings.ContractResolver =
            new DefaultContractResolver();
    })
    .Build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 JSON 序列化。</p>
</div>
<h3 id="messagepack-serialization-options">MessagePack 序列化选项</h3>
<p>可以通过向 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.msgpackprotocoldependencyinjectionextensions.addmessagepackprotocol">AddMessagePackProtocol</a> 调用提供委托来配置 MessagePack 序列化。 有关更多详细信息，请参阅<a class="xref" href="messagepackhubprotocol.html">中 SignalR 的 MessagePack</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>目前不能在 JavaScript 客户端中配置 MessagePack 序列化。</p>
</div>
<h2 id="configure-server-options">配置服务器选项</h2>
<p>下表描述了用于配置中心的选项 SignalR ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>如果客户端在此时间间隔内未发送初始握手消息，连接将关闭。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
<tr>
<td><code>KeepAliveInterval</code></td>
<td>15 秒</td>
<td>如果服务器未在此时间间隔内发送消息，则会自动发送 ping 消息，使连接保持打开状态。 更改时 <code>KeepAliveInterval</code> ，请更改 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 客户端上的设置。 建议 <code>ServerTimeout</code> / <code>serverTimeoutInMilliseconds</code> 值为值的两倍 <code>KeepAliveInterval</code> 。</td>
</tr>
<tr>
<td><code>SupportedProtocols</code></td>
<td>所有已安装的协议</td>
<td>此中心支持的协议。 默认情况下，将允许在服务器上注册的所有协议，但可以从此列表中删除协议，以禁用各个集线器的特定协议。</td>
</tr>
<tr>
<td><code>EnableDetailedErrors</code></td>
<td><code>false</code></td>
<td>如果为，则在 <code>true</code> 集线器方法中引发异常时，详细的异常消息将返回到客户端。 默认值为 <code>false</code> ，因为这些异常消息可能包含敏感信息。</td>
</tr>
</tbody>
</table>
<p>可以通过在中提供对调用的选项委托，为所有中心配置选项 <code>AddSignalR</code> <code>Startup.ConfigureServices</code> 。</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR(hubOptions =&gt;
    {
        hubOptions.EnableDetailedErrors = true;
        hubOptions.KeepAliveInterval = TimeSpan.FromMinutes(1);
    });
}
</code></pre>
<p>单个集线器的选项用于替代和中提供的全局选项 <code>AddSignalR</code> ，可以使用进行配置 &lt;xref:Microsoft.Extensions.DependencyInjection.SignalRDependencyInjectionExtensions.AddHubOptions*&gt; ：</p>
<pre><code class="lang-csharp">services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;
{
    options.EnableDetailedErrors = true;
});
</code></pre>
<h3 id="advanced-http-configuration-options">高级 HTTP 配置选项</h3>
<p>用于 <code>HttpConnectionDispatcherOptions</code> 配置与传输和内存缓冲区管理相关的高级设置。 这些选项通过将委托传递给中的<a href="/dotnet/api/microsoft.aspnetcore.signalr.hubroutebuilder.maphub">MapHub &lt;T&gt; </a>来配置 <code>Startup.Configure</code> 。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseSignalR((configure) =&gt;
    {
        var desiredTransports =
            HttpTransportType.WebSockets |
            HttpTransportType.LongPolling;

        configure.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;, (options) =&gt;
        {
            options.Transports = desiredTransports;
        });
    });
}
</code></pre>
<p>下表描述了用于配置 ASP.NET Core SignalR 的高级 HTTP 选项的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationMaxBufferSize</code></td>
<td>32 KB</td>
<td>服务器缓冲的客户端接收到的最大字节数。 增大此值可使服务器接收更大的消息，但可能会对内存消耗产生负面影响。</td>
</tr>
<tr>
<td><code>AuthorizationData</code></td>
<td>从应用于 Hub 类的属性中自动收集的数据 <code>Authorize</code> 。</td>
<td>用于确定客户端是否有权连接到集线器的 <a href="/dotnet/api/microsoft.aspnetcore.authorization.iauthorizedata">IAuthorizeData</a> 对象的列表。</td>
</tr>
<tr>
<td><code>TransportMaxBufferSize</code></td>
<td>32 KB</td>
<td>由服务器缓冲的应用发送的最大字节数。 增大此值后，服务器将发送更大的消息，但会对内存消耗产生负面影响。</td>
</tr>
<tr>
<td><code>Transports</code></td>
<td>所有传输均已启用。</td>
<td>值的位标志枚举 <code>HttpTransportType</code> ，可限制客户端可用于连接的传输。</td>
</tr>
<tr>
<td><code>LongPolling</code></td>
<td>请参阅下文。</td>
<td>特定于长轮询传输的其他选项。</td>
</tr>
<tr>
<td><code>WebSockets</code></td>
<td>请参阅下文。</td>
<td>特定于 Websocket 传输的其他选项。</td>
</tr>
</tbody>
</table>
<p>长轮询传输具有可使用属性配置的其他选项 <code>LongPolling</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PollTimeout</code></td>
<td>90秒</td>
<td>服务器在终止单个轮询请求之前等待发送到客户端的消息的最长时间。 减小此值将导致客户端更频繁地发出新的投票请求。</td>
</tr>
</tbody>
</table>
<p>WebSocket 传输具有可使用属性配置的其他选项 <code>WebSockets</code> ：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>服务器关闭后，如果客户端在此时间间隔内未能关闭，则连接将终止。</td>
</tr>
<tr>
<td><code>SubProtocolSelector</code></td>
<td><code>null</code></td>
<td>一个委托，可用于将 <code>Sec-WebSocket-Protocol</code> 标头设置为自定义值。 委托接收客户端请求的值作为输入，并且应返回所需的值。</td>
</tr>
</tbody>
</table>
<h2 id="configure-client-options">配置客户端选项</h2>
<p>可以在 <code>HubConnectionBuilder</code> .net 和 JavaScript 客户端) 中可用的类型 (上配置客户端选项。 它在 Java 客户端中也可用，但 <code>HttpHubConnectionBuilder</code> 子类是包含生成器配置选项的内容，也是其 <code>HubConnection</code> 本身。</p>
<h3 id="configure-logging">配置日志记录</h3>
<p>使用方法在 .NET 客户端中配置日志记录 <code>ConfigureLogging</code> 。 日志提供程序和筛选器的注册方式与服务器上相同。 有关详细信息，请参阅 <a class="xref" href="../fundamentals/logging/index.html">ASP.NET Core 文档中的日志记录</a> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>若要注册日志记录提供程序，必须安装所需的包。 有关完整列表，请参阅文档的 <a class="xref" href="../fundamentals/logging/index.html#built-in-logging-providers">内置日志记录提供程序</a> 部分。</p>
</div>
<p>例如，若要启用控制台日志记录，请安装 <code>Microsoft.Extensions.Logging.Console</code> NuGet 包。 调用 <code>AddConsole</code> 扩展方法：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;)
    .ConfigureLogging(logging =&gt; {
        logging.SetMinimumLevel(LogLevel.Information);
        logging.AddConsole();
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，存在类似的 <code>configureLogging</code> 方法。 提供一个 <code>LogLevel</code> 值，该值指示要生成的日志消息的最小级别。 日志将写入浏览器控制台窗口中。</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .configureLogging(signalR.LogLevel.Information)
    .build();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>若要完全禁用日志记录，请 <code>signalR.LogLevel.None</code> 在方法中指定 <code>configureLogging</code> 。</p>
</div>
<p>有关日志记录的详细信息，请参阅<a class="xref" href="diagnostics.html"> SignalR 诊断文档</a>。</p>
<p>SignalRJava 客户端使用<a href="https://www.slf4j.org/">SLF4J</a>库进行日志记录。 这是一个高级日志记录 API，它允许库的用户通过引入特定的日志记录依赖项来选择自己的特定日志记录实现。 下面的代码段演示如何将用于 <code>java.util.logging</code> SignalR Java 客户端。</p>
<pre><code class="lang-gradle">implementation 'org.slf4j:slf4j-jdk14:1.7.25'
</code></pre>
<p>如果未在依赖项中配置日志记录，SLF4J 将加载默认的非操作记录器，并提供以下警告消息：</p>
<pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>可以安全地忽略此情况。</p>
<h3 id="configure-allowed-transports">配置允许的传输</h3>
<p>使用的传输 SignalR 可在 <code>WithUrl</code> JavaScript) 的调用 (中进行配置 <code>withUrl</code> 。 的值的按位 &quot;或&quot; <code>HttpTransportType</code> 可用于将客户端限制为仅使用指定的传输。 默认情况下，将启用所有传输。</p>
<p>例如，禁用 Server-Sent 事件传输，但允许 Websocket 和长轮询连接：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, HttpTransportType.WebSockets | HttpTransportType.LongPolling)
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>transport</code> 在提供的选项对象上设置字段来配置传输 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling })
    .build();
</code></pre>
<h3 id="configure-bearer-authentication">配置持有者身份验证</h3>
<p>若要与请求一起提供身份验证数据 SignalR ，请使用 <code>AccessTokenProvider</code> <code>accessTokenFactory</code> JavaScript) 中 (选项来指定返回所需访问令牌的函数。 在 .NET 客户端中，此访问令牌作为 HTTP &quot;持有者身份验证&quot; 令牌传入 (使用 <code>Authorization</code>) 类型的标头 <code>Bearer</code> 。 在 JavaScript 客户端中，访问令牌用作持有者令牌， <strong>但</strong> 在某些情况下，浏览器 api 会限制在 Server-Sent 事件和 websocket 请求)  (具体应用标头的能力。 在这些情况下，访问令牌作为查询字符串值提供 <code>access_token</code> 。</p>
<p>在 .NET 客户端中， <code>AccessTokenProvider</code> 可使用中的选项委托指定选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.AccessTokenProvider = async () =&gt; {
            // Get and return the access token.
        };
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，通过 <code>accessTokenFactory</code> 在中设置 &quot;选项&quot; 对象上的字段来配置访问令牌 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        accessTokenFactory: () =&gt; {
            // Get and return the access token.
            // This function can return a JavaScript Promise if asynchronous
            // logic is required to retrieve the access token.
        }
    })
    .build();
</code></pre>
<p>在 SignalR Java 客户端中，可以通过向 <a href="/java/api/com.microsoft.signalr._http_hub_connection_builder?view=aspnet-signalr-java">HttpHubConnectionBuilder</a>提供访问令牌工厂来配置用于身份验证的持有者令牌。 使用<a href="/java/api/com.microsoft.signalr._http_hub_connection_builder.withaccesstokenprovider?view=aspnet-signalr-java#com_microsoft_signalr__http_hub_connection_builder_withAccessTokenProvider_Single_String__">withAccessTokenFactory</a>提供<a href="https://github.com/ReactiveX/RxJava">RxJava</a> <a href="https://reactivex.io/documentation/single.html">Single &lt;String&gt; </a>。 如果调用了 <a href="https://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#defer-java.util.concurrent.Callable-">单延迟</a>，你可以编写逻辑来为客户端生成访问令牌。</p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
    .withAccessTokenProvider(Single.defer(() -&gt; {
        // Your logic here.
        return Single.just(&quot;An Access Token&quot;);
    })).build();
</code></pre>
<h3 id="configure-timeout-and-keep-alive-options">配置超时和 keep-alive 选项</h3>
<p>用于配置超时和保持活动状态的其他选项可用于 <code>HubConnection</code> 对象本身：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-8">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-8_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>HandshakeTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并 <code>Closed</code> <code>onclose</code> 在 JavaScript) 中触发事件 (。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
</tbody>
</table>
<p>在 .NET 客户端中，超时值指定为 <code>TimeSpan</code> 值。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-8_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>serverTimeoutInMilliseconds</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onclose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-8_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getServerTimeout</code> / <code>setServerTimeout</code></td>
<td>30秒 (30000 毫秒)</td>
<td>服务器活动超时。 如果服务器未在此时间间隔内发送消息，则客户端会将服务器视为断开连接，并触发 <code>onClose</code> 事件。 此值必须足够大，以便从服务器发送 ping 消息 <strong>，并</strong> 在超时间隔内由客户端接收该消息。 建议值至少为服务器值的两倍 <code>KeepAliveInterval</code> ，以允许 ping 到达的时间。</td>
</tr>
<tr>
<td><code>withHandshakeResponseTimeout</code></td>
<td>15 秒</td>
<td>初始服务器握手的超时时间。 如果服务器在此时间间隔内未发送握手响应，则客户端将取消握手，并触发 <code>onClose</code> 事件。 这是一种高级设置，只应在握手超时错误由于严重网络延迟而发生时进行修改。 有关握手过程的详细信息，请参阅<a href="https://github.com/aspnet/SignalR/blob/master/specs/HubProtocol.md"> SignalR 集线器协议规范</a>。</td>
</tr>
</tbody>
</table>
</section>
</div>
<h3 id="configure-additional-options">配置其他选项</h3>
<p>可以在中的 <code>WithUrl</code> <code>withUrl</code> JavaScript) 方法 (上 <code>HubConnectionBuilder</code> 或在 <code>HttpHubConnectionBuilder</code> Java 客户端中的各种配置 api 上配置其他选项：</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-9">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_dotnet" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_dotnet" data-tab="dotnet" tabindex="0" aria-selected="true">.NET</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_javascript" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_javascript" data-tab="javascript" tabindex="-1">JavaScript</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_java" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_java" data-tab="java" tabindex="-1">Java</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-9_dotnet" role="tabpanel" data-tab="dotnet">

<table>
<thead>
<tr>
<th>.NET 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>SkipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>ClientCertificates</code></td>
<td>空</td>
<td>要发送以对请求进行身份验证的 TLS 证书的集合。</td>
</tr>
<tr>
<td><code>Cookies</code></td>
<td>空</td>
<td>cookie要随每个 http 请求一起发送的 http 的集合。</td>
</tr>
<tr>
<td><code>Credentials</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的凭据。</td>
</tr>
<tr>
<td><code>CloseTimeout</code></td>
<td>5 秒</td>
<td>仅 Websocket。 客户端在关闭之后等待服务器确认关闭请求的最长时间。 如果服务器在这段时间内没有确认关闭，客户端将断开连接。</td>
</tr>
<tr>
<td><code>Headers</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
<tr>
<td><code>HttpMessageHandlerFactory</code></td>
<td><code>null</code></td>
<td>一个委托，可用于配置或替换 <code>HttpMessageHandler</code> 用于发送 HTTP 请求的。 不用于 WebSocket 连接。 此委托必须返回非 null 值，并接收默认值作为参数。 修改该默认值的设置并将其返回，或返回一个新的 <code>HttpMessageHandler</code> 实例。 <strong>当替换处理程序时，请确保从提供的处理程序复制您要保留的设置，否则，所配置的选项 (如 Cookie s 和标头) 将不会应用于新的处理程序。</strong></td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td><code>null</code></td>
<td>发送 HTTP 请求时要使用的 HTTP 代理。</td>
</tr>
<tr>
<td><code>UseDefaultCredentials</code></td>
<td><code>false</code></td>
<td>设置此布尔值可发送 HTTP 和 Websocket 请求的默认凭据。 这样就可以使用 Windows 身份验证。</td>
</tr>
<tr>
<td><code>WebSocketConfiguration</code></td>
<td><code>null</code></td>
<td>可用于配置其他 WebSocket 选项的委托。 接收可用于配置选项的 <a href="/dotnet/api/system.net.websockets.clientwebsocketoptions">ClientWebSocketOptions</a> 实例。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-9_javascript" role="tabpanel" data-tab="javascript" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>JavaScript 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accessTokenFactory</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>transport</code></td>
<td><code>null</code></td>
<td>一个 &lt;xref:Microsoft.AspNetCore.Http.Connections.HttpTransportType&gt; 值，该值指定用于连接的传输。</td>
</tr>
<tr>
<td><code>logMessageContent</code></td>
<td><code>null</code></td>
<td>设置为 <code>true</code> 可记录客户端发送和接收的消息的字节数/字符数。</td>
</tr>
<tr>
<td><code>skipNegotiation</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
</tbody>
</table>
</section>
<section id="tabpanel_CeZOj-G++Q-9_java" role="tabpanel" data-tab="java" aria-hidden="true" hidden="hidden">

<table>
<thead>
<tr>
<th>Java 选项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>withAccessTokenProvider</code></td>
<td><code>null</code></td>
<td>一个函数，它返回作为 HTTP 请求中的持有者身份验证令牌提供的字符串。</td>
</tr>
<tr>
<td><code>shouldSkipNegotiate</code></td>
<td><code>false</code></td>
<td>将此设置为 <code>true</code> 以跳过协商步骤。 <strong>仅当 websocket 传输为唯一启用的传输时才受支持</strong> 。 使用 Azure 服务时，无法启用此设置 SignalR 。</td>
</tr>
<tr>
<td><code>withHeader</code> <code>withHeaders</code></td>
<td>空</td>
<td>要随每个 HTTP 请求一起发送的附加 HTTP 标头的映射。</td>
</tr>
</tbody>
</table>
</section>
</div>

<p>在 .NET 客户端中，可以通过提供给的 options 委托来修改这些选项 <code>WithUrl</code> ：</p>
<pre><code class="lang-csharp">var connection = new HubConnectionBuilder()
    .WithUrl(&quot;https://example.com/chathub&quot;, options =&gt; {
        options.Headers[&quot;Foo&quot;] = &quot;Bar&quot;;
        options.Cookies.Add(new Cookie(/* ... */);
        options.ClientCertificates.Add(/* ... */);
    })
    .Build();
</code></pre>
<p>在 JavaScript 客户端中，可以在提供给的 JavaScript 对象中提供这些选项 <code>withUrl</code> ：</p>
<pre><code class="lang-javascript">let connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;, {
        skipNegotiation: true,
        transport: signalR.HttpTransportType.WebSockets
    })
    .build();
</code></pre>
<p>在 Java 客户端中，这些选项可以在 <code>HttpHubConnectionBuilder</code> 从 <code>HubConnectionBuilder.create(&quot;HUB URL&quot;)</code></p>
<pre><code class="lang-java">HubConnection hubConnection = HubConnectionBuilder.create(&quot;https://example.com/chathub&quot;)
        .withHeader(&quot;Foo&quot;, &quot;Bar&quot;)
        .shouldSkipNegotiate(true)
        .withHandshakeResponseTimeout(30*1000)
        .build();
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../tutorials/signalr.html">ASP.NET Core SignalR 入门</a></li>
<li><a class="xref" href="hubs.html">在 ASP.NET Core 中使用中心 SignalR</a></li>
<li><a class="xref" href="javascript-client.html">ASP.NET Core SignalR JavaScript 客户端</a></li>
<li><a class="xref" href="dotnet-client.html">ASP.NET Core SignalR .Net 客户端</a></li>
<li><a class="xref" href="messagepackhubprotocol.html">使用中的 MessagePack Hub 协议 SignalR 进行 ASP.NET Core</a></li>
<li><a class="xref" href="supported-platforms.html">ASP.NET Core SignalR 支持的平台</a></li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
