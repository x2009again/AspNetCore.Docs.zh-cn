<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core SignalR JavaScript &#23458;&#25143;&#31471; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core SignalR JavaScript &#23458;&#25143;&#31471; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="signalr/javascript-client">
<h1 id="aspnet-core-no-locsignalr-javascript-client">ASP.NET Core SignalR JavaScript 客户端</h1>

<div range="&gt;= aspnetcore-3.0">
<p>作者：<a href="https://twitter.com/rachelappel">Rachel Appel</a></p>
<p>ASP.NET Core SignalR JavaScript 客户端库使开发人员能够调用服务器端集线器代码。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/signalr/javascript-client/samples">查看或下载示例代码</a>（<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="install-the-no-locsignalr-client-package">安装 SignalR 客户端包</h2>
<p>SignalRJavaScript 客户端库以<a href="https://www.npmjs.com/">npm</a>包的形式提供。 以下部分概述了安装客户端库的不同方式。</p>
<h3 id="install-with-npm">通过 npm 安装</h3>
<p>对于 Visual Studio，请在根文件夹中的 &quot; <strong>包管理器控制台</strong> &quot; 中运行以下命令。 对于 Visual Studio Code，请从 <strong>集成终端</strong> 运行以下命令。</p>
<pre><code class="lang-bash">npm init -y
npm install @microsoft/signalr
</code></pre>
<p>npm 将包内容安装到 *node_modules \ @microsoft\signalr\dist\browser* 文件夹中。 在 <em>wwwroot \ lib</em> 文件夹下创建名为 <em>signalr</em> 的新文件夹。 将 <em>signalr.js</em> 文件复制到 <em>wwwroot\lib\signalr</em> 文件夹。</p>
<p>SignalR在元素中引用 JavaScript 客户端 <code>&lt;script&gt;</code> 。 例如： 。</p>
<pre><code class="lang-html">&lt;script src=&quot;~/lib/signalr/signalr.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="use-a-content-delivery-network-cdn">使用内容交付网络 (CDN)</h3>
<p>若要在不使用 npm 先决条件的情况下使用客户端库，请引用 CDN 托管的客户端库副本。 例如： 。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下 Cdn 提供了客户端库：</p>
<ul>
<li><a href="https://cdnjs.com/libraries/microsoft-signalr">cdnjs</a></li>
<li><a href="https://www.jsdelivr.com/package/npm/@microsoft/signalr">jsDelivr</a></li>
<li><a href="https://unpkg.com/@microsoft/signalr@next/dist/browser/signalr.min.js">unpkg</a></li>
</ul>
<h3 id="install-with-libman">通过 LibMan 安装</h3>
<p><a class="xref" href="../client-side/libman/index.html">LibMan</a> 可用于从 CDN 托管的客户端库安装特定的客户端库文件。 例如，仅将缩小 JavaScript 文件添加到项目。 有关该方法的详细信息，请参阅 <a class="xref" href="../tutorials/signalr.html#add-the-signalr-client-library">添加 SignalR 客户端库</a>。</p>
<h2 id="connect-to-a-hub">连接到集线器</h2>
<p>下面的代码创建并启动连接。 中心名称不区分大小写：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="cross-origin-connections">跨域连接</h3>
<p>通常，浏览器从与请求的页相同的域中加载连接。 但是，在某些情况下，需要与另一个域建立连接。</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>客户端代码必须使用绝对 URL，而不是相对 URL。 将 <code>.withUrl(&quot;/chathub&quot;)</code> 更改为 <code>.withUrl(&quot;https://myappurl/chathub&quot;)</code>。</p>
</div>
<p>为了防止恶意站点读取其他站点中的敏感数据，默认情况下会禁用 <a class="xref" href="../security/cors.html">跨域连接</a> 。 若要允许跨源请求，请在类中启用该请求 <code>Startup</code> ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="call-hub-methods-from-the-client">从客户端调用中心方法</h2>
<p>JavaScript 客户端通过<a href="/javascript/api/%40microsoft/signalr/hubconnection">HubConnection</a>的<a href="/javascript/api/%40microsoft/signalr/hubconnection#invoke-string--any---">invoke</a>方法在集线器上调用公共方法。 此 <code>invoke</code> 方法接受：</p>
<ul>
<li>集线器方法的名称。</li>
<li>在 hub 方法中定义的所有参数。</li>
</ul>
<p>在下面的示例中，中心的方法名称是 <code>SendMessage</code> 。 传递给 <code>invoke</code> 集线器方法和参数的第二个和第三个参数 <code>user</code> <code>message</code> ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>仅 SignalR 在 <em>默认</em> 模式下使用 Azure 服务时，才支持从客户端调用中心方法。 有关详细信息，请参阅 <a href="https://github.com/Azure/azure-signalr/blob/dev/docs/faq.md#what-is-the-meaning-of-service-mode-defaultserverlessclassic-how-can-i-choose">Signalr GitHub 存储库)  (常见问题解答 </a>。</p>
</div>
<p><code>invoke</code>方法返回 JavaScript<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise">承诺</a>。 <code>Promise</code>当服务器上的方法返回时，将用返回值解析)  (。 如果服务器上的方法引发错误，将拒绝， <code>Promise</code> 并出现错误消息。 使用 <code>async</code> 和 <code>await</code> 或的 <code>Promise</code> <code>then</code> 和 <code>catch</code> 方法来处理这些情况。</p>
<p>JavaScript 客户端也可以通过的 <a href="/javascript/api/%40microsoft/signalr/hubconnection#send-string--any---">send</a> 方法在集线器上调用公共方法 <code>HubConnection</code> 。 与 <code>invoke</code> 方法不同， <code>send</code> 方法不会等待服务器的响应。 <code>send</code>方法返回 JavaScript <code>Promise</code> 。 <code>Promise</code>当消息已发送到服务器时，将解决。 如果发送消息时出错，将 <code>Promise</code> 拒绝，并出现错误消息。 使用 <code>async</code> 和 <code>await</code> 或的 <code>Promise</code> <code>then</code> 和 <code>catch</code> 方法来处理这些情况。</p>
<div class="NOTE">
<h5>Note</h5>
<p>使用 <code>send</code> 不会等到服务器收到消息。 因此，不可能从服务器返回数据或错误。</p>
</div>
<h2 id="call-client-methods-from-the-hub">从中心调用客户端方法</h2>
<p>若要从中心接收消息，请使用的 <a href="/javascript/api/%40microsoft/signalr/hubconnection#on-string---args--any-------void-">on</a> 方法定义方法 <code>HubConnection</code> 。</p>
<ul>
<li>JavaScript 客户端方法的名称。</li>
<li>集线器传递给方法的参数。</li>
</ul>
<p>在下面的示例中，方法名称是 <code>ReceiveMessage</code> 。 参数名称为 <code>user</code> 和 <code>message</code> ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>connection.on</code>当服务器端代码使用方法调用时，上面的代码会运行 &lt;xref:Microsoft.AspNetCore.SignalR.ClientProxyExtensions.SendAsync%2A&gt; ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>SignalR 通过匹配和中定义的方法名称和参数，确定要调用的客户端方法 <code>SendAsync</code> <code>connection.on</code> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>作为最佳做法，请在后面调用 <a href="/javascript/api/%40aspnet/signalr/hubconnection#start">start</a> 方法 <code>HubConnection</code> <code>on</code> 。 这样做可确保在收到消息之前注册处理程序。</p>
</div>
<h2 id="error-handling-and-logging">错误处理和日志记录</h2>
<p>使用和，使用 <code>try</code> <code>catch</code> <code>async</code> 和 <code>await</code> 或 <code>Promise</code> 的 <code>catch</code> 方法来处理客户端错误。 使用 <code>console.error</code> 将错误输出到浏览器控制台：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>设置客户端日志跟踪，方法是在建立连接时将记录器和事件类型传递给日志。 记录的消息具有指定的日志级别和更高的日志级别。 可用的日志级别如下所示：</p>
<ul>
<li><code>signalR.LogLevel.Error</code>：错误消息。 <code>Error</code>仅记录消息。</li>
<li><code>signalR.LogLevel.Warning</code>：有关潜在错误的警告消息。 日志 <code>Warning</code> 和 <code>Error</code> 消息。</li>
<li><code>signalR.LogLevel.Information</code>：无错误的状态消息。 日志 <code>Information</code> 、 <code>Warning</code> 和 <code>Error</code> 消息。</li>
<li><code>signalR.LogLevel.Trace</code>：跟踪消息。 记录所有内容，包括中心和客户端之间传输的数据。</li>
</ul>
<p>使用<a href="/javascript/api/%40aspnet/signalr/hubconnectionbuilder">HubConnectionBuilder</a>上的<a href="/javascript/api/%40aspnet/signalr/hubconnectionbuilder#configurelogging">configureLogging</a>方法配置日志级别。 消息记录到浏览器控制台：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="reconnect-clients">重新连接客户端</h2>
<h3 id="automatically-reconnect">自动重新连接</h3>
<p>的 JavaScript 客户端 SignalR 可以配置为使用 <code>withAutomaticReconnect</code> <a href="/javascript/api/%40aspnet/signalr/hubconnectionbuilder">HubConnectionBuilder</a>上的方法自动重新连接。 默认情况下，它不会自动重新连接。</p>
<pre><code class="lang-javascript">const connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .withAutomaticReconnect()
    .build();
</code></pre>
<p>在没有任何参数的情况下，会 <code>withAutomaticReconnect()</code> 将客户端配置为分别等待0、2、10和30秒，然后再尝试重新连接尝试。</p>
<p>在开始任何重新连接尝试之前， <code>HubConnection</code> 将转换为 <code>HubConnectionState.Reconnecting</code> 状态，并激发其 <code>onreconnecting</code> 回调，而不是转换为 <code>Disconnected</code> 状态，并触发其 <code>onclose</code> 回调，如 <code>HubConnection</code> 不配置自动重新连接。 这为用户提供警告连接已丢失并禁用 UI 元素的机会。</p>
<pre><code class="lang-javascript">connection.onreconnecting(error =&gt; {
    console.assert(connection.state === signalR.HubConnectionState.Reconnecting);

    document.getElementById(&quot;messageInput&quot;).disabled = true;

    const li = document.createElement(&quot;li&quot;);
    li.textContent = `Connection lost due to error &quot;${error}&quot;. Reconnecting.`;
    document.getElementById(&quot;messagesList&quot;).appendChild(li);
});
</code></pre>
<p>如果客户端在其前四次尝试内成功重新连接，则 <code>HubConnection</code> 将转换回 <code>Connected</code> 状态并激发其 <code>onreconnected</code> 回调。 这为用户提供了通知用户连接已重新建立的机会。</p>
<p>由于连接在服务器上看起来是全新的，因此 <code>connectionId</code> 将向回调提供一个新的 <code>onreconnected</code> 。</p>
<div class="WARNING">
<h5>Warning</h5>
<p><code>onreconnected</code> <code>connectionId</code> 如果 <code>HubConnection</code> 配置为<a class="xref" href="configuration.html#configure-client-options">跳过协商</a>，则不会定义回调的参数。</p>
</div>
<pre><code class="lang-javascript">connection.onreconnected(connectionId =&gt; {
    console.assert(connection.state === signalR.HubConnectionState.Connected);

    document.getElementById(&quot;messageInput&quot;).disabled = false;

    const li = document.createElement(&quot;li&quot;);
    li.textContent = `Connection reestablished. Connected with connectionId &quot;${connectionId}&quot;.`;
    document.getElementById(&quot;messagesList&quot;).appendChild(li);
});
</code></pre>
<p><code>withAutomaticReconnect()</code> 不会将配置 <code>HubConnection</code> 为重试初始启动失败，因此，需要手动处理启动失败：</p>
<pre><code class="lang-javascript">async function start() {
    try {
        await connection.start();
        console.assert(connection.state === signalR.HubConnectionState.Connected);
        console.log(&quot;SignalR Connected.&quot;);
    } catch (err) {
        console.assert(connection.state === signalR.HubConnectionState.Disconnected);
        console.log(err);
        setTimeout(() =&gt; start(), 5000);
    }
};
</code></pre>
<p>如果客户端在其前四次尝试中未成功重新连接，则 <code>HubConnection</code> 将转换为 <code>Disconnected</code> 状态并激发其 <a href="/javascript/api/%40aspnet/signalr/hubconnection#onclose">onclose</a> 回调。 这为用户提供了通知用户连接永久丢失的机会，并建议刷新页面：</p>
<pre><code class="lang-javascript">connection.onclose(error =&gt; {
    console.assert(connection.state === signalR.HubConnectionState.Disconnected);

    document.getElementById(&quot;messageInput&quot;).disabled = true;

    const li = document.createElement(&quot;li&quot;);
    li.textContent = `Connection closed due to error &quot;${error}&quot;. Try refreshing this page to restart the connection.`;
    document.getElementById(&quot;messagesList&quot;).appendChild(li);
});
</code></pre>
<p>若要在断开连接或更改重新连接时间安排之前配置自定义的重新连接尝试次数，请 <code>withAutomaticReconnect</code> 接受一个数字数组，表示在开始每次重新连接尝试之前等待的延迟（以毫秒为单位）。</p>
<pre><code class="lang-javascript">const connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .withAutomaticReconnect([0, 0, 10000])
    .build();

    // .withAutomaticReconnect([0, 2000, 10000, 30000]) yields the default behavior
</code></pre>
<p>前面的示例将配置 <code>HubConnection</code> 为在连接丢失后立即开始尝试重新连接。 这也适用于默认配置。</p>
<p>如果第一次重新连接尝试失败，则第二次重新连接尝试还会立即启动，而不是等待2秒，就像在默认配置中一样。</p>
<p>如果第二次重新连接尝试失败，则第三次重新连接尝试将在10秒内启动，这与默认配置相同。</p>
<p>然后，在第三次重新连接尝试失败后，自定义行为将再次从默认行为与其分离，而不是在另一个30秒内尝试再次尝试重新连接，就像在默认配置中一样。</p>
<p>如果需要更好地控制计时和自动重新连接尝试的次数，则 <code>withAutomaticReconnect</code> 接受一个实现接口的 <code>IRetryPolicy</code> 对象，该对象具有一个名为的方法 <code>nextRetryDelayInMilliseconds</code> 。</p>
<p><code>nextRetryDelayInMilliseconds</code> 采用类型为的单个自变量 <code>RetryContext</code> 。 <code>RetryContext</code>具有三个属性： <code>previousRetryCount</code> <code>elapsedMilliseconds</code> 和分别为 <code>retryReason</code> <code>number</code> 、 <code>number</code> 和 <code>Error</code> 。 第一次重新连接尝试之前， <code>previousRetryCount</code> 和都 <code>elapsedMilliseconds</code> 是零， <code>retryReason</code> 将是导致连接丢失的错误。 每次失败的重试次数递增一次后，将进行 <code>previousRetryCount</code> <code>elapsedMilliseconds</code> 更新，以反映到目前为止的重新连接所用的时间（以毫秒为单位），并且 <code>retryReason</code> 将是导致上次重新连接尝试失败的错误。</p>
<p><code>nextRetryDelayInMilliseconds</code> 必须返回一个数字，该数字表示在下一次重新连接尝试之前要等待的毫秒数，或者 <code>null</code> ，如果应停止重新连接，则为 <code>HubConnection</code> 。</p>
<pre><code class="lang-javascript">const connection = new signalR.HubConnectionBuilder()
    .withUrl(&quot;/chathub&quot;)
    .withAutomaticReconnect({
        nextRetryDelayInMilliseconds: retryContext =&gt; {
            if (retryContext.elapsedMilliseconds &lt; 60000) {
                // If we've been reconnecting for less than 60 seconds so far,
                // wait between 0 and 10 seconds before the next reconnect attempt.
                return Math.random() * 10000;
            } else {
                // If we've been reconnecting for more than 60 seconds so far, stop reconnecting.
                return null;
            }
        }
    })
    .build();
</code></pre>
<p>或者，你可以编写将手动重新连接客户端的代码，如 <a href="#manually-reconnect">手动重新连接</a>中所示。</p>
<h3 id="manually-reconnect">手动重新连接</h3>
<p>下面的代码演示典型的手动重新连接方法：</p>
<ol>
<li>函数 (在这种情况下，将 <code>start</code> 创建函数) 来启动连接。</li>
<li><code>start</code>在连接的 <code>onclose</code> 事件处理程序中调用函数。</li>
</ol>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>实际的实现将使用指数回退或在放弃之前重试指定的次数。</p>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a href="/javascript/api/?view=signalr-js-latest&amp;preserve-view=true">JavaScript API 参考</a></li>
<li><a class="xref" href="../tutorials/signalr.html">JavaScript 教程</a></li>
<li><a class="xref" href="../tutorials/signalr-typescript-webpack.html">WebPack 和 TypeScript 教程</a></li>
<li><a class="xref" href="hubs.html">中心</a></li>
<li><a class="xref" href="dotnet-client.html">.NET 客户端</a></li>
<li><a class="xref" href="publish-to-azure-web-app.html">发布到 Azure</a></li>
<li><a class="xref" href="../security/cors.html"> (CORS 的跨源请求) </a></li>
<li><a href="/azure/azure-signalr/signalr-concept-serverless-development-config">Azure SignalR Service 无服务器文档</a></li>
<li><a class="xref" href="troubleshoot.html">排查连接错误</a></li>
</ul>
</div>
<div range="&lt; aspnetcore-3.0">
<p>作者：<a href="https://twitter.com/rachelappel">Rachel Appel</a></p>
<p>ASP.NET Core SignalR JavaScript 客户端库使开发人员能够调用服务器端集线器代码。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/signalr/javascript-client/samples">查看或下载示例代码</a>（<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="install-the-no-locsignalr-client-package">安装 SignalR 客户端包</h2>
<p>SignalRJavaScript 客户端库以<a href="https://www.npmjs.com/">npm</a>包的形式提供。 以下部分概述了安装客户端库的不同方式。</p>
<h3 id="install-with-npm">通过 npm 安装</h3>
<p>如果使用的是 Visual Studio，请在根文件夹中的 &quot; <strong>包管理器控制台</strong> &quot; 中运行以下命令。 对于 Visual Studio Code，请从 <strong>集成终端</strong> 运行以下命令。</p>
<pre><code class="lang-bash">npm init -y
npm install @aspnet/signalr
</code></pre>
<p>npm 将包内容安装到 *node_modules \ @aspnet\signalr\dist\browser* 文件夹中。 在 <em>wwwroot \ lib</em> 文件夹下创建名为 <em>signalr</em> 的新文件夹。 将 <em>signalr.js</em> 文件复制到 <em>wwwroot\lib\signalr</em> 文件夹。</p>
<p>SignalR在元素中引用 JavaScript 客户端 <code>&lt;script&gt;</code> 。 例如： 。</p>
<pre><code class="lang-html">&lt;script src=&quot;~/lib/signalr/signalr.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="use-a-content-delivery-network-cdn">使用内容交付网络 (CDN)</h3>
<p>若要在不使用 npm 先决条件的情况下使用客户端库，请引用 CDN 托管的客户端库副本。 例如： 。</p>
<pre><code class="lang-html">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/3.1.3/signalr.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>以下 Cdn 提供了客户端库：</p>
<ul>
<li><a href="https://cdnjs.com/libraries/aspnet-signalr">cdnjs</a></li>
<li><a href="https://www.jsdelivr.com/package/npm/@aspnet/signalr">jsDelivr</a></li>
<li><a href="https://unpkg.com/@aspnet/signalr@next/dist/browser/signalr.min.js">unpkg</a></li>
</ul>
<h3 id="install-with-libman">通过 LibMan 安装</h3>
<p><a class="xref" href="../client-side/libman/index.html">LibMan</a> 可用于从 CDN 托管的客户端库安装特定的客户端库文件。 例如，仅将缩小 JavaScript 文件添加到项目。 有关该方法的详细信息，请参阅 <a class="xref" href="../tutorials/signalr.html#add-the-signalr-client-library">添加 SignalR 客户端库</a>。</p>
<h2 id="connect-to-a-hub">连接到集线器</h2>
<p>下面的代码创建并启动连接。 中心名称不区分大小写。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="cross-origin-connections">跨域连接</h3>
<p>通常，浏览器从与请求的页相同的域中加载连接。 但是，在某些情况下，需要与另一个域建立连接。</p>
<p>为了防止恶意站点读取其他站点中的敏感数据，默认情况下会禁用 <a class="xref" href="../security/cors.html">跨域连接</a> 。 若要允许跨源请求，请在类中启用它 <code>Startup</code> 。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="call-hub-methods-from-client">从客户端调用集线器方法</h2>
<p>JavaScript 客户端通过<a href="/javascript/api/%40aspnet/signalr/hubconnection">HubConnection</a>的<a href="/javascript/api/%40aspnet/signalr/hubconnection#invoke">invoke</a>方法在集线器上调用公共方法。 此 <code>invoke</code> 方法接受两个参数：</p>
<ul>
<li><p>集线器方法的名称。 在下面的示例中，中心的方法名称是 <code>SendMessage</code> 。</p>
</li>
<li><p>在 hub 方法中定义的所有参数。 在下面的示例中，自变量名称为 <code>message</code> 。 示例代码使用了在所有主要浏览器（Internet Explorer 除外）的当前版本中受支持的箭头函数语法。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>仅 SignalR 在 <em>默认</em> 模式下使用 Azure 服务时，才支持从客户端调用中心方法。 有关详细信息，请参阅 <a href="https://github.com/Azure/azure-signalr/blob/dev/docs/faq.md#what-is-the-meaning-of-service-mode-defaultserverlessclassic-how-can-i-choose">Signalr GitHub 存储库)  (常见问题解答 </a>。</p>
</div>
<p><code>invoke</code>方法返回 JavaScript<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise">承诺</a>。 <code>Promise</code>当服务器上的方法返回时，将用返回值解析)  (。 如果服务器上的方法引发错误，将拒绝， <code>Promise</code> 并出现错误消息。 使用 <code>then</code> 和 <code>catch</code> 方法 <code>Promise</code> 来处理这些事例 (或 <code>await</code> 语法) 。</p>
<p><code>send</code>方法返回 JavaScript <code>Promise</code> 。 <code>Promise</code>当消息已发送到服务器时，将解决。 如果发送消息时出错，将 <code>Promise</code> 拒绝，并出现错误消息。 使用 <code>then</code> 和 <code>catch</code> 方法 <code>Promise</code> 来处理这些事例 (或 <code>await</code> 语法) 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>使用 <code>send</code> 不会等到服务器收到消息。 因此，不可能从服务器返回数据或错误。</p>
</div>
<h2 id="call-client-methods-from-hub">从中心调用客户端方法</h2>
<p>若要从中心接收消息，请使用的 <a href="/javascript/api/%40aspnet/signalr/hubconnection#on">on</a> 方法定义方法 <code>HubConnection</code> 。</p>
<ul>
<li>JavaScript 客户端方法的名称。 在下面的示例中，方法名称是 <code>ReceiveMessage</code> 。</li>
<li>集线器传递给方法的参数。 在下面的示例中，参数值为 <code>message</code> 。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>connection.on</code>当服务器端代码使用方法调用时，上面的代码将运行 &lt;xref:Microsoft.AspNetCore.SignalR.ClientProxyExtensions.SendAsync%2A&gt; 。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>SignalR 通过匹配和中定义的方法名称和参数，确定要调用的客户端方法 <code>SendAsync</code> <code>connection.on</code> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p>作为最佳做法，请在后面调用 <a href="/javascript/api/%40aspnet/signalr/hubconnection#start">start</a> 方法 <code>HubConnection</code> <code>on</code> 。 这样做可确保在收到消息之前注册处理程序。</p>
</div>
<h2 id="error-handling-and-logging">错误处理和日志记录</h2>
<p>将 <code>catch</code> 方法链接到方法的末尾 <code>start</code> ，以处理客户端错误。 使用 <code>console.error</code> 将错误输出到浏览器控制台。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>设置客户端日志跟踪，方法是在建立连接时将记录器和事件类型传递给日志。 记录的消息具有指定的日志级别和更高的日志级别。 可用的日志级别如下所示：</p>
<ul>
<li><code>signalR.LogLevel.Error</code>：错误消息。 <code>Error</code>仅记录消息。</li>
<li><code>signalR.LogLevel.Warning</code>：有关潜在错误的警告消息。 日志 <code>Warning</code> 和 <code>Error</code> 消息。</li>
<li><code>signalR.LogLevel.Information</code>：无错误的状态消息。 日志 <code>Information</code> 、 <code>Warning</code> 和 <code>Error</code> 消息。</li>
<li><code>signalR.LogLevel.Trace</code>：跟踪消息。 记录所有内容，包括中心和客户端之间传输的数据。</li>
</ul>
<p>使用<a href="/javascript/api/%40aspnet/signalr/hubconnectionbuilder">HubConnectionBuilder</a>上的<a href="/javascript/api/%40aspnet/signalr/hubconnectionbuilder#configurelogging">configureLogging</a>方法配置日志级别。 消息将记录到浏览器控制台。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="reconnect-clients">重新连接客户端</h2>
<h3 id="manually-reconnect">手动重新连接</h3>
<div class="WARNING">
<h5>Warning</h5>
<p>在3.0 之前， SignalR 不会自动重新连接 JavaScript 客户端。 必须编写代码来手动重新连接客户端。</p>
</div>
<p>下面的代码演示典型的手动重新连接方法：</p>
<ol>
<li>函数 (在这种情况下，将 <code>start</code> 创建函数) 来启动连接。</li>
<li><code>start</code>在连接的 <code>onclose</code> 事件处理程序中调用函数。</li>
</ol>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>实际的实现将使用指数回退或在放弃之前重试指定的次数。</p>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a href="/javascript/api/?view=signalr-js-latest">JavaScript API 参考</a></li>
<li><a class="xref" href="../tutorials/signalr.html">JavaScript 教程</a></li>
<li><a class="xref" href="../tutorials/signalr-typescript-webpack.html">WebPack 和 TypeScript 教程</a></li>
<li><a class="xref" href="hubs.html">中心</a></li>
<li><a class="xref" href="dotnet-client.html">.NET 客户端</a></li>
<li><a class="xref" href="publish-to-azure-web-app.html">发布到 Azure</a></li>
<li><a class="xref" href="../security/cors.html"> (CORS 的跨源请求) </a></li>
<li><a href="/azure/azure-signalr/signalr-concept-serverless-development-config">Azure SignalR Service 无服务器文档</a></li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
