<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#25945;&#31243;&#65306;&#20351;&#29992; ASP.NET Core &#21019;&#24314; Web API </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#25945;&#31243;&#65306;&#20351;&#29992; ASP.NET Core &#21019;&#24314; Web API ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="tutorials/first-web-api">
<h1 id="tutorial-create-a-web-api-with-aspnet-core">教程：使用 ASP.NET Core 创建 Web API</h1>

<p>作者：<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://twitter.com/serpent5">Kirk Larkin</a> 和 <a href="https://github.com/mikewasson">Mike Wasson</a></p>
<p>本教程介绍使用 ASP.NET Core 构建 Web API 的基础知识。</p>
<div range="&gt;= aspnetcore-5.0">
<p>在本教程中，你将了解：</p>
<div class="checklist">
<ul>
<li>创建 Web API 项目。</li>
<li>添加模型类和数据库上下文。</li>
<li>使用 CRUD 方法构建控制器。</li>
<li>配置路由、URL 路径和返回值。</li>
<li>使用 Postman 调用 Web API。</li>
</ul>
</div>
<p>在结束时，你会获得可以管理存储在数据库中的“待办事项”的 Web API。</p>
<h2 id="overview">概述</h2>
<p>本教程将创建以下 API：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
<th>请求正文</th>
<th>响应正文</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET /api/TodoItems</code></td>
<td>获取所有待办事项</td>
<td>None</td>
<td>待办事项的数组</td>
</tr>
<tr>
<td><code>GET /api/TodoItems/{id}</code></td>
<td>按 ID 获取项</td>
<td>None</td>
<td>待办事项</td>
</tr>
<tr>
<td><code>POST /api/TodoItems</code></td>
<td>添加新项</td>
<td>待办事项</td>
<td>待办事项</td>
</tr>
<tr>
<td><code>PUT /api/TodoItems/{id}</code></td>
<td>更新现有项  </td>
<td>待办事项</td>
<td>None</td>
</tr>
<tr>
<td><code>DELETE /api/TodoItems/{id}</code>    </td>
<td>删除项   </td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>下图显示了应用的设计。</p>
<p><img src="first-web-api/_static/architecture.png" alt="右侧的框表示客户端。 它提交请求并从应用程序接收响应，如右侧的框所示。 在应用程序框内，三个框分别代表控制器、模型和数据访问层。 请求进入应用程序的控制器，读/写操作是在控制器和数据访问层之间进行的。 模型被序列化并在响应中被返回给客户端。"></p>
<h2 id="prerequisites">先决条件</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q_visual-studio" role="tabpanel" data-tab="visual-studio">
<ul>
<li>具有<strong>ASP.NET 和 web 开发</strong>工作负荷的<a href="https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019">Visual Studio 2019 16.8 或更高版本</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet/5.0">.NET 5.0 SDK 或更高版本</a></p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">用于 Visual Studio Code 的 C#（最新版本）</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet/5.0">.NET 5.0 SDK 或更高版本</a></p>
</li>
</ul>
<p>Visual Studio Code 说明使用用于 ASP.NET Core 的 .NET Core CLI 开发功能，如项目创建。 可以在 macOS、Linux 或 Windows 上以及任何代码编辑器中遵循这些说明。 如果使用 Visual Studio Code 以外的其他内容，则可能需要进行少量更改。</p>
</section>
<section id="tabpanel_CeZOj-G++Q_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://visualstudio.microsoft.com/vs/mac/">Visual Studio for Mac 预览</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet/5.0">.NET 5.0 SDK 或更高版本</a></p>
</li>
</ul>
</section>
</div>
<h2 id="create-a-web-project">创建 Web 项目</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-1_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li>从“文件”菜单中选择“新建”&gt;“项目”  。</li>
<li>选择“ASP.NET Core Web 应用程序”模板，再单击“下一步” 。</li>
<li>将项目命名为 TodoApi，然后单击“创建”。</li>
<li>在“创建新的 ASP.NET Core Web 应用程序”对话框中，确认选择 .NET Core 和 ASP.NET Core 5.0  。 选择“API”模板，然后单击“创建” 。</li>
</ul>
<p><img src="first-web-api/_static/5/vs.png" alt="VS“新建项目”对话框"></p>
</section>
<section id="tabpanel_CeZOj-G++Q-1_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>打开<a href="https://code.visualstudio.com/docs/editor/integrated-terminal">集成终端</a>。</p>
</li>
<li><p>将目录 (<code>cd</code>) 更改为包含项目文件夹的文件夹。</p>
</li>
<li><p>运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet new webapi -o TodoApi
cd TodoApi
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.InMemory
code -r ../TodoApi
</code></pre>
</li>
<li><p>当对话框询问是否要将所需资产添加到项目时，选择“是”。</p>
<p>前面的命令：</p>
<ul>
<li>创建新的 web API 项目，并在 Visual Studio Code 中打开它。</li>
<li>添加下一部分中所需的 NuGet 包。</li>
</ul>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-1_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>选择“文件”&gt;“新建解决方案” 。</p>
<p><img src="first-web-api-mac/_static/sln.png" alt="macOS 新建解决方案"></p>
</li>
<li><p>在版本 8.6 之前的 Visual Studio for Mac 中，依次选择“.NET Core” &gt; “应用” &gt; “API” &gt; “下一步”   。 在版本 8.6 或更高版本中，依次选择“Web 和控制台” &gt; “应用” &gt; “API” &gt; “下一步”。</p>
<p><img src="first-web-api-mac/_static/api_template.png" alt="macOS API 模板选择"></p>
</li>
<li><p>在“配置新的 ASP.NET Core Web API”对话框中，选择最新的 .NET Core 3.x 目标框架 。 选择“下一步”。</p>
</li>
<li><p>输入“TodoApi”作为“项目名称”，然后选择“创建”。</p>
<p><img src="first-web-api-mac/_static/2.png" alt="配置对话框"></p>
</li>
</ul>
<h3 id="accessing-a-command-terminal-on-visual-studios-for-mac">访问 Visual studio for Mac 上的命令终端</h3>
<p>首次访问 Mac 上的命令终端需要以下设置配置：</p>
<ul>
<li>导航到“系统首选项”&gt;“键盘”&gt;“快捷方式”&gt;“服务”  。</li>
<li>在“文件和文件夹”下，验证是否选中了“文件夹中的新终端”   。</li>
</ul>
<p>上述说明以两种方式实现访问命令终端：从 Visual Studio 内访问或通过查找器访问   。</p>
<h4 id="to-access-a-command-terminal-from-visual-studio-for-mac">若要从 Visual Studio for Mac 访问命令终端，请执行以下操作：</h4>
<ul>
<li>右键单击项目名称。</li>
<li>导航到“工具”&gt;“在终端中打开”  。</li>
</ul>
<h4 id="to-access-a-command-terminal-from-finder">若要通过查找器访问命令终端，请执行以下操作：</h4>
<ul>
<li>右键单击所需文件夹。</li>
<li>在列表底部，选择“文件夹中的新终端”  。</li>
</ul>

<p>在项目文件夹中打开命令终端并运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.InMemory
</code></pre>
</section>
</div>
<h3 id="test-the-project">测试项目</h3>
<p>项目模板创建了一个支持 <a class="xref" href="web-api-help-pages-using-swagger.html">Swagger</a> 的 <code>WeatherForecast</code> API。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-2_visual-studio" role="tabpanel" data-tab="visual-studio">

<p>按 Ctrl+F5 以在不使用调试程序的情况下运行。</p>
<p>Visual Studio 会显示以下对话框：</p>
<p><img src="../getting-started/_static/trustCert.png" alt="此项目配置为使用 SSL。 要避免浏览器中出现 SSL 警告，可以选择信任 IIS Express 生成的自签名证书。 要信任 IIS Express SSL 证书吗？"></p>
<p>如果信任 IIS Express SSL 证书，请选择“是”  。</p>
<p>将显示以下对话框：</p>
<p><img src="../getting-started/_static/cert.png" alt="安全警告对话"></p>
<p>如果你同意信任开发证书，请选择“是”。</p>

<p>Visual Studio 将启动：</p>
<ul>
<li>IIS Express Web 服务器。</li>
<li>默认浏览器，并导航到 <code>https://localhost:&lt;port&gt;/https://localhost:5001/swagger/index.html</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-2_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">
<ul>
<li><p>通过运行以下命令来信任 HTTPS 开发证书：</p>
<pre><code class="lang-dotnetcli">dotnet dev-certs https --trust
</code></pre>
<p>上述命令在 Linux 上无效。 有关信任证书的详细信息，请参阅 Linux 发行版的文档。</p>
<p>以上命令会显示以下对话：</p>
<p><img src="../getting-started/_static/cert.png" alt="安全警告对话"></p>
</li>
<li><p>如果你同意信任开发证书，请选择“是”。</p>
<p>有关详细信息，请参阅<a class="xref" href="../security/enforcing-ssl.html#trust-the-aspnet-core-https-development-certificate-on-windows-and-macos">信任 ASP.NET Core HTTPS 开发证书</a>。</p>
</li>
</ul>

<p>按 Ctrl+F5 运行应用。 在浏览器中，转到以下 URL：<a href="https://localhost:5001/swagger">https://localhost:5001/swagger</a></p>
</section>
<section id="tabpanel_CeZOj-G++Q-2_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<p>选择“运行” &gt; “开始调试”以启动应用。 Visual Studio for Mac 会启动浏览器并导航到 <code>https://localhost:&lt;port&gt;</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。 将返回 HTTP 404（未找到）错误。 将 <code>/swagger</code> 追加到 URL（将 URL 更改为 <code>https://localhost:&lt;port&gt;/swagger</code>）。</p>
</section>
</div>

<p>随即显示 Swagger 页面 <code>/swagger/index.html</code>。 选择 GET  &gt; “试用” &gt; “执行”  。 页面将显示：</p>
<ul>
<li>用于测试 WeatherForecast API 的 <a href="https://curl.haxx.se/">Curl</a> 命令。</li>
<li>用于测试 WeatherForecast API 的 URL。</li>
<li>响应代码、正文和标头。</li>
<li>包含媒体类型、示例值和架构的下拉列表框。</li>
</ul>
<!-- Review: Do we care the IE generates several errors. It shows the data, but with  Unrecognized response type; displaying content as text.
-->
<p>Swagger 用于为 Web API 生成有用的文档和帮助页面。 本教程重点介绍如何创建 Web API。 有关 Swagger 的详细信息，请参阅 <a class="xref" href="web-api-help-pages-using-swagger.html">带有 Swagger/OpenAPI 的 ASP.NET Core Web API 帮助页</a>。</p>
<p>将请求 URL 复制粘贴到浏览器中：<code>https://localhost:&lt;port&gt;/WeatherForecast</code></p>
<p>返回类似于以下项的 JSON：</p>
<pre><code class="lang-json">[
    {
        &quot;date&quot;: &quot;2019-07-16T19:04:05.7257911-06:00&quot;,
        &quot;temperatureC&quot;: 52,
        &quot;temperatureF&quot;: 125,
        &quot;summary&quot;: &quot;Mild&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-17T19:04:05.7258461-06:00&quot;,
        &quot;temperatureC&quot;: 36,
        &quot;temperatureF&quot;: 96,
        &quot;summary&quot;: &quot;Warm&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-18T19:04:05.7258467-06:00&quot;,
        &quot;temperatureC&quot;: 39,
        &quot;temperatureF&quot;: 102,
        &quot;summary&quot;: &quot;Cool&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-19T19:04:05.7258471-06:00&quot;,
        &quot;temperatureC&quot;: 10,
        &quot;temperatureF&quot;: 49,
        &quot;summary&quot;: &quot;Bracing&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-20T19:04:05.7258474-06:00&quot;,
        &quot;temperatureC&quot;: -1,
        &quot;temperatureF&quot;: 31,
        &quot;summary&quot;: &quot;Chilly&quot;
    }
]
</code></pre>
<h3 id="update-the-launchurl">更新 launchUrl</h3>
<p>在 Properties\launchSettings.json 中，将 <code>launchUrl</code> 从 <code>&quot;swagger&quot;</code> 更新为 <code>&quot;api/TodoItems&quot;</code>：</p>
<pre><code class="lang-json">&quot;launchUrl&quot;: &quot;api/TodoItems&quot;,
</code></pre>
<p>由于已删除 Swagger，上述标记会将启动的 URL 更改为添加到以下部分的控制器的 GET 方法。</p>
<h2 id="add-a-model-class">添加模型类</h2>
<p>模型是一组表示应用管理的数据的类。 此应用的模型是单个 <code>TodoItem</code> 类。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-3_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-3_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-3_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>在“解决方案资源管理器”中，右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoItem，然后选择“添加”。</p>
</li>
<li><p>将模板代码替换为以下内容：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-3_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>添加名为 Models 的文件夹。</p>
</li>
<li><p>使用以下代码将 <code>TodoItem</code> 类添加到 Models 文件夹：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-3_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
<p><img src="first-web-api-mac/_static/folder.png" alt="新建文件夹"></p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加”&gt;“新建文件”&gt;“常规”&gt;“空类”   。</p>
</li>
<li><p>将类命名为“TodoItem”，然后单击“新建”。</p>
</li>
<li><p>将模板代码替换为以下内容：</p>
</li>
</ul>
</section>
</div>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>Id</code> 属性用作关系数据库中的唯一键。</p>
<p>模型类可位于项目的任意位置，但按照惯例会使用 Models 文件夹。</p>
<h2 id="add-a-database-context">添加数据库上下文</h2>
<p>数据库上下文是为数据模型协调 Entity Framework 功能的主类。 此类由 &lt;xref:Microsoft.EntityFrameworkCore.DbContext?displayProperty=fullName&gt; 类派生而来。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-4_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-4_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-4_visual-studio" role="tabpanel" data-tab="visual-studio">
<h3 id="add-nuget-packages">添加 NuGet 包</h3>
<ul>
<li>在“工具”菜单中，依次选择“NuGet 包管理器”、“管理解决方案的 NuGet 包” 。</li>
<li>选择“浏览”选项卡，然后在搜索框中输入 Microsoft.。
EntityFrameworkCore.SqlServer。</li>
</ul>
<!-- https://github.com/dotnet/AspNetCore.Docs/issues/19782 Delete this line at RTM -->
<ul>
<li>选中“包括预发行版”复选框，以使 5.0 RC 版本可用。</li>
<li>在左窗格中选择“Microsoft.EntityFrameworkCore.SqlServer”。</li>
<li>选中右窗格中的“项目”复选框，然后选择“安装” 。</li>
<li>使用前面的说明添加 Microsoft.EntityFrameworkCore.InMemory NuGet 包。</li>
</ul>
<!-- https://github.com/dotnet/AspNetCore.Docs/issues/19782 Update this image at RTM -->
<p><img src="first-web-api/_static/5/vsNuGet.png" alt="NuGet 包管理器"></p>
<h2 id="add-the-todocontext-database-context">添加 TodoContext 数据库上下文</h2>
<ul>
<li>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoContext，然后单击“添加”。</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-4_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li>将 <code>TodoContext</code> 类添加到 Models 文件夹。</li>
</ul>
</section>
</div>

<ul>
<li><p>输入以下代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<h2 id="register-the-database-context">注册数据库上下文</h2>
<p>在 ASP.NET Core 中，服务（如数据库上下文）必须向<a class="xref" href="../fundamentals/dependency-injection.html">依赖关系注入 (DI)</a> 容器进行注册。 该容器向控制器提供服务。</p>
<p>使用以下代码更新 Startup.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码：</p>
<ul>
<li>删除 Swagger 调用。</li>
<li>删除未使用的 <code>using</code> 声明。</li>
<li>将数据库上下文添加到 DI 容器。</li>
<li>指定数据库上下文将使用内存中数据库。</li>
</ul>
<h2 id="scaffold-a-controller">构建控制器</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-5_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-5_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-5_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>右键单击 Controllers 文件夹。</p>
</li>
<li><p>选择“添加”&gt;“新建构建项” 。</p>
</li>
<li><p>选择“其操作使用实体框架的 API 控制器”，然后选择“添加” 。</p>
</li>
<li><p>在“添加其操作使用实体框架的 API 控制器”对话框中：</p>
<ul>
<li>在“模型类”中选择“TodoItem (TodoApi.Models)” 。</li>
<li>在“数据上下文类”中选择“TodoContext (TodoApi.Models)” 。</li>
<li>选择“添加”。</li>
</ul>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-5_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<p>运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet tool install --global dotnet-aspnet-codegenerator
dotnet tool update -g Dotnet-aspnet-codegenerator
dotnet aspnet-codegenerator controller -name TodoItemsController -async -api -m TodoItem -dc TodoContext -outDir Controllers
</code></pre>
<p>前面的命令：</p>
<ul>
<li>添加构建所需的 NuGet 包。</li>
<li>安装构建引擎 (<code>dotnet-aspnet-codegenerator</code>)。</li>
<li>构建 <code>TodoItemsController</code>。</li>
</ul>
</section>
</div>

<p>生成的代码：</p>
<ul>
<li>使用 <a href="xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute"><code>[ApiController]</code></a> 属性标记类。 此属性指示控制器响应 Web API 请求。 有关该属性启用的特定行为的信息，请参阅 <a class="xref" href="../web-api/index.html">使用 ASP.NET Core 创建 Web API</a>。</li>
<li>使用 DI 将数据库上下文 (<code>TodoContext</code>) 注入到控制器中。 数据库上下文将在控制器中的每个 <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> 方法中使用。</li>
</ul>
<p>ASP.NET Core 模板：</p>
<ul>
<li>具有视图的控制器在路由模板中包含 <code>[action]</code>。</li>
<li>API 控制器不在路由模板中包含 <code>[action]</code>。</li>
</ul>
<p>如果 <code>[action]</code> 标记不在路由模板中，则从路由中排除<a class="xref" href="../mvc/controllers/routing.html#action">操作</a>名称。 也就是说，不会在匹配的路由中使用操作的关联方法名称。</p>
<h2 id="update-the-posttodoitem-create-method">更新 PostTodoItem create 方法</h2>
<p>替换 <code>PostTodoItem</code> 中的返回语句，以使用 <a href="/dotnet/csharp/language-reference/operators/nameof">nameof</a> 运算符：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码是 HTTP POST 方法，如 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPostAttribute"><code>[HttpPost]</code></a> 属性所指示。 该方法从 HTTP 请求正文获取待办事项的值。</p>
<p>有关详细信息，请参阅<a class="xref" href="../mvc/controllers/routing.html#attribute-routing-with-httpverb-attributes">使用 Http [Verb] 特性的特性路由</a>。</p>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtAction*&gt; 方法：</p>
<ul>
<li>如果成功，将返回 <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/201">HTTP 201 状态代码</a>。 HTTP 201 是在服务器上创建新资源的 HTTP POST 方法的标准响应。</li>
<li>向响应添加<a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Location">位置</a>标头。 <code>Location</code> 标头指定新建的待办事项的 <a href="https://developer.mozilla.org/docs/Glossary/URI">URI</a>。 有关详细信息，请参阅<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">创建的 10.2.2 201</a>。</li>
<li>引用 <code>GetTodoItem</code> 操作以创建 <code>Location</code> 标头的 URI。 C# <code>nameof</code> 关键字用于避免在 <code>CreatedAtAction</code> 调用中硬编码操作名称。</li>
</ul>
<h3 id="install-postman">安装 Postman</h3>
<p>本教程使用 Postman 测试 Web API。</p>
<ul>
<li>安装 <a href="https://www.getpostman.com/downloads/">Postman</a></li>
<li>启动 Web 应用。</li>
<li>启动 Postman。</li>
<li>禁用 <strong>SSL 证书验证</strong>
<ul>
<li>在“文件”&gt;“设置”（“常规” 选项卡）中，禁用“SSL 证书验证”。
<div class="WARNING">
<h5>Warning</h5>
<p>在测试控制器之后重新启用 SSL 证书验证。</p>
</div>
</li>
</ul>
</li>
</ul>
<p><a name="post"></a></p>
<h3 id="test-posttodoitem-with-postman">通过 Postman 测试 PostTodoItem</h3>
<ul>
<li><p>创建新请求。</p>
</li>
<li><p>将 HTTP 方法设置为 <code>POST</code>。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems</code>。 例如 <code>https://localhost:5001/api/TodoItems</code>。</p>
</li>
<li><p>选择“正文”选项卡。</p>
</li>
<li><p>选择“原始”单选按钮。</p>
</li>
<li><p>将类型设置为 <strong>JSON (application/json)</strong></p>
</li>
<li><p>在请求正文中，输入待办事项的 JSON：</p>
<pre><code class="lang-json">{
  &quot;name&quot;:&quot;walk dog&quot;,
  &quot;isComplete&quot;:true
}
</code></pre>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
<p><img src="first-web-api/_static/3/create.png" alt="使用创建请求的 Postman"></p>
</li>
</ul>
<h3 id="test-the-location-header-uri">测试位置标头 URI</h3>
<p>你可以在浏览器中测试位置标头 URI。 将位置标头 URI 复制粘贴到浏览器中。</p>
<p>若要在 Postman 中测试，请执行以下操作：</p>
<ul>
<li><p>在 <strong>Headers</strong> 窗格中选择 <strong>Response</strong> 选项卡。</p>
</li>
<li><p>复制 <strong>Location</strong> 标头值：</p>
<p><img src="first-web-api/_static/3/create.png" alt="Postman 控制台的“标头”选项卡"></p>
</li>
<li><p>将 HTTP 方法设置为 <code>GET</code>。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems/1</code>。 例如 <code>https://localhost:5001/api/TodoItems/1</code>。</p>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
</li>
</ul>
<h2 id="examine-the-get-methods">检查 GET 方法</h2>
<p>实现了两个 GET 终结点：</p>
<ul>
<li><code>GET /api/TodoItems</code></li>
<li><code>GET /api/TodoItems/{id}</code></li>
</ul>
<p>通过从浏览器或 Postman 调用两个终结点来测试应用。 例如：</p>
<ul>
<li><code>https://localhost:5001/api/TodoItems</code></li>
<li><code>https://localhost:5001/api/TodoItems/1</code></li>
</ul>
<p>对 <code>GetTodoItems</code> 的调用生成类似于以下项的响应：</p>
<pre><code class="lang-json">[
  {
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Item1&quot;,
    &quot;isComplete&quot;: false
  }
]
</code></pre>
<h3 id="test-get-with-postman">使用 Postman 测试 Get</h3>
<ul>
<li>创建新请求。</li>
<li>将 HTTP 方法设置为“GET”。</li>
<li>将请求 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems</code>。 例如 <code>https://localhost:5001/api/TodoItems</code>。</li>
<li>在 Postman 中设置 <strong>Two pane view</strong> 。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p>此应用使用内存中数据库。 如果应用已停止并启动，则前面的 GET 请求将不会返回任何数据。 如果未返回任何数据，将数据 <a href="#post">POST</a> 到应用。</p>
<h2 id="routing-and-url-paths">路由和 URL 路径</h2>
<p><a href="xref:Microsoft.AspNetCore.Mvc.HttpGetAttribute"><code>[HttpGet]</code></a> 属性表示响应 HTTP GET 请求的方法。 每个方法的 URL 路径构造如下所示：</p>
<ul>
<li><p>在控制器的 <code>Route</code> 属性中以模板字符串开头：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
<li><p>将 <code>[controller]</code> 替换为控制器的名称，按照惯例，在控制器类名称中去掉“Controller”后缀。 对于此示例，控制器类名称为“TodoItems”控制器，因此控制器名称为“TodoItems”。 ASP.NET Core <a class="xref" href="../mvc/controllers/routing.html">路由</a>不区分大小写。</p>
</li>
<li><p>如果 <code>[HttpGet]</code> 属性具有路由模板（例如 <code>[HttpGet(&quot;products&quot;)]</code>），则将它追加到路径。 此示例不使用模板。 有关详细信息，请参阅<a class="xref" href="../mvc/controllers/routing.html#attribute-routing-with-httpverb-attributes">使用 Http [Verb] 特性的特性路由</a>。</p>
</li>
</ul>
<p>在下面的 <code>GetTodoItem</code> 方法中，<code>&quot;{id}&quot;</code> 是待办事项的唯一标识符的占位符变量。 调用 <code>GetTodoItem</code> 时，URL 中 <code>&quot;{id}&quot;</code> 的值会在 <code>id</code> 参数中提供给方法。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="return-values">返回值</h2>
<p><code>GetTodoItems</code> 和 <code>GetTodoItem</code> 方法的返回类型是 <a class="xref" href="../web-api/action-return-types.html#actionresultt-type">ActionResult&lt;T&gt; 类型</a>。 ASP.NET Core 自动将对象序列化为 <a href="https://www.json.org/">JSON</a>，并将 JSON 写入响应消息的正文中。 此返回类型的响应代码为 <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/200">200 OK</a>（假设没有未处理的异常）。 未经处理的异常将转换为 5xx 错误。</p>
<p><code>ActionResult</code> 返回类型可以表示大范围的 HTTP 状态代码。 例如，<code>GetTodoItem</code> 可以返回两个不同的状态值：</p>
<ul>
<li>如果没有任何项与请求的 ID 匹配，该方法将返回 <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/404">404 状态</a> &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.NotFound%2A&gt; 错误代码。</li>
<li>否则，此方法将返回具有 JSON 响应正文的 200。 返回 <code>item</code> 则产生 HTTP 200 响应。</li>
</ul>
<h2 id="the-puttodoitem-method">PutTodoItem 方法</h2>
<p>检查 <code>PutTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>PutTodoItem</code> 与 <code>PostTodoItem</code> 类似，但是使用的是 HTTP PUT。 响应是 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">204（无内容）</a>。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。 若要支持部分更新，请使用 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPatchAttribute">HTTP PATCH</a>。</p>
<p>如果在调用 <code>PutTodoItem</code> 时出错，请调用 <code>GET</code> 以确保数据库中有项目。</p>
<h3 id="test-the-puttodoitem-method">测试 PutTodoItem 方法</h3>
<p>本示例使用内存内、数据库，每次启动应用时都必须对其进行初始化。 在进行 PUT 调用之前，数据库中必须有一个项。 调用 GET，以确保在调用 PUT 之前数据库中存在项。</p>
<p>更新 ID 为 1 的待办事项并将其名称设置为 <code>&quot;feed fish&quot;</code>：</p>
<pre><code class="lang-json">  {
    &quot;Id&quot;:1,
    &quot;name&quot;:&quot;feed fish&quot;,
    &quot;isComplete&quot;:true
  }
</code></pre>
<p>下图显示 Postman 更新：</p>
<p><img src="first-web-api/_static/3/pmcput.png" alt="显示 204（无内容）响应的 Postman 控制台"></p>
<h2 id="the-deletetodoitem-method">DeleteTodoItem 方法</h2>
<p>检查 <code>DeleteTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="test-the-deletetodoitem-method">测试 DeleteTodoItem 方法</h3>
<p>使用 Postman 删除待办事项：</p>
<ul>
<li>将方法设置为 <code>DELETE</code>。</li>
<li>设置要删除的对象的 URI，例如 <code>https://localhost:5001/api/TodoItems/1</code>。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p><a name="over-post-v5"></a></p>
<h2 id="prevent-over-posting">防止过度发布</h2>
<p>目前，示例应用公开了整个 <code>TodoItem</code> 对象。 生产应用通常使用模型的子集来限制输入和返回的数据。 这背后有多种原因，但安全性是主要原因。 模型的子集通常称为数据传输对象 (DTO)、输入模型或视图模型。 本文使用的是 <strong>DTO</strong> 。</p>
<p>DTO 可用于：</p>
<ul>
<li>防止过度发布。</li>
<li>隐藏客户端不应查看的属性。</li>
<li>省略一些属性以缩减有效负载大小。</li>
<li>平展包含嵌套对象的对象图。 对客户端而言，平展的对象图可能更方便。</li>
</ul>
<p>若要演示 DTO 方法，请更新 <code>TodoItem</code> 类，使其包含机密字段：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>此应用需要隐藏机密字段，但管理应用可以选择公开它。</p>
<p>确保可以发布和获取机密字段。</p>
<p>创建 DTO 模型：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>更新 <code>TodoItemsController</code> 以使用 <code>TodoItemDTO</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>确保无法发布或获取机密字段。</p>
<h2 id="call-the-web-api-with-javascript">使用 JavaScript 调用 Web API</h2>
<p>请参阅<a class="xref" href="web-api-javascript.html">教程：使用 JavaScript 调用 ASP.NET Core Web API</a>。</p>
</div>
<div range="&gt;= aspnetcore-3.0 &lt; aspnetcore-5.0">
<p>在本教程中，你将了解：</p>
<div class="checklist">
<ul>
<li>创建 Web API 项目。</li>
<li>添加模型类和数据库上下文。</li>
<li>使用 CRUD 方法构建控制器。</li>
<li>配置路由、URL 路径和返回值。</li>
<li>使用 Postman 调用 Web API。</li>
</ul>
</div>
<p>在结束时，你会获得可以管理存储在数据库中的“待办事项”的 Web API。</p>
<h2 id="overview">概述</h2>
<p>本教程将创建以下 API：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
<th>请求正文</th>
<th>响应正文</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET /api/TodoItems</code></td>
<td>获取所有待办事项</td>
<td>None</td>
<td>待办事项的数组</td>
</tr>
<tr>
<td><code>GET /api/TodoItems/{id}</code></td>
<td>按 ID 获取项</td>
<td>None</td>
<td>待办事项</td>
</tr>
<tr>
<td><code>POST /api/TodoItems</code></td>
<td>添加新项</td>
<td>待办事项</td>
<td>待办事项</td>
</tr>
<tr>
<td><code>PUT /api/TodoItems/{id}</code></td>
<td>更新现有项  </td>
<td>待办事项</td>
<td>None</td>
</tr>
<tr>
<td><code>DELETE /api/TodoItems/{id}</code>    </td>
<td>删除项   </td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>下图显示了应用的设计。</p>
<p><img src="first-web-api/_static/architecture.png" alt="右侧的框表示客户端。 它提交请求并从应用程序接收响应，如右侧的框所示。 在应用程序框内，三个框分别代表控制器、模型和数据访问层。 请求进入应用程序的控制器，读/写操作是在控制器和数据访问层之间进行的。 模型被序列化并在响应中被返回给客户端。"></p>
<h2 id="prerequisites">先决条件</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-6_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-6_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-6_visual-studio" role="tabpanel" data-tab="visual-studio">
<ul>
<li>具有“ASP.NET 和 Web 开发”工作负载的 <a href="https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019">Visual Studio 2019 16.4 或更高版本</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">.NET Core 3.1 SDK 或更高版本</a></p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-6_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">用于 Visual Studio Code 的 C#（最新版本）</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">.NET Core 3.1 SDK 或更高版本</a></p>
</li>
</ul>
<p>Visual Studio Code 说明使用用于 ASP.NET Core 的 .NET Core CLI 开发功能，如项目创建。 可在任何平台（macOS、Linux 或 Windows）上或在任何代码编辑器中遵循这些说明。 如果使用 Visual Studio Code 以外的其他内容，则可能需要进行少量更改。 有关在 macOS 上安装 Visual Studio Code 的详细信息，请参阅<a href="https://code.visualstudio.com/docs/setup/mac">macOS 上的 Visual Studio Code</a>。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-6_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://visualstudio.microsoft.com/vs/mac/">Visual Studio for Mac 版本 8.4 或更高版本</a></li>
<li><p><a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">.NET Core 3.1 SDK 或更高版本</a></p>
</li>
</ul>
</section>
</div>
<h2 id="create-a-web-project">创建 Web 项目</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-7_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-7_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-7_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li>从“文件”菜单中选择“新建”&gt;“项目”  。</li>
<li>选择“ASP.NET Core Web 应用程序”模板，再单击“下一步” 。</li>
<li>将项目命名为 TodoApi，然后单击“创建”。</li>
<li>在“创建新的 ASP.NET Core Web 应用程序”对话框中，确认选择“.NET Core”和“ASP.NET Core 3.1”  。 选择“API”模板，然后单击“创建” 。</li>
</ul>
<p><img src="first-web-api/_static/vs3.png" alt="VS“新建项目”对话框"></p>
</section>
<section id="tabpanel_CeZOj-G++Q-7_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>打开<a href="https://code.visualstudio.com/docs/editor/integrated-terminal">集成终端</a>。</p>
</li>
<li><p>将目录 (<code>cd</code>) 更改为包含项目文件夹的文件夹。</p>
</li>
<li><p>运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet new webapi -o TodoApi
cd TodoApi
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.InMemory
code -r ../TodoApi
</code></pre>
</li>
<li><p>当对话框询问是否要将所需资产添加到项目时，选择“是”。</p>
<p>前面的命令：</p>
<ul>
<li>创建新的 web API 项目，并在 Visual Studio Code 中打开它。</li>
<li>添加下一部分中所需的 NuGet 包。</li>
</ul>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-7_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>选择“文件”&gt;“新建解决方案” 。</p>
<p><img src="first-web-api-mac/_static/sln.png" alt="macOS 新建解决方案"></p>
</li>
<li><p>在版本 8.6 之前的 Visual Studio for Mac 中，依次选择“.NET Core” &gt; “应用” &gt; “API” &gt; “下一步”   。 在版本 8.6 或更高版本中，依次选择“Web 和控制台” &gt; “应用” &gt; “API” &gt; “下一步”。</p>
<p><img src="first-web-api-mac/_static/api_template.png" alt="macOS API 模板选择"></p>
</li>
<li><p>在“配置新的 ASP.NET Core Web API”对话框中，选择最新的 .NET Core 3.x 目标框架 。 选择“下一步”。</p>
</li>
<li><p>输入“TodoApi”作为“项目名称”，然后选择“创建”。</p>
<p><img src="first-web-api-mac/_static/2.png" alt="配置对话框"></p>
</li>
</ul>
<h3 id="accessing-a-command-terminal-on-visual-studios-for-mac">访问 Visual studio for Mac 上的命令终端</h3>
<p>首次访问 Mac 上的命令终端需要以下设置配置：</p>
<ul>
<li>导航到“系统首选项”&gt;“键盘”&gt;“快捷方式”&gt;“服务”  。</li>
<li>在“文件和文件夹”下，验证是否选中了“文件夹中的新终端”   。</li>
</ul>
<p>上述说明以两种方式实现访问命令终端：从 Visual Studio 内访问或通过查找器访问   。</p>
<h4 id="to-access-a-command-terminal-from-visual-studio-for-mac">若要从 Visual Studio for Mac 访问命令终端，请执行以下操作：</h4>
<ul>
<li>右键单击项目名称。</li>
<li>导航到“工具”&gt;“在终端中打开”  。</li>
</ul>
<h4 id="to-access-a-command-terminal-from-finder">若要通过查找器访问命令终端，请执行以下操作：</h4>
<ul>
<li>右键单击所需文件夹。</li>
<li>在列表底部，选择“文件夹中的新终端”  。</li>
</ul>

<p>在项目文件夹中打开命令终端并运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.InMemory
</code></pre>
</section>
</div>
<h3 id="test-the-api">测试 API</h3>
<p>项目模板会创建 <code>WeatherForecast</code> API。 从浏览器调用 <code>Get</code> 方法以测试应用。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-8">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-8_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-8_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-8_visual-studio" role="tabpanel" data-tab="visual-studio">

<p>按 Ctrl+F5 运行应用。 Visual Studio 启动浏览器并导航到 <code>https://localhost:&lt;port&gt;/WeatherForecast</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。</p>
<p>如果出现询问是否应信任 IIS Express 证书的对话框，则选择“是”。 在接下来出现的“安全警告”对话框中，选择“是”。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-8_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<p>按 Ctrl+F5 运行应用。 在浏览器中，转到以下 URL：<code>https://localhost:5001/WeatherForecast</code>。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-8_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<p>选择“运行” &gt; “开始调试”以启动应用。 Visual Studio for Mac 会启动浏览器并导航到 <code>https://localhost:&lt;port&gt;</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。 将返回 HTTP 404（未找到）错误。 将 <code>/WeatherForecast</code> 追加到 URL（将 URL 更改为 <code>https://localhost:&lt;port&gt;/WeatherForecast</code>）。</p>
</section>
</div>

<p>返回类似于以下项的 JSON：</p>
<pre><code class="lang-json">[
    {
        &quot;date&quot;: &quot;2019-07-16T19:04:05.7257911-06:00&quot;,
        &quot;temperatureC&quot;: 52,
        &quot;temperatureF&quot;: 125,
        &quot;summary&quot;: &quot;Mild&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-17T19:04:05.7258461-06:00&quot;,
        &quot;temperatureC&quot;: 36,
        &quot;temperatureF&quot;: 96,
        &quot;summary&quot;: &quot;Warm&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-18T19:04:05.7258467-06:00&quot;,
        &quot;temperatureC&quot;: 39,
        &quot;temperatureF&quot;: 102,
        &quot;summary&quot;: &quot;Cool&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-19T19:04:05.7258471-06:00&quot;,
        &quot;temperatureC&quot;: 10,
        &quot;temperatureF&quot;: 49,
        &quot;summary&quot;: &quot;Bracing&quot;
    },
    {
        &quot;date&quot;: &quot;2019-07-20T19:04:05.7258474-06:00&quot;,
        &quot;temperatureC&quot;: -1,
        &quot;temperatureF&quot;: 31,
        &quot;summary&quot;: &quot;Chilly&quot;
    }
]
</code></pre>
<h2 id="add-a-model-class">添加模型类</h2>
<p>模型是一组表示应用管理的数据的类。 此应用的模型是单个 <code>TodoItem</code> 类。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-9">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-9_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-9_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-9_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>在“解决方案资源管理器”中，右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoItem，然后选择“添加”。</p>
</li>
<li><p>将模板代码替换为以下代码：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-9_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>添加名为 Models 的文件夹。</p>
</li>
<li><p>使用以下代码将 <code>TodoItem</code> 类添加到 Models 文件夹：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-9_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
<p><img src="first-web-api-mac/_static/folder.png" alt="新建文件夹"></p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加”&gt;“新建文件”&gt;“常规”&gt;“空类”   。</p>
</li>
<li><p>将类命名为“TodoItem”，然后单击“新建”。</p>
</li>
<li><p>将模板代码替换为以下代码：</p>
</li>
</ul>
</section>
</div>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>Id</code> 属性用作关系数据库中的唯一键。</p>
<p>模型类可位于项目的任意位置，但按照惯例会使用 Models 文件夹。</p>
<h2 id="add-a-database-context">添加数据库上下文</h2>
<p>数据库上下文是为数据模型协调 Entity Framework 功能的主类。 此类由 <code>Microsoft.EntityFrameworkCore.DbContext</code> 类派生而来。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-10">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-10_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-10_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-10_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-10_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-10_visual-studio" role="tabpanel" data-tab="visual-studio">
<h3 id="add-nuget-packages">添加 NuGet 包</h3>
<ul>
<li>在“工具”菜单中，依次选择“NuGet 包管理器”、“管理解决方案的 NuGet 包” 。</li>
<li>选择“浏览”选项卡，然后在搜索框中输入 Microsoft.EntityFrameworkCore.SqlServer 。</li>
<li>在左窗格中选择“Microsoft.EntityFrameworkCore.SqlServer”。</li>
<li>选中右窗格中的“项目”复选框，然后选择“安装” 。</li>
<li>使用前面的说明添加 Microsoft.EntityFrameworkCore.InMemory NuGet 包。</li>
</ul>
<p><img src="first-web-api/_static/vs3NuGet.png" alt="NuGet 程序包管理器"></p>
<h2 id="add-the-todocontext-database-context">添加 TodoContext 数据库上下文</h2>
<ul>
<li>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoContext，然后单击“添加”。</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-10_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li>将 <code>TodoContext</code> 类添加到 Models 文件夹。</li>
</ul>
</section>
</div>

<ul>
<li><p>输入以下代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<h2 id="register-the-database-context">注册数据库上下文</h2>
<p>在 ASP.NET Core 中，服务（如数据库上下文）必须向<a class="xref" href="../fundamentals/dependency-injection.html">依赖关系注入 (DI)</a> 容器进行注册。 该容器向控制器提供服务。</p>
<p>使用以下突出显示的代码更新 Startup.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码：</p>
<ul>
<li>删除未使用的 <code>using</code> 声明。</li>
<li>将数据库上下文添加到 DI 容器。</li>
<li>指定数据库上下文将使用内存中数据库。</li>
</ul>
<h2 id="scaffold-a-controller">构建控制器</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-11">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-11_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-11_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-11_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-11_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-11_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>右键单击 Controllers 文件夹。</p>
</li>
<li><p>选择“添加”&gt;“新建构建项” 。</p>
</li>
<li><p>选择“其操作使用实体框架的 API 控制器”，然后选择“添加” 。</p>
</li>
<li><p>在“添加其操作使用实体框架的 API 控制器”对话框中：</p>
<ul>
<li>在“模型类”中选择“TodoItem (TodoApi.Models)” 。</li>
<li>在“数据上下文类”中选择“TodoContext (TodoApi.Models)” 。</li>
<li>选择“添加”。</li>
</ul>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-11_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<p>运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet tool install --global dotnet-aspnet-codegenerator
dotnet tool update -g Dotnet-aspnet-codegenerator
dotnet aspnet-codegenerator controller -name TodoItemsController -async -api -m TodoItem -dc TodoContext -outDir Controllers
</code></pre>
<p>前面的命令：</p>
<ul>
<li>添加构建所需的 NuGet 包。</li>
<li>安装构建引擎 (<code>dotnet-aspnet-codegenerator</code>)。</li>
<li>构建 <code>TodoItemsController</code>。</li>
</ul>
</section>
</div>

<p>生成的代码：</p>
<ul>
<li>使用 <a href="xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute"><code>[ApiController]</code></a> 属性标记类。 此属性指示控制器响应 Web API 请求。 有关该属性启用的特定行为的信息，请参阅 <a class="xref" href="../web-api/index.html">使用 ASP.NET Core 创建 Web API</a>。</li>
<li>使用 DI 将数据库上下文 (<code>TodoContext</code>) 注入到控制器中。 数据库上下文将在控制器中的每个 <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> 方法中使用。</li>
</ul>
<p>ASP.NET Core 模板：</p>
<ul>
<li>具有视图的控制器在路由模板中包含 <code>[action]</code>。</li>
<li>API 控制器不在路由模板中包含 <code>[action]</code>。</li>
</ul>
<p>如果 <code>[action]</code> 标记不在路由模板中，则从路由中排除<a class="xref" href="../mvc/controllers/routing.html#action">操作</a>名称。 也就是说，不会在匹配的路由中使用操作的关联方法名称。</p>
<h2 id="examine-the-posttodoitem-create-method">检查 PostTodoItem create 方法</h2>
<p>替换 <code>PostTodoItem</code> 中的返回语句，以使用 <a href="/dotnet/csharp/language-reference/operators/nameof">nameof</a> 运算符：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码是 HTTP POST 方法，如 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPostAttribute"><code>[HttpPost]</code></a> 属性所指示。 该方法从 HTTP 请求正文获取待办事项的值。</p>
<p>有关详细信息，请参阅<a class="xref" href="../mvc/controllers/routing.html#attribute-routing-with-httpverb-attributes">使用 Http [Verb] 特性的特性路由</a>。</p>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.CreatedAtAction*&gt; 方法：</p>
<ul>
<li>如果成功，则返回 HTTP 201 状态代码。 HTTP 201 是在服务器上创建新资源的 HTTP POST 方法的标准响应。</li>
<li>向响应添加<a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Location">位置</a>标头。 <code>Location</code> 标头指定新建的待办事项的 <a href="https://developer.mozilla.org/docs/Glossary/URI">URI</a>。 有关详细信息，请参阅<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">创建的 10.2.2 201</a>。</li>
<li>引用 <code>GetTodoItem</code> 操作以创建 <code>Location</code> 标头的 URI。 C# <code>nameof</code> 关键字用于避免在 <code>CreatedAtAction</code> 调用中硬编码操作名称。</li>
</ul>
<h3 id="install-postman">安装 Postman</h3>
<p>本教程使用 Postman 测试 Web API。</p>
<ul>
<li>安装 <a href="https://www.getpostman.com/downloads/">Postman</a></li>
<li>启动 Web 应用。</li>
<li>启动 Postman。</li>
<li>禁用 <strong>SSL 证书验证</strong>
<ul>
<li>在“文件”&gt;“设置”（“常规” 选项卡）中，禁用“SSL 证书验证”。
<div class="WARNING">
<h5>Warning</h5>
<p>在测试控制器之后重新启用 SSL 证书验证。</p>
</div>
</li>
</ul>
</li>
</ul>
<p><a name="post"></a></p>
<h3 id="test-posttodoitem-with-postman">通过 Postman 测试 PostTodoItem</h3>
<ul>
<li><p>创建新请求。</p>
</li>
<li><p>将 HTTP 方法设置为 <code>POST</code>。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems</code>。 例如 <code>https://localhost:5001/api/TodoItems</code>。</p>
</li>
<li><p>选择“正文”选项卡。</p>
</li>
<li><p>选择“原始”单选按钮。</p>
</li>
<li><p>将类型设置为 <strong>JSON (application/json)</strong></p>
</li>
<li><p>在请求正文中，输入待办事项的 JSON：</p>
<pre><code class="lang-json">{
  &quot;name&quot;:&quot;walk dog&quot;,
  &quot;isComplete&quot;:true
}
</code></pre>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
<p><img src="first-web-api/_static/3/create.png" alt="使用创建请求的 Postman"></p>
</li>
</ul>
<h3 id="test-the-location-header-uri-with-postman">使用 Postman 测试位置标头 URI</h3>
<ul>
<li><p>在 <strong>Headers</strong> 窗格中选择 <strong>Response</strong> 选项卡。</p>
</li>
<li><p>复制 <strong>Location</strong> 标头值：</p>
<p><img src="first-web-api/_static/3/create.png" alt="Postman 控制台的“标头”选项卡"></p>
</li>
<li><p>将 HTTP 方法设置为 <code>GET</code>。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems/1</code>。 例如 <code>https://localhost:5001/api/TodoItems/1</code>。</p>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
</li>
</ul>
<h2 id="examine-the-get-methods">检查 GET 方法</h2>
<p>这些方法实现两个 GET 终结点：</p>
<ul>
<li><code>GET /api/TodoItems</code></li>
<li><code>GET /api/TodoItems/{id}</code></li>
</ul>
<p>通过从浏览器或 Postman 调用两个终结点来测试应用。 例如：</p>
<ul>
<li><code>https://localhost:5001/api/TodoItems</code></li>
<li><code>https://localhost:5001/api/TodoItems/1</code></li>
</ul>
<p>对 <code>GetTodoItems</code> 的调用生成类似于以下项的响应：</p>
<pre><code class="lang-json">[
  {
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Item1&quot;,
    &quot;isComplete&quot;: false
  }
]
</code></pre>
<h3 id="test-get-with-postman">使用 Postman 测试 Get</h3>
<ul>
<li>创建新请求。</li>
<li>将 HTTP 方法设置为“GET”。</li>
<li>将请求 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems</code>。 例如 <code>https://localhost:5001/api/TodoItems</code>。</li>
<li>在 Postman 中设置 <strong>Two pane view</strong> 。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p>此应用使用内存中数据库。 如果应用已停止并启动，则前面的 GET 请求将不会返回任何数据。 如果未返回任何数据，将数据 <a href="#post">POST</a> 到应用。</p>
<h2 id="routing-and-url-paths">路由和 URL 路径</h2>
<p><a href="xref:Microsoft.AspNetCore.Mvc.HttpGetAttribute"><code>[HttpGet]</code></a> 属性表示响应 HTTP GET 请求的方法。 每个方法的 URL 路径构造如下所示：</p>
<ul>
<li><p>在控制器的 <code>Route</code> 属性中以模板字符串开头：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
<li><p>将 <code>[controller]</code> 替换为控制器的名称，按照惯例，在控制器类名称中去掉“Controller”后缀。 对于此示例，控制器类名称为“TodoItems”控制器，因此控制器名称为“TodoItems”。 ASP.NET Core <a class="xref" href="../mvc/controllers/routing.html">路由</a>不区分大小写。</p>
</li>
<li><p>如果 <code>[HttpGet]</code> 属性具有路由模板（例如 <code>[HttpGet(&quot;products&quot;)]</code>），则将它追加到路径。 此示例不使用模板。 有关详细信息，请参阅<a class="xref" href="../mvc/controllers/routing.html#attribute-routing-with-httpverb-attributes">使用 Http [Verb] 特性的特性路由</a>。</p>
</li>
</ul>
<p>在下面的 <code>GetTodoItem</code> 方法中，<code>&quot;{id}&quot;</code> 是待办事项的唯一标识符的占位符变量。 调用 <code>GetTodoItem</code> 时，URL 中 <code>&quot;{id}&quot;</code> 的值会在 <code>id</code> 参数中提供给方法。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="return-values">返回值</h2>
<p><code>GetTodoItems</code> 和 <code>GetTodoItem</code> 方法的返回类型是 <a class="xref" href="../web-api/action-return-types.html#actionresultt-type">ActionResult&lt;T&gt; 类型</a>。 ASP.NET Core 自动将对象序列化为 <a href="https://www.json.org/">JSON</a>，并将 JSON 写入响应消息的正文中。 在假设没有未经处理的异常的情况下，此返回类型的响应代码为 200。 未经处理的异常将转换为 5xx 错误。</p>
<p><code>ActionResult</code> 返回类型可以表示大范围的 HTTP 状态代码。 例如，<code>GetTodoItem</code> 可以返回两个不同的状态值：</p>
<ul>
<li>如果没有任何项与请求的 ID 匹配，则该方法将返回 404 &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.NotFound%2A&gt; 错误代码。</li>
<li>否则，此方法将返回具有 JSON 响应正文的 200。 返回 <code>item</code> 则产生 HTTP 200 响应。</li>
</ul>
<h2 id="the-puttodoitem-method">PutTodoItem 方法</h2>
<p>检查 <code>PutTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>PutTodoItem</code> 与 <code>PostTodoItem</code> 类似，但是使用的是 HTTP PUT。 响应是 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">204（无内容）</a>。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。 若要支持部分更新，请使用 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPatchAttribute">HTTP PATCH</a>。</p>
<p>如果在调用 <code>PutTodoItem</code> 时出错，请调用 <code>GET</code> 以确保数据库中有项目。</p>
<h3 id="test-the-puttodoitem-method">测试 PutTodoItem 方法</h3>
<p>本示例使用内存内、数据库，每次启动应用时都必须对其进行初始化。 在进行 PUT 调用之前，数据库中必须有一个项。 调用 GET，以确保在调用 PUT 之前数据库中存在项。</p>
<p>更新 ID 为 1 的待办事项并将其名称设置为“feed fish”：</p>
<pre><code class="lang-json">  {
    &quot;id&quot;:1,
    &quot;name&quot;:&quot;feed fish&quot;,
    &quot;isComplete&quot;:true
  }
</code></pre>
<p>下图显示 Postman 更新：</p>
<p><img src="first-web-api/_static/3/pmcput.png" alt="显示 204（无内容）响应的 Postman 控制台"></p>
<h2 id="the-deletetodoitem-method">DeleteTodoItem 方法</h2>
<p>检查 <code>DeleteTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="test-the-deletetodoitem-method">测试 DeleteTodoItem 方法</h3>
<p>使用 Postman 删除待办事项：</p>
<ul>
<li>将方法设置为 <code>DELETE</code>。</li>
<li>设置要删除的对象的 URI，例如 <code>https://localhost:5001/api/TodoItems/1</code>。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p><a name="over-post"></a>
<a name="over-post-v3"></a></p>
<h2 id="prevent-over-posting">防止过度发布</h2>
<p>目前，示例应用公开了整个 <code>TodoItem</code> 对象。 生产应用通常使用模型的子集来限制输入和返回的数据。 这背后有多种原因，但安全性是主要原因。 模型的子集通常称为数据传输对象 (DTO)、输入模型或视图模型。 本文使用的是 <strong>DTO</strong> 。</p>
<p>DTO 可用于：</p>
<ul>
<li>防止过度发布。</li>
<li>隐藏客户端不应查看的属性。</li>
<li>省略一些属性以缩减有效负载大小。</li>
<li>平展包含嵌套对象的对象图。 对客户端而言，平展的对象图可能更方便。</li>
</ul>
<p>若要演示 DTO 方法，请更新 <code>TodoItem</code> 类，使其包含机密字段：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>此应用需要隐藏机密字段，但管理应用可以选择公开它。</p>
<p>确保可以发布和获取机密字段。</p>
<p>创建 DTO 模型：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>更新 <code>TodoItemsController</code> 以使用 <code>TodoItemDTO</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>确保无法发布或获取机密字段。</p>
<h2 id="call-the-web-api-with-javascript">使用 JavaScript 调用 Web API</h2>
<p>请参阅<a class="xref" href="web-api-javascript.html">教程：使用 JavaScript 调用 ASP.NET Core Web API</a>。</p>
</div>
<div range="&lt; aspnetcore-3.0">
<p>在本教程中，你将了解：</p>
<div class="checklist">
<ul>
<li>创建 Web API 项目。</li>
<li>添加模型类和数据库上下文。</li>
<li>添加控制器。</li>
<li>添加 CRUD 方法。</li>
<li>配置路由和 URL 路径。</li>
<li>指定返回值。</li>
<li>使用 Postman 调用 Web API。</li>
<li>使用 JavaScript 调用 Web API。</li>
</ul>
</div>
<p>在结束时，你会获得可以管理存储在关系数据库中的“待办事项”的 Web API。</p>
<h2 id="overview-21">概述 2.1</h2>
<p>本教程将创建以下 API：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
<th>请求正文</th>
<th>响应正文</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /api/TodoItems</td>
<td>获取所有待办事项</td>
<td>None</td>
<td>待办事项的数组</td>
</tr>
<tr>
<td>GET /api/TodoItems/{id}</td>
<td>按 ID 获取项</td>
<td>None</td>
<td>待办事项</td>
</tr>
<tr>
<td>POST /api/TodoItems</td>
<td>添加新项</td>
<td>待办事项</td>
<td>待办事项</td>
</tr>
<tr>
<td>PUT /api/TodoItems/{id}</td>
<td>更新现有项  </td>
<td>待办事项</td>
<td>None</td>
</tr>
<tr>
<td>DELETE /api/TodoItems/{id}    </td>
<td>删除项   </td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>下图显示了应用的设计。</p>
<p><img src="first-web-api/_static/architecture.png" alt="右侧的框表示客户端。 它提交请求并从应用程序接收响应，如右侧的框所示。 在应用程序框内，三个框分别代表控制器、模型和数据访问层。 请求进入应用程序的控制器，读/写操作是在控制器和数据访问层之间进行的。 模型被序列化并在响应中被返回给客户端。"></p>
<h2 id="prerequisites-21">先决条件 2.1</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-12">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-12_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-12_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-12_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-12_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-12_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-12_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-12_visual-studio" role="tabpanel" data-tab="visual-studio">
<ul>
<li>带有 ASP.NET 和 Web 开发工作负荷的 <a href="https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019">Visual Studio 2019</a></li>
<li><a href="https://dotnet.microsoft.com/download/dotnet-core">.NET Core SDK 2.2 或更高版本</a></li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>如果使用 Visual Studio 2017，请参阅 <a href="https://github.com/dotnet/sdk/issues/3124">dotnet/sdk 问题 #3124</a>，以了解无法与 Visual Studio 一起使用的 .NET Core SDK 版本的信息。</p>
</div>
</section>
<section id="tabpanel_CeZOj-G++Q-12_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">用于 Visual Studio Code 的 C#（最新版本）</a></li>
<li><a href="https://dotnet.microsoft.com/download/dotnet-core">.NET Core SDK 2.2 或更高版本</a></li>
</ul>
<p>Visual Studio Code 说明使用用于 ASP.NET Core 的 .NET Core CLI 开发功能，如项目创建。 可在任何平台（macOS、Linux 或 Windows）上或在任何代码编辑器中遵循这些说明。 如果使用 Visual Studio Code 以外的其他内容，则可能需要进行少量更改。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-12_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">
<ul>
<li><a href="https://visualstudio.microsoft.com/downloads/">Visual Studio for Mac 版本 8.0 或更高版本</a></li>
<li><a href="https://dotnet.microsoft.com/download/dotnet-core">.NET Core SDK 2.2 或更高版本</a></li>
</ul>
</section>
</div>
<h2 id="create-a-web-project-21">创建 Web 项目 2.1</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-13">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-13_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-13_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-13_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-13_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-13_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-13_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-13_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li>从“文件”菜单中选择“新建”&gt;“项目”  。</li>
<li>选择“ASP.NET Core Web 应用程序”模板，再单击“下一步” 。</li>
<li>将项目命名为 TodoApi，然后单击“创建”。</li>
<li>在“创建新的 ASP.NET Core Web 应用程序”对话框中，确认选择“.NET Core”和“ASP.NET Core 2.2”  。 选择“API”模板，然后单击“创建” 。 请不要选择“启用 Docker 支持” 。</li>
</ul>
<p><img src="first-web-api/_static/vs.png" alt="VS“新建项目”对话框"></p>
</section>
<section id="tabpanel_CeZOj-G++Q-13_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>打开<a href="https://code.visualstudio.com/docs/editor/integrated-terminal">集成终端</a>。</p>
</li>
<li><p>将目录 (<code>cd</code>) 更改为包含项目文件夹的文件夹。</p>
</li>
<li><p>运行以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet new webapi -o TodoApi
code -r TodoApi
</code></pre>
<p>这些命令会创建新 Web API 项目并在新项目文件夹中打开 Visual Studio Code 的新实例。</p>
</li>
<li><p>当对话框询问是否要将所需资产添加到项目时，选择“是”。</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-13_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>选择“文件”&gt;“新建解决方案” 。</p>
<p><img src="first-web-api-mac/_static/sln.png" alt="macOS 新建解决方案"></p>
</li>
<li><p>在版本 8.6 之前的 Visual Studio for Mac 中，依次选择“.NET Core” &gt; “应用” &gt; “API” &gt; “下一步”   。 在版本 8.6 或更高版本中，依次选择“Web 和控制台” &gt; “应用” &gt; “API” &gt; “下一步”。</p>
</li>
<li><p>在“配置新的 ASP.NET Core Web API”对话框中，选择最新的 .NET Core 2.x 目标框架 。 选择“下一步”。</p>
</li>
<li><p>输入“TodoApi”作为“项目名称”，然后选择“创建”。</p>
<p><img src="first-web-api-mac/_static/2.png" alt="配置对话框"></p>
</li>
</ul>
</section>
</div>
<h3 id="test-the-api-21">测试 API 2.1</h3>
<p>项目模板会创建 <code>values</code> API。 从浏览器调用 <code>Get</code> 方法以测试应用。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-14">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-14_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-14_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-14_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-14_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-14_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-14_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-14_visual-studio" role="tabpanel" data-tab="visual-studio">

<p>按 Ctrl+F5 运行应用。 Visual Studio 启动浏览器并导航到 <code>https://localhost:&lt;port&gt;/api/values</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。</p>
<p>如果出现询问是否应信任 IIS Express 证书的对话框，则选择“是”。 在接下来出现的“安全警告”对话框中，选择“是”。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-14_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<p>按 Ctrl+F5 运行应用。 在浏览器中，转到以下 URL：<code>https://localhost:5001/api/values</code>。</p>
</section>
<section id="tabpanel_CeZOj-G++Q-14_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<p>选择“运行” &gt; “开始调试”以启动应用。 Visual Studio for Mac 会启动浏览器并导航到 <code>https://localhost:&lt;port&gt;</code>，其中 <code>&lt;port&gt;</code> 是随机选择的端口号。 将返回 HTTP 404（未找到）错误。 将 <code>/api/values</code> 追加到 URL（将 URL 更改为 <code>https://localhost:&lt;port&gt;/api/values</code>）。</p>
</section>
</div>

<p>会返回以下 JSON：</p>
<pre><code class="lang-json">[&quot;value1&quot;,&quot;value2&quot;]
</code></pre>
<h2 id="add-a-model-class-21">添加模型类 2.1</h2>
<p>模型是一组表示应用管理的数据的类。 此应用的模型是单个 <code>TodoItem</code> 类。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-15">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-15_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-15_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-15_visual-studio-code" role="tab" aria-controls="tabpanel_CeZOj-G++Q-15_visual-studio-code" data-tab="visual-studio-code" tabindex="-1">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-15_visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-15_visual-studio-mac" data-tab="visual-studio-mac" tabindex="-1">Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-15_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>在“解决方案资源管理器”中，右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoItem，然后选择“添加”。</p>
</li>
<li><p>将模板代码替换为以下代码：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-15_visual-studio-code" role="tabpanel" data-tab="visual-studio-code" aria-hidden="true" hidden="hidden">

<ul>
<li><p>添加名为 Models 的文件夹。</p>
</li>
<li><p>使用以下代码将 <code>TodoItem</code> 类添加到 Models 文件夹：</p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-15_visual-studio-mac" role="tabpanel" data-tab="visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li><p>右键单击项目。 选择“添加” &gt; “新建文件夹”。 将文件夹命名为 Models。</p>
<p><img src="first-web-api-mac/_static/folder.png" alt="新建文件夹"></p>
</li>
<li><p>右键单击 Models 文件夹，然后选择“添加”&gt;“新建文件”&gt;“常规”&gt;“空类”   。</p>
</li>
<li><p>将类命名为“TodoItem”，然后单击“新建”。</p>
</li>
<li><p>将模板代码替换为以下代码：</p>
</li>
</ul>
</section>
</div>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>Id</code> 属性用作关系数据库中的唯一键。</p>
<p>模型类可位于项目的任意位置，但按照惯例会使用 Models 文件夹。</p>
<h2 id="add-a-database-context-21">添加数据库上下文 2.1</h2>
<p>数据库上下文是为数据模型协调 Entity Framework 功能的主类。 此类由 <code>Microsoft.EntityFrameworkCore.DbContext</code> 类派生而来。</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-16">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-16_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-16_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-16_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-16_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-16_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li>右键单击 Models 文件夹，然后选择“添加” &gt; “类” 。 将类命名为 TodoContext，然后单击“添加”。</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-16_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li>将 <code>TodoContext</code> 类添加到 Models 文件夹。</li>
</ul>
</section>
</div>

<ul>
<li><p>将模板代码替换为以下代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<h2 id="register-the-database-context-21">注册数据库上下文 2.1</h2>
<p>在 ASP.NET Core 中，服务（如数据库上下文）必须向<a class="xref" href="../fundamentals/dependency-injection.html">依赖关系注入 (DI)</a> 容器进行注册。 该容器向控制器提供服务。</p>
<p>使用以下突出显示的代码更新 Startup.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码：</p>
<ul>
<li>删除未使用的 <code>using</code> 声明。</li>
<li>将数据库上下文添加到 DI 容器。</li>
<li>指定数据库上下文将使用内存中数据库。</li>
</ul>
<h2 id="add-a-controller-21">添加控制器 2.1</h2>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-17">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-17_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-17_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-17_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-17_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-17_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li><p>右键单击 Controllers 文件夹。</p>
</li>
<li><p>选择“添加”&gt;“新项”  。</p>
</li>
<li><p>在“添加新项”对话框中，选择“API 控制器类”模板 。</p>
</li>
<li><p>将类命名为 TodoController，然后选择“添加”。</p>
<p><img src="first-web-api/_static/new_controller.png" alt="“添加新项”对话框，“控制器”显示在搜索框中，并且“Web API 控制器”已选中"></p>
</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-17_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li>在“控制器”文件夹中，创建名为 <code>TodoController</code> 的类。</li>
</ul>
</section>
</div>

<ul>
<li><p>将模板代码替换为以下代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<p>前面的代码：</p>
<ul>
<li>定义了没有方法的 API 控制器类。</li>
<li>使用 <a href="xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute"><code>[ApiController]</code></a> 属性标记类。 此属性指示控制器响应 Web API 请求。 有关该属性启用的特定行为的信息，请参阅 <a class="xref" href="../web-api/index.html">使用 ASP.NET Core 创建 Web API</a>。</li>
<li>使用 DI 将数据库上下文 (<code>TodoContext</code>) 注入到控制器中。 数据库上下文将在控制器中的每个 <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> 方法中使用。</li>
<li>如果数据库为空，则将名为 <code>Item1</code> 的项添加到数据库。 此代码位于构造函数中，因此在每次出现新 HTTP 请求时运行。 如果删除所有项，则构造函数会在下次调用 API 方法时再次创建 <code>Item1</code>。 因此删除可能看上去不起作用，不过实际上确实有效。</li>
</ul>
<h2 id="add-get-methods-21">添加 Get 方法 2.1</h2>
<p>若要提供检索待办事项的 API，请将以下方法添加到 <code>TodoController</code> 类中：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>这些方法实现两个 GET 终结点：</p>
<ul>
<li><code>GET /api/todo</code></li>
<li><code>GET /api/todo/{id}</code></li>
</ul>
<p>如果应用仍在运行，请停止它。 然后再次运行它以包括最新更改。</p>
<p>通过从浏览器调用两个终结点来测试应用。 例如：</p>
<ul>
<li><code>https://localhost:&lt;port&gt;/api/todo</code></li>
<li><code>https://localhost:&lt;port&gt;/api/todo/1</code></li>
</ul>
<p>以下 HTTP 响应通过调用 <code>GetTodoItems</code> 来生成：</p>
<pre><code class="lang-json">[
  {
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Item1&quot;,
    &quot;isComplete&quot;: false
  }
]
</code></pre>
<h2 id="routing-and-url-paths-21">路由和 URL 路径 2.1</h2>
<p><a href="xref:Microsoft.AspNetCore.Mvc.HttpGetAttribute"><code>[HttpGet]</code></a> 属性表示响应 HTTP GET 请求的方法。 每个方法的 URL 路径构造如下所示：</p>
<ul>
<li><p>在控制器的 <code>Route</code> 属性中以模板字符串开头：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
<li><p>将 <code>[controller]</code> 替换为控制器的名称，按照惯例，在控制器类名称中去掉“Controller”后缀。 对于此示例，控制器类名称为“Todo”控制器，因此控制器名称为“todo”。 ASP.NET Core <a class="xref" href="../mvc/controllers/routing.html">路由</a>不区分大小写。</p>
</li>
<li><p>如果 <code>[HttpGet]</code> 属性具有路由模板（例如 <code>[HttpGet(&quot;products&quot;)]</code>），则将它追加到路径。 此示例不使用模板。 有关详细信息，请参阅<a class="xref" href="../mvc/controllers/routing.html#attribute-routing-with-httpverb-attributes">使用 Http [Verb] 特性的特性路由</a>。</p>
</li>
</ul>
<p>在下面的 <code>GetTodoItem</code> 方法中，<code>&quot;{id}&quot;</code> 是待办事项的唯一标识符的占位符变量。 调用 <code>GetTodoItem</code> 时，URL 中 <code>&quot;{id}&quot;</code> 的值会在 <code>id</code> 参数中提供给方法。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="return-values-21">返回值 2.1</h2>
<p><code>GetTodoItems</code> 和 <code>GetTodoItem</code> 方法的返回类型是 <a class="xref" href="../web-api/action-return-types.html#actionresultt-type">ActionResult&lt;T&gt; 类型</a>。 ASP.NET Core 自动将对象序列化为 <a href="https://www.json.org/">JSON</a>，并将 JSON 写入响应消息的正文中。 在假设没有未经处理的异常的情况下，此返回类型的响应代码为 200。 未经处理的异常将转换为 5xx 错误。</p>
<p><code>ActionResult</code> 返回类型可以表示大范围的 HTTP 状态代码。 例如，<code>GetTodoItem</code> 可以返回两个不同的状态值：</p>
<ul>
<li>如果没有任何项与请求的 ID 匹配，则该方法将返回 404 &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.NotFound%2A&gt; 错误代码。</li>
<li>否则，此方法将返回具有 JSON 响应正文的 200。 返回 <code>item</code> 则产生 HTTP 200 响应。</li>
</ul>
<h2 id="test-the-gettodoitems-method-21">测试 GetTodoItems 方法 2.1</h2>
<p>本教程使用 Postman 测试 Web API。</p>
<ul>
<li>安装 <a href="https://www.getpostman.com/downloads/">Postman</a>。</li>
<li>启动 Web 应用。</li>
<li>启动 Postman。</li>
<li>禁用 <strong>SSL 证书验证</strong> 。</li>
</ul>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-18">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-18_visual-studio" role="tab" aria-controls="tabpanel_CeZOj-G++Q-18_visual-studio" data-tab="visual-studio" tabindex="0" aria-selected="true">Visual Studio</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-18_visual-studio-code+visual-studio-mac" role="tab" aria-controls="tabpanel_CeZOj-G++Q-18_visual-studio-code+visual-studio-mac" data-tab="visual-studio-code+visual-studio-mac" tabindex="-1">Visual Studio Code / Visual Studio for Mac</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-18_visual-studio" role="tabpanel" data-tab="visual-studio">

<ul>
<li>在“文件”&gt;“设置”（“常规” 选项卡）中，禁用“SSL 证书验证”。</li>
</ul>
</section>
<section id="tabpanel_CeZOj-G++Q-18_visual-studio-code+visual-studio-mac" role="tabpanel" data-tab="visual-studio-code+visual-studio-mac" aria-hidden="true" hidden="hidden">

<ul>
<li>在“Postman” &gt; “首选项”（“常规”选项卡）中，禁用“SSL 证书验证”   。 或者，选择扳手图标并选择“设置”，然后禁用“SSL 证书验证”。</li>
</ul>
</section>
</div>

<div class="WARNING">
<h5>Warning</h5>
<p>在测试控制器之后重新启用 SSL 证书验证。</p>
</div>
<ul>
<li>创建新请求。
<ul>
<li>将 HTTP 方法设置为“GET”。</li>
<li>将请求 URI 设置为 <code>https://localhost:&lt;port&gt;/api/todo</code>。 例如 <code>https://localhost:5001/api/todo</code>。</li>
</ul>
</li>
<li>在 Postman 中设置 <strong>Two pane view</strong> 。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p><img src="first-web-api/_static/2pv.png" alt="使用 Get 请求的 Postman"></p>
<h2 id="add-a-create-method-21">添加 Create 方法 2.1</h2>
<p>在 Controllers / TodoController.cs 中添加以下 <code>PostTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码是 HTTP POST 方法，如 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPostAttribute"><code>[HttpPost]</code></a> 属性所指示。 该方法从 HTTP 请求正文获取待办事项的值。</p>
<p><code>CreatedAtAction</code> 方法：</p>
<ul>
<li><p>如果成功，则返回 HTTP 201 状态代码。 HTTP 201 是在服务器上创建新资源的 HTTP POST 方法的标准响应。</p>
</li>
<li><p>将 <code>Location</code> 标头添加到响应。 <code>Location</code> 标头指定新建的待办事项的 URI。 有关详细信息，请参阅<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">创建的 10.2.2 201</a>。</p>
</li>
<li><p>引用 <code>GetTodoItem</code> 操作以创建 <code>Location</code> 标头的 URI。 C# <code>nameof</code> 关键字用于避免在 <code>CreatedAtAction</code> 调用中硬编码操作名称。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></li>
</ul>
<h3 id="test-the-posttodoitem-method-21">测试 PostTodoItem 方法 2.1</h3>
<ul>
<li><p>生成项目。</p>
</li>
<li><p>在 Postman 中，将 HTTP 方法设置为 <code>POST</code>。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItem</code>。 例如 <code>https://localhost:5001/api/TodoItem</code>。</p>
</li>
<li><p>选择“正文”选项卡。</p>
</li>
<li><p>选择“原始”单选按钮。</p>
</li>
<li><p>将类型设置为 <strong>JSON (application/json)</strong></p>
</li>
<li><p>在请求正文中，输入待办事项的 JSON：</p>
<pre><code class="lang-json">{
  &quot;name&quot;:&quot;walk dog&quot;,
  &quot;isComplete&quot;:true
}
</code></pre>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
<p><img src="first-web-api/_static/create.png" alt="使用创建请求的 Postman"></p>
<p>如果收到 405 不允许的方法错误，则可能是由于未在添加 <code>PostTodoItem</code> 方法之后编译项目。</p>
</li>
</ul>
<h3 id="test-the-location-header-uri-21">测试位置标头 URI 2.1</h3>
<ul>
<li><p>在 <strong>Headers</strong> 窗格中选择 <strong>Response</strong> 选项卡。</p>
</li>
<li><p>复制 <strong>Location</strong> 标头值：</p>
<p><img src="first-web-api/_static/pmc2.png" alt="Postman 控制台的“标头”选项卡"></p>
</li>
<li><p>将方法设置为“GET”。</p>
</li>
<li><p>将 URI 设置为 <code>https://localhost:&lt;port&gt;/api/TodoItems/2</code>。 例如 <code>https://localhost:5001/api/TodoItems/2</code>。</p>
</li>
<li><p>选择 <strong>Send</strong> 。</p>
</li>
</ul>
<h2 id="add-a-puttodoitem-method-21">添加 PutTodoItem 方法 2.1</h2>
<p>添加以下 <code>PutTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>PutTodoItem</code> 与 <code>PostTodoItem</code> 类似，但是使用的是 HTTP PUT。 响应是 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">204（无内容）</a>。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。 若要支持部分更新，请使用 <a href="xref:Microsoft.AspNetCore.Mvc.HttpPatchAttribute">HTTP PATCH</a>。</p>
<p>如果在调用 <code>PutTodoItem</code> 时出错，请调用 <code>GET</code> 以确保数据库中有项目。</p>
<h3 id="test-the-puttodoitem-method-21">测试 PutTodoItem 方法 2.1</h3>
<p>本示例使用内存内、数据库，每次启动应用时都必须对其进行初始化。 在进行 PUT 调用之前，数据库中必须有一个项。 调用 GET，以确保在调用 PUT 之前数据库中存在项。</p>
<p>更新 ID 为 1 的待办事项并将其名称设置为“feed fish”：</p>
<pre><code class="lang-json">  {
    &quot;id&quot;:1,
    &quot;name&quot;:&quot;feed fish&quot;,
    &quot;isComplete&quot;:true
  }
</code></pre>
<p>下图显示 Postman 更新：</p>
<p><img src="first-web-api/_static/pmcput.png" alt="显示 204（无内容）响应的 Postman 控制台"></p>
<h2 id="add-a-deletetodoitem-method-21">添加 DeleteTodoItem 方法 2.1</h2>
<p>添加以下 <code>DeleteTodoItem</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>DeleteTodoItem</code> 响应是 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">204（无内容）</a>。</p>
<h3 id="test-the-deletetodoitem-method-21">测试 DeleteTodoItem 方法 2.1</h3>
<p>使用 Postman 删除待办事项：</p>
<ul>
<li>将方法设置为 <code>DELETE</code>。</li>
<li>设置要删除的对象的 URI，例如 <code>https://localhost:5001/api/todo/1</code>。</li>
<li>选择 <strong>Send</strong> 。</li>
</ul>
<p>可通过示例应用删除所有项。 但如果删除最后一项，则在下次调用 API 时，模型类构造函数会创建一个新项。</p>
<h2 id="call-the-web-api-with-javascript-21">使用 JavaScript 调用 Web API 2.1</h2>
<p>在本部分中，将添加一个 HTML 页面，该页面使用 JavaScript 调用 Web API。 jQuery 可启动该请求。 JavaScript 会使用 Web API 响应的详细信息来更新页面。</p>
<p>通过下面突出显示的代码更新 Startup.cs，配置应用来<a href="xref:Microsoft.AspNetCore.Builder.StaticFileExtensions.UseStaticFiles%2A">提供静态文件</a>并<a href="xref:Microsoft.AspNetCore.Builder.DefaultFilesExtensions.UseDefaultFiles%2A">实现默认文件映射</a>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在项目目录中创建 wwwroot 文件夹。</p>
<p>将一个名为 index.html 的 HTML 文件添加到 wwwroot 目录 。 用以下标记替代其内容：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>将名为 site.js 的 JavaScript 文件添加到 wwwroot 目录 。 用以下代码替代其内容：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>可能需要更改 ASP.NET Core 项目的启动设置，以便对 HTML 页面进行本地测试：</p>
<ul>
<li>打开 Properties\launchSettings.json。</li>
<li>删除 <code>launchUrl</code> 以便在项目的默认文件 index.html 强制打开应用。</li>
</ul>
<p>此示例调用 Web API 的所有 CRUD 方法。 以下是 API 调用的说明。</p>
<h3 id="get-a-list-of-to-do-items-21">获取待办事项列表 2.1</h3>
<p>jQuery 将向 Web API 发送 HTTP GET 请求，该 API 返回表示待办事项的数组的 JSON。 如果请求成功，则调用 <code>success</code> 回调函数。 在该回调中使用待办事项信息更新 DOM。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="add-a-to-do-item-21">添加待办事项 2.1</h3>
<p>jQuery 发送 HTTP POST 请求，请求正文中包含待办事项。 将 <code>accepts</code> 和 <code>contentType</code> 选项设置为 <code>application/json</code>，以便指定接收和发送的媒体类型。 待办事项使用 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a> 转换为 JSON。 当 API 返回成功状态的代码时，将调用 <code>getData</code> 函数来更新 HTML 表。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="update-a-to-do-item-21">更新待办事项 2.1</h3>
<p>更新待办事项与添加类似。 <code>url</code> 更改为添加项的唯一标识符，并且 <code>type</code> 为 <code>PUT</code>。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="delete-a-to-do-item-21">删除待办事项 2.1</h3>
<p>若要删除待办事项，请将 AJAX 调用上的 <code>type</code> 设为 <code>DELETE</code> 并指定该项在 URL 中的唯一标识符。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<p><a name="auth"></a></p>
<h2 id="add-authentication-support-to-a-web-api-21">向 Web API 添加身份验证支持 2.1</h2>
<p>ASP.NET Core 标识将用户界面 (UI) 登录功能添加到 ASP.NET Core Web 应用。 若要保护 Web API 和 SPA，请使用以下项之一：</p>
<ul>
<li><a href="/azure/api-management/api-management-howto-protect-backend-with-aad">Azure Active Directory</a></li>
<li><a href="/azure/active-directory-b2c/active-directory-b2c-custom-rest-api-netfw">Azure Active Directory B2C</a> (Azure AD B2C)</li>
<li><a href="https://identityserver.io">IdentityServer4</a></li>
</ul>
<p>IdentityServer4 是适用于 ASP.NET Core 的 OpenID Connect 和 OAuth 2.0 框架。 IdentityServer4 支持以下安全功能：</p>
<ul>
<li>身份验证即服务 (AaaS)</li>
<li>跨多个应用程序类型的单一登录/注销 (SSO)</li>
<li>API 的访问控制</li>
<li>Federation Gateway</li>
</ul>
<p>有关详细信息，请参阅<a href="https://docs.identityserver.io/en/latest/index.html">欢迎使用 IdentityServer4</a>。</p>
<h2 id="additional-resources-21">其他资源 2.1</h2>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/tutorials/first-web-api/samples">查看或下载本教程的示例代码</a>。 请参阅<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>。</p>
<p>有关更多信息，请参见以下资源：</p>
<ul>
<li><a class="xref" href="../web-api/index.html">使用 ASP.NET Core 创建 Web API</a></li>
<li><a class="xref" href="web-api-help-pages-using-swagger.html">带有 Swagger/OpenAPI 的 ASP.NET Core Web API 帮助页</a></li>
<li><a class="xref" href="../data/ef-rp/intro.html">ASP.NET Core 中的 Razor Pages 和 Entity Framework Core - 第 1 个教程（共 8 个）</a></li>
<li><a class="xref" href="../mvc/controllers/routing.html">在 ASP.NET Core 中路由到控制器操作</a></li>
<li><a class="xref" href="../web-api/action-return-types.html">ASP.NET Core Web API 中控制器操作的返回类型</a></li>
<li><a class="xref" href="../host-and-deploy/azure-apps/index.html">将 ASP.NET Core 应用部署到 Azure 应用服务</a></li>
<li><a class="xref" href="../host-and-deploy/index.html">托管和部署 ASP.NET Core</a></li>
<li><a href="https://www.youtube.com/watch?v=TTkhEyGBfAk">本教程的 YouTube 版本</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
