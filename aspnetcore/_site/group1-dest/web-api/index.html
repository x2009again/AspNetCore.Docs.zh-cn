<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#20351;&#29992; ASP.NET Core &#21019;&#24314; Web API </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#20351;&#29992; ASP.NET Core &#21019;&#24314; Web API ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="web-api/index">
<h1 id="create-web-apis-with-aspnet-core">使用 ASP.NET Core 创建 Web API</h1>

<p>作者：<a href="https://github.com/scottaddie">Scott Addie</a> 和 <a href="https://github.com/tdykstra">Tom Dykstra</a></p>
<p>ASP.NET Core 支持使用 C# 创建 RESTful 服务，也称为 Web API。 若要处理请求，Web API 使用控制器。 Web API 中的 <em>控制器</em> 是派生自 <code>ControllerBase</code> 的类。 本文介绍了如何使用控制器处理 Web API 请求。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/web-api/index/samples">查看或下载示例代码</a>。 （<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">下载方法</a>）。</p>
<h2 id="controllerbase-class">ControllerBase 类</h2>
<p>Web API 包含一个或多个派生自 &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase&gt; 的控制器类。 Web API 项目模板提供了一个入门版控制器：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="&lt;= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<p>不要通过从 &lt;xref:Microsoft.AspNetCore.Mvc.Controller&gt; 类派生来创建 Web API 控制器。 <code>Controller</code> 派生自 <code>ControllerBase</code>，并添加对视图的支持，因此它用于处理 Web 页面，而不是 Web API 请求。 此规则有一个例外：如果打算为视图和 Web API 使用相同的控制器，则从 <code>Controller</code> 派生控制器。</p>
<p><code>ControllerBase</code> 类提供了很多用于处理 HTTP 请求的属性和方法。 例如，<code>ControllerBase.CreatedAtAction</code> 返回 201 状态代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面是 <code>ControllerBase</code> 提供的方法的更多示例。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.BadRequest%2A&gt;</td>
<td>返回 400 状态代码。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.NotFound%2A&gt;</td>
<td>返回 404 状态代码。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.PhysicalFile%2A&gt;</td>
<td>返回文件。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.TryUpdateModelAsync%2A&gt;</td>
<td>调用<a class="xref" href="../mvc/models/model-binding.html">模型绑定</a>。</td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.TryValidateModel%2A&gt;</td>
<td>调用<a class="xref" href="../mvc/models/validation.html">模型验证</a>。</td>
</tr>
</tbody>
</table>
<p>有关可用方法和属性的列表，请参阅 &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase&gt;。</p>
<h2 id="attributes">特性</h2>
<p>&lt;xref:Microsoft.AspNetCore.Mvc&gt; 命名空间提供可用于配置 Web API 控制器的行为和操作方法的属性。 下述示例使用属性来指定受支持的 HTTP 操作谓词和所有可返回的已知 HTTP 状态代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下是可用属性的更多示例。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.RouteAttribute"><code>[Route]</code></a></td>
<td>指定控制器或操作的 URL 模式。</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.BindAttribute"><code>[Bind]</code></a></td>
<td>指定要包含的前缀和属性，以进行模型绑定。</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.HttpGetAttribute"><code>[HttpGet]</code></a></td>
<td>标识支持 HTTP GET 操作谓词的操作。</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.ConsumesAttribute"><code>[Consumes]</code></a></td>
<td>指定某个操作接受的数据类型。</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.ProducesAttribute"><code>[Produces]</code></a></td>
<td>指定某个操作返回的数据类型。</td>
</tr>
</tbody>
</table>
<p>有关包含可用属性的列表，请参阅 &lt;xref:Microsoft.AspNetCore.Mvc&gt; 命名空间。</p>
<h2 id="apicontroller-attribute">ApiController 属性</h2>
<p><a href="xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute"><code>[ApiController]</code></a> 属性可应用于控制器类，以启用下述 API 特定的固定行为：</p>
<div range="&gt;= aspnetcore-2.2">
<ul>
<li><a href="#attribute-routing-requirement">属性路由要求</a></li>
<li><a href="#automatic-http-400-responses">自动 HTTP 400 响应</a></li>
<li><a href="#binding-source-parameter-inference">绑定源参数推理</a></li>
<li><a href="#multipartform-data-request-inference">Multipart/form-data 请求推理</a></li>
<li><a href="#problem-details-for-error-status-codes">错误状态代码的问题详细信息</a></li>
</ul>
<p>必须有<a class="xref" href="../mvc/compatibility-version.html">兼容性版本</a> 2.2 或更高版本，才能使用“错误状态代码的问题详细信息”功能。 必须有兼容性版本 2.1 或更高版本，才能使用其他功能。</p>
</div>
<ul>
<li><a href="#attribute-routing-requirement">属性路由要求</a></li>
<li><a href="#automatic-http-400-responses">自动 HTTP 400 响应</a></li>
<li><a href="#binding-source-parameter-inference">绑定源参数推理</a></li>
<li><a href="#multipartform-data-request-inference">Multipart/form-data 请求推理</a></li>
</ul>
<p>这些功能需要<a class="xref" href="../mvc/compatibility-version.html">兼容性版本</a>为 2.1 或更高版本。</p>
<h3 id="attribute-on-specific-controllers">特定控制器上的属性</h3>
<p><code>[ApiController]</code> 属性可应用于特定控制器，如项目模板中的以下示例所示：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="&lt;= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<h3 id="attribute-on-multiple-controllers">多个控制器上的属性</h3>
<p>在多个控制器上使用该属性的一种方法是创建通过 <code>[ApiController]</code> 属性批注的自定义基控制器类。 下述示例展示了自定义基类以及从其派生的控制器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="&lt;= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="&gt;= aspnetcore-2.2">
<h3 id="attribute-on-an-assembly">程序集上的属性</h3>
<p>如果将<a class="xref" href="../mvc/compatibility-version.html">兼容性版本</a>设置为 2.2 或更高版本，则 <code>[ApiController]</code> 属性可应用于程序集。 以这种方式进行注释，会将 web API 行为应用到程序集中的所有控制器。 无法针对单个控制器执行选择退出操作。 将程序集级别的属性应用于 <code>Startup</code> 类两侧的命名空间声明：</p>
<pre><code class="lang-csharp">[assembly: ApiController]
namespace WebApiSample
{
    public class Startup
    {
        ...
    }
}
</code></pre>
</div>
<h2 id="attribute-routing-requirement">特性路由要求</h2>
<p><code>[ApiController]</code> 属性使属性路由成为要求。 例如：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>不能通过由 <code>Startup.Configure</code> 中的 <code>UseEndpoints</code>、&lt;xref:Microsoft.AspNetCore.Builder.MvcApplicationBuilderExtensions.UseMvc%2A&gt; 或 &lt;xref:Microsoft.AspNetCore.Builder.MvcApplicationBuilderExtensions.UseMvcWithDefaultRoute%2A&gt; 定义的<a class="xref" href="../mvc/controllers/routing.html#conventional-routing">传统路由</a>访问操作。</p>
</div>
<div range="&lt;= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>不能通过 &lt;xref:Microsoft.AspNetCore.Builder.MvcApplicationBuilderExtensions.UseMvc%2A&gt; 定义的<a class="xref" href="../mvc/controllers/routing.html#conventional-routing">传统路由</a>或通过 <code>Startup.Configure</code> 中的 &lt;xref:Microsoft.AspNetCore.Builder.MvcApplicationBuilderExtensions.UseMvcWithDefaultRoute%2A&gt; 访问操作。</p>
</div>
<h2 id="automatic-http-400-responses">自动 HTTP 400 响应</h2>
<p><code>[ApiController]</code> 属性使模型验证错误自动触发 HTTP 400 响应。 因此，操作方法中不需要以下代码：</p>
<pre><code class="lang-csharp">if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}
</code></pre>
<p>ASP.NET Core MVC 使用 &lt;xref:Microsoft.AspNetCore.Mvc.Infrastructure.ModelStateInvalidFilter&gt; 操作筛选器来执行上述检查。</p>
<h3 id="default-badrequest-response">默认 BadRequest 响应</h3>
<p>使用 2.1 的兼容性版本时，HTTP 400 响应的默认响应类型为 &lt;xref:Microsoft.AspNetCore.Mvc.SerializableError&gt;。 下述请求正文是序列化类型的示例：</p>
<pre><code class="lang-json">{
  &quot;&quot;: [
    &quot;A non-empty request body is required.&quot;
  ]
}
</code></pre>
<div range="&gt;= aspnetcore-2.2">
<p>使用 2.2 或更高版本的兼容性版本时，HTTP 400 响应的默认响应类型为 &lt;xref:Microsoft.AspNetCore.Mvc.ValidationProblemDetails&gt;。 下述请求正文是序列化类型的示例：</p>
<pre><code class="lang-json">{
  &quot;type&quot;: &quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;,
  &quot;title&quot;: &quot;One or more validation errors occurred.&quot;,
  &quot;status&quot;: 400,
  &quot;traceId&quot;: &quot;|7fb5e16a-4c8f23bbfc974667.&quot;,
  &quot;errors&quot;: {
    &quot;&quot;: [
      &quot;A non-empty request body is required.&quot;
    ]
  }
}
</code></pre>
<p><code>ValidationProblemDetails</code> 类型：</p>
<ul>
<li>提供计算机可读的格式来指定 Web API 响应中的错误。</li>
<li>符合 <a href="https://tools.ietf.org/html/rfc7807">RFC 7807 规范</a>。</li>
</ul>
</div>
<p>要使自动和自定义响应保持一致，请调用 &lt;xref:Microsoft.AspNetCore.Mvc.ControllerBase.ValidationProblem%2A&gt; 方法，而不是 &lt;xref:System.Web.Http.ApiController.BadRequest%2A&gt;。 <code>ValidationProblem</code> 返回 &lt;xref:Microsoft.AspNetCore.Mvc.ValidationProblemDetails&gt; 对象以及自动响应。</p>
<h3 id="log-automatic-400-responses">记录自动 400 响应</h3>
<p>请参阅<a href="https://github.com/dotnet/AspNetCore.Docs/issues/12157">如何对模型验证错误记录自动 400 响应 (dotnet/AspNetCore.Docs#12157)</a>。</p>
<h3 id="disable-automatic-400-response">禁用自动 400 响应</h3>
<p>若要禁用自动 400 行为，请将 &lt;xref:Microsoft.AspNetCore.Mvc.ApiBehaviorOptions.SuppressModelStateInvalidFilter&gt; 属性设置为 <code>true</code>。 将以下突出显示的代码添加到 <code>Startup.ConfigureServices</code>：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.1">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<h2 id="binding-source-parameter-inference">绑定源参数推理</h2>
<p>绑定源特性定义可找到操作参数值的位置。 存在以下绑定源特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>绑定源</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.FromBodyAttribute"><code>[FromBody]</code></a></td>
<td>请求正文</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.FromFormAttribute"><code>[FromForm]</code></a></td>
<td>请求正文中的表单数据</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.FromHeaderAttribute"><code>[FromHeader]</code></a></td>
<td>请求标头</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.FromQueryAttribute"><code>[FromQuery]</code></a></td>
<td>请求查询字符串参数</td>
</tr>
<tr>
<td><a href="xref:Microsoft.AspNetCore.Mvc.FromRouteAttribute"><code>[FromRoute]</code></a></td>
<td>当前请求中的路由数据</td>
</tr>
<tr>
<td><a class="xref" href="../mvc/controllers/dependency-injection.html#action-injection-with-fromservices"><code>[FromServices]</code></a></td>
<td>作为操作参数插入的请求服务</td>
</tr>
</tbody>
</table>
<div class="WARNING">
<h5>Warning</h5>
<p>当值可能包含 <code>%2f</code>（即 <code>/</code>）时，请勿使用 <code>[FromRoute]</code>。 <code>%2f</code> 不会转换为 <code>/</code>（非转义形式）。 如果值可能包含 <code>%2f</code>，则使用 <code>[FromQuery]</code>。</p>
</div>
<p>如果没有 <code>[ApiController]</code> 属性或诸如 <code>[FromQuery]</code> 的绑定源属性，ASP.NET Core 运行时会尝试使用复杂对象模型绑定器。 复杂对象模型绑定器按已定义顺序从值提供程序拉取数据。</p>
<p>在下面的示例中，<code>[FromQuery]</code> 特性指示 <code>discontinuedOnly</code> 参数值在请求 URL 的查询字符串中提供：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>[ApiController]</code> 属性将推理规则应用于操作参数的默认数据源。 借助这些规则，无需通过将属性应用于操作参数来手动识别绑定源。 绑定源推理规则的行为如下：</p>
<ul>
<li><code>[FromBody]</code> 针对复杂类型参数进行推断。 <code>[FromBody]</code> 不适用于具有特殊含义的任何复杂的内置类型，如 &lt;xref:Microsoft.AspNetCore.Http.IFormCollection&gt; 和 &lt;xref:System.Threading.CancellationToken&gt;。 绑定源推理代码将忽略这些特殊类型。</li>
<li><code>[FromForm]</code> 针对 &lt;xref:Microsoft.AspNetCore.Http.IFormFile&gt; 和 &lt;xref:Microsoft.AspNetCore.Http.IFormFileCollection&gt; 类型的操作参数进行推断。 该特性不针对任何简单类型或用户定义类型进行推断。</li>
<li><code>[FromRoute]</code> 针对与路由模板中的参数相匹配的任何操作参数名称进行推断。 当多个路由与一个操作参数匹配时，任何路由值都视为 <code>[FromRoute]</code>。</li>
<li><code>[FromQuery]</code> 针对任何其他操作参数进行推断。</li>
</ul>
<h3 id="frombody-inference-notes">FromBody 推理说明</h3>
<p>对于简单类型（例如 <code>string</code> 或 <code>int</code>），推断不出 <code>[FromBody]</code>。 因此，如果需要该功能，对于简单类型，应使用 <code>[FromBody]</code> 属性。</p>
<p>当操作拥有多个从请求正文中绑定的参数时，将会引发异常。 例如，以下所有操作方法签名都会导致异常：</p>
<ul>
<li><p><code>[FromBody]</code> 对两者进行推断，因为它们是复杂类型。</p>
<pre><code class="lang-csharp">[HttpPost]
public IActionResult Action1(Product product, Order order)
</code></pre>
</li>
<li><p><code>[FromBody]</code> 对一个进行归属，对另一个进行推断，因为它是复杂类型。</p>
<pre><code class="lang-csharp">[HttpPost]
public IActionResult Action2(Product product, [FromBody] Order order)
</code></pre>
</li>
<li><p><code>[FromBody]</code> 对两者进行归属。</p>
<pre><code class="lang-csharp">[HttpPost]
public IActionResult Action3([FromBody] Product product, [FromBody] Order order)
</code></pre>
</li>
</ul>
<div range="= aspnetcore-2.1">
<div class="NOTE">
<h5>Note</h5>
<p>在 ASP.NET Core 2.1 中，集合类型参数（如列表和数组）被不正确地推断为 <code>[FromQuery]</code>。 若要从请求正文中绑定参数，应对这些参数使用 <code>[FromBody]</code> 属性。 此行为在 ASP.NET Core 2.2 或更高版本中得到了更正，其中集合类型参数默认被推断为从正文中绑定。</p>
</div>
</div>
<h3 id="disable-inference-rules">禁用推理规则</h3>
<p>若要禁用绑定源推理，请将 &lt;xref:Microsoft.AspNetCore.Mvc.ApiBehaviorOptions.SuppressInferBindingSourcesForParameters&gt; 设置为 <code>true</code>。 在 <code>Startup.ConfigureServices</code> 中添加下列代码：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.1">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<h2 id="multipartform-data-request-inference">Multipart/form-data 请求推理</h2>
<p>使用 <a href="xref:Microsoft.AspNetCore.Mvc.FromFormAttribute"><code>[FromForm]</code></a> 属性批注操作参数时，<code>[ApiController]</code> 属性应用推理规则。 将推断 <code>multipart/form-data</code> 请求内容类型。</p>
<p>要禁用默认行为，请在 <code>Startup.ConfigureServices</code> 中将 &lt;xref:Microsoft.AspNetCore.Mvc.ApiBehaviorOptions.SuppressConsumesConstraintForFormFileParameters&gt; 属性设置为 <code>true</code>：</p>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.1">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="&gt;= aspnetcore-2.2">
<h2 id="problem-details-for-error-status-codes">错误状态代码的问题详细信息</h2>
<p>当兼容性版本为 2.2 或更高版本时，MVC 会将错误结果（状态代码为 400 或更高的结果）转换为状态代码为 &lt;xref:Microsoft.AspNetCore.Mvc.ProblemDetails&gt; 的结果。 <code>ProblemDetails</code> 类型基于 <a href="https://tools.ietf.org/html/rfc7807">RFC 7807 规范</a>，用于提供 HTTP 响应中计算机可读的错误详细信息。</p>
<p>考虑在控制器操作中使用以下代码：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>NotFound</code> 方法会生成带 <code>ProblemDetails</code> 正文的 HTTP 404 状态代码。 例如：</p>
<pre><code class="lang-json">{
  type: &quot;https://tools.ietf.org/html/rfc7231#section-6.5.4&quot;,
  title: &quot;Not Found&quot;,
  status: 404,
  traceId: &quot;0HLHLV31KRN83:00000001&quot;
}
</code></pre>
<h3 id="disable-problemdetails-response">禁用 ProblemDetails 响应</h3>
<p>当 &lt;xref:Microsoft.AspNetCore.Mvc.ApiBehaviorOptions.SuppressMapClientErrors%2A&gt; 属性设置为 <code>true</code> 时，会禁止自动创建错误状态代码的 <code>ProblemDetails</code>。 在 <code>Startup.ConfigureServices</code> 中添加下列代码：</p>
</div>
<div range="&gt;= aspnetcore-3.0">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<div range="= aspnetcore-2.2">
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div></div>
<p><a name="consumes"></a></p>
<h2 id="define-supported-request-content-types-with-the-consumes-attribute">使用 [Consumes] 属性定义支持的请求内容类型</h2>
<p>默认情况下，操作支持所有可用的请求内容类型。 例如，如果应用配置为同时支持 JSON 和 XML <a class="xref" href="../mvc/models/model-binding.html#input-formatters">输入格式化程序</a>，那么操作支持多种内容类型，其中包括 <code>application/json</code> 和 <code>application/xml</code>。</p>
<p>使用 <a href="xref:Microsoft.AspNetCore.Mvc.ConsumesAttribute">[Consumes]</a> 属性，操作可以限制支持的请求内容类型。 将 <code>[Consumes]</code> 属性应用于操作或控制器，同时指定一个或多个内容类型：</p>
<pre><code class="lang-csharp">[HttpPost]
[Consumes(&quot;application/xml&quot;)]
public IActionResult CreateProduct(Product product)
</code></pre>
<p>在上面的代码中，<code>CreateProduct</code> 操作指定内容类型 <code>application/xml</code>。 路由到此操作的请求必须指定 <code>application/xml</code> 的 <code>Content-Type</code> 头。 如果请求未指定 <code>application/xml</code> 的 <code>Content-Type</code> 头，会生成 <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/415">415 不支持的媒体类型</a>响应。</p>
<p>使用 <code>[Consumes]</code> 属性，操作可以通过应用类型约束，根据传入请求的内容类型来影响它的选择。 请看下面的示例：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，<code>ConsumesController</code> 配置为处理发送到 <code>https://localhost:5001/api/Consumes</code> URL 的请求。 控制器的两个操作（<code>PostJson</code> 和 <code>PostForm</code>）都使用相同的 URL 处理 POST 请求。 如果 <code>[Consumes]</code> 属性不应用类型约束，则会抛出不明确匹配异常。</p>
<p><code>[Consumes]</code> 属性应用于两个操作。 <code>PostJson</code> 操作处理使用 <code>application/json</code> 的 <code>Content-Type</code> 头发送的请求。 <code>PostForm</code> 操作处理使用 <code>application/x-www-form-urlencoded</code> 的 <code>Content-Type</code> 头发送的请求。</p>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="action-return-types.html">ASP.NET Core Web API 中控制器操作的返回类型</a></li>
<li><a class="xref" href="handle-errors.html">处理 ASP.NET Core Web API 中的错误</a></li>
<li><a class="xref" href="advanced/custom-formatters.html">ASP.NET Core Web API 中的自定义格式化程序</a></li>
<li><a class="xref" href="advanced/formatting.html">设置 ASP.NET Core Web API 中响应数据的格式</a></li>
<li><a class="xref" href="../tutorials/web-api-help-pages-using-swagger.html">带有 Swagger/OpenAPI 的 ASP.NET Core Web API 帮助页</a></li>
<li><a class="xref" href="../mvc/controllers/routing.html">在 ASP.NET Core 中路由到控制器操作</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
