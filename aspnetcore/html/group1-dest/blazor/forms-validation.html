<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core Blazor &#31383;&#20307;&#21644;&#39564;&#35777; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core Blazor &#31383;&#20307;&#21644;&#39564;&#35777; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="blazor/forms-validation">
<h1 id="aspnet-core-no-locblazor-forms-and-validation">ASP.NET Core Blazor 窗体和验证</h1>

<p>作者：<a href="https://github.com/danroth27">Daniel Roth</a>、<a href="https://remibou.github.io/">Rémi Bourgarel</a> 和 <a href="https://github.com/guardrex">Luke Latham</a></p>
<p>在 Blazor 中，使用<a class="xref" href="../mvc/models/validation.html">数据注释</a>支持窗体和验证。</p>
<p>下面的 <code>ExampleModel</code> 类型使用数据注释定义验证逻辑：</p>
<pre><code class="lang-csharp">using System.ComponentModel.DataAnnotations;

public class ExampleModel
{
    [Required]
    [StringLength(10, ErrorMessage = &quot;Name is too long.&quot;)]
    public string Name { get; set; }
}
</code></pre>
<p>窗体是使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 组件定义的。 以下窗体展示了典型的元素、组件和 Razor 代码：</p>
<pre><code class="lang-razor">&lt;EditForm Model=&quot;@exampleModel&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    &lt;InputText id=&quot;name&quot; @bind-Value=&quot;exampleModel.Name&quot; /&gt;

    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    private ExampleModel exampleModel = new ExampleModel();

    private void HandleValidSubmit()
    {
        ...
    }
}
</code></pre>
<p>在上面的示例中：</p>
<ul>
<li>该窗体使用 <code>ExampleModel</code> 类型中定义的验证来验证 <code>name</code> 字段中的用户输入。 该模型在组件的 <code>@code</code> 块中创建，并保存在私有字段 (<code>exampleModel</code>) 中。 该字段分配给 <code>&lt;EditForm&gt;</code> 元素的 <code>Model</code> 属性。</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt; 组件的 <code>@bind-Value</code> 进行以下绑定：
<ul>
<li>将模型属性 (<code>exampleModel.Name</code>) 绑定到 &lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt; 组件的 <code>Value</code> 属性。 有关属性绑定的详细信息，请参阅 <a class="xref" href="components/data-binding.html#parent-to-child-binding-with-component-parameters">ASP.NET Core Blazor 数据绑定</a>。</li>
<li>将更改事件委托绑定到 &lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt; 组件的 <code>ValueChanged</code> 属性。</li>
</ul>
</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; <a href="#validator-components">验证器组件</a>使用数据注释附加验证支持。</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件汇总验证消息。</li>
<li>窗体成功提交（通过验证）时触发 <code>HandleValidSubmit</code>。</li>
</ul>
<h2 id="built-in-forms-components">内置窗体组件</h2>
<p>可使用一组内置的组件来接收和验证用户输入。 当更改输入和提交窗体时，将验证输入。 下表显示了可用的输入组件。</p>
<div range="&gt;= aspnetcore-5.0">
<table>
<thead>
<tr>
<th>输入组件</th>
<th>呈现为…</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputCheckbox&gt;</td>
<td><code>&lt;input type=&quot;checkbox&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputDate%601&gt;</td>
<td><code>&lt;input type=&quot;date&quot;&gt;</code></td>
</tr>
<tr>
<td><a class="xref" href="file-uploads.html"><code>InputFile</code></a></td>
<td><code>&lt;input type=&quot;file&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputNumber%601&gt;</td>
<td><code>&lt;input type=&quot;number&quot;&gt;</code></td>
</tr>
<tr>
<td><a href="#radio-buttons"><code>InputRadio</code></a></td>
<td><code>&lt;input type=&quot;radio&quot;&gt;</code></td>
</tr>
<tr>
<td><a href="#radio-buttons"><code>InputRadioGroup</code></a></td>
<td><code>&lt;input type=&quot;radio&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputSelect%601&gt;</td>
<td><code>&lt;select&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt;</td>
<td><code>&lt;input&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputTextArea&gt;</td>
<td><code>&lt;textarea&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<div range="&lt; aspnetcore-5.0">
<table>
<thead>
<tr>
<th>输入组件</th>
<th>呈现为…</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputCheckbox&gt;</td>
<td><code>&lt;input type=&quot;checkbox&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputDate%601&gt;</td>
<td><code>&lt;input type=&quot;date&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputNumber%601&gt;</td>
<td><code>&lt;input type=&quot;number&quot;&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputSelect%601&gt;</td>
<td><code>&lt;select&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt;</td>
<td><code>&lt;input&gt;</code></td>
</tr>
<tr>
<td>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputTextArea&gt;</td>
<td><code>&lt;textarea&gt;</code></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p><code>InputRadio</code> 和 <code>InputRadioGroup</code> 组件在 ASP.NET Core 5.0 或更高版本中可用。 有关详细信息，请选择本文的 5.0 或更高版本。</p>
</div>
</div>
<p>所有输入组件（包括 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt;）都支持任意属性。 与某个组件参数不匹配的所有属性都将添加到呈现的 HTML 元素中。</p>
<p>输入组件为验证字段何时更改（包括更新字段 CSS 类以反映字段状态）提供默认行为。 某些组件包含有用的分析逻辑。 例如，&lt;xref:Microsoft.AspNetCore.Components.Forms.InputDate%601&gt; 和 &lt;xref:Microsoft.AspNetCore.Components.Forms.InputNumber%601&gt; 通过将无法分析的值注册为验证错误，以恰当的方式来处理无法分析的值。 可接受 Null 值的类型也支持目标字段的为 Null 性（例如，<code>int?</code>）。</p>
<p>下面的 <code>Starship</code> 类型使用比之前的 <code>ExampleModel</code> 更大的属性和数据注释集来定义验证逻辑：</p>
<pre><code class="lang-csharp">using System;
using System.ComponentModel.DataAnnotations;

public class Starship
{
    [Required]
    [StringLength(16, ErrorMessage = &quot;Identifier too long (16 character limit).&quot;)]
    public string Identifier { get; set; }

    public string Description { get; set; }

    [Required]
    public string Classification { get; set; }

    [Range(1, 100000, ErrorMessage = &quot;Accommodation invalid (1-100000).&quot;)]
    public int MaximumAccommodation { get; set; }

    [Required]
    [Range(typeof(bool), &quot;true&quot;, &quot;true&quot;, 
        ErrorMessage = &quot;This form disallows unapproved ships.&quot;)]
    public bool IsValidatedDesign { get; set; }

    [Required]
    public DateTime ProductionDate { get; set; }
}
</code></pre>
<p>在上面的示例中，<code>Description</code> 是可选的，因为不存在任何数据注释。</p>
<p>以下窗体使用 <code>Starship</code> 模型中定义的验证来验证用户输入：</p>
<pre><code class="lang-razor">@page &quot;/FormsValidation&quot;

&lt;h1&gt;Starfleet Starship Database&lt;/h1&gt;

&lt;h2&gt;New Ship Entry Form&lt;/h2&gt;

&lt;EditForm Model=&quot;@starship&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    &lt;p&gt;
        &lt;label&gt;
            Identifier:
            &lt;InputText @bind-Value=&quot;starship.Identifier&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Description (optional):
            &lt;InputTextArea @bind-Value=&quot;starship.Description&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Primary Classification:
            &lt;InputSelect @bind-Value=&quot;starship.Classification&quot;&gt;
                &lt;option value=&quot;&quot;&gt;Select classification ...&lt;/option&gt;
                &lt;option value=&quot;Exploration&quot;&gt;Exploration&lt;/option&gt;
                &lt;option value=&quot;Diplomacy&quot;&gt;Diplomacy&lt;/option&gt;
                &lt;option value=&quot;Defense&quot;&gt;Defense&lt;/option&gt;
            &lt;/InputSelect&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Maximum Accommodation:
            &lt;InputNumber @bind-Value=&quot;starship.MaximumAccommodation&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Engineering Approval:
            &lt;InputCheckbox @bind-Value=&quot;starship.IsValidatedDesign&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Production Date:
            &lt;InputDate @bind-Value=&quot;starship.ProductionDate&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;

    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;

    &lt;p&gt;
        &lt;a href=&quot;http://www.startrek.com/&quot;&gt;Star Trek&lt;/a&gt;, 
        &amp;copy;1966-2019 CBS Studios, Inc. and 
        &lt;a href=&quot;https://www.paramount.com&quot;&gt;Paramount Pictures&lt;/a&gt;
    &lt;/p&gt;
&lt;/EditForm&gt;

@code {
    private Starship starship = new Starship() { ProductionDate = DateTime.UtcNow };

    private void HandleValidSubmit()
    {
        ...
    }
}
</code></pre>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 创建一个 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 作为<a class="xref" href="components/cascading-values-and-parameters.html">级联值</a>来跟踪有关编辑过程的元数据，其中包括已修改的字段和当前的验证消息。</p>
<p>将 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 或 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.Model?displayProperty=nameWithType&gt; 分配给 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 。 不支持同时分配两者，会生成运行时错误。</p>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 为有效和无效的窗体提交提供便捷的事件：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.OnValidSubmit&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.OnInvalidSubmit&gt;</li>
</ul>
<p>通过 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.OnSubmit&gt;，使用自定义代码触发验证并检查字段值。</p>
<p>如下示例中：</p>
<ul>
<li>选择 <code>Submit</code> 按钮时，执行 <code>HandleSubmit</code> 方法。</li>
<li>通过调用 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext.Validate%2A?displayProperty=nameWithType&gt; 验证窗体。</li>
<li>根据验证结果执行其他代码。 将业务逻辑放在分配给 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.OnSubmit&gt; 的方法中。</li>
</ul>
<pre><code class="lang-razor">&lt;EditForm EditContext=&quot;@editContext&quot; OnSubmit=&quot;@HandleSubmit&quot;&gt;

    ...

    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    private Starship starship = new Starship() { ProductionDate = DateTime.UtcNow };
    private EditContext editContext;

    protected override void OnInitialized()
    {
        editContext = new EditContext(starship);
    }

    private async Task HandleSubmit()
    {
        var isValid = editContext.Validate();

        if (isValid)
        {
            ...
        }
        else
        {
            ...
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Framework API 不存在，无法直接从 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 清除验证消息。 因此，通常建议不要在窗体中将验证消息添加到新的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessageStore&gt;。 若要管理验证消息，请将<a href="#validator-components">验证器组件</a>与<a href="#business-logic-validation">业务逻辑验证代码</a>一起使用，如本文所述。</p>
</div>
<div range="&gt;= aspnetcore-5.0">
<h2 id="display-name-support">显示名称支持</h2>
<p><em>本部分应用于 .NET 5 候选发布 1 (RC1) 或更高版本中的 ASP.NET Core。</em></p>
<p>以下内置组件支持带有 <code>DisplayName</code> 参数的显示名称：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputDate%601&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputNumber%601&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Components.Forms.InputSelect%601&gt;</li>
</ul>
<p>在下面的 <code>InputDate</code> 组件示例中：</p>
<ul>
<li>显示名称 (<code>DisplayName</code>) 设置为 <code>birthday</code>。</li>
<li>该组件作为 <code>DateTime</code> 类型绑定到 <code>BirthDate</code> 属性。</li>
</ul>
<pre><code class="lang-razor">&lt;InputDate @bind-Value=&quot;@BirthDate&quot; DisplayName=&quot;birthday&quot; /&gt;

@code {
    public DateTime BirthDate { get; set; }
}
</code></pre>
<p>如果用户不提供日期值，则验证错误将显示为：</p>
<pre><code>The birthday must be a date.
</code></pre>
</div>
<h2 id="validator-components">验证器组件</h2>
<p>验证器组件通过管理窗体的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessageStore&gt; 来支持窗体验证。</p>
<p>Blazor 框架提供了 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件，以将验证支持附加到基于<a class="xref" href="../mvc/models/validation.html#validation-attributes">验证属性（数据批注）</a>的窗体。 创建自定义验证器组件，以处理同一页上不同窗体或不同窗体处理步骤上相同窗体的验证消息，例如客户端验证，然后是服务器端验证。 本文的以下部分将使用本部分 <code>CustomValidator</code> 中所示的验证器组件示例：</p>
<ul>
<li><a href="#business-logic-validation">业务逻辑验证</a></li>
<li><a href="#server-validation">服务器验证</a></li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>在许多情况下，可使用自定义数据注释验证属性来代替自定义验证器组件。 应用于窗体模型的自定义属性使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件激活。 当与服务器端验证一起使用时，应用于模型的所有自定义属性都必须可在服务器上执行。 有关详细信息，请参阅 <a class="xref" href="../mvc/models/validation.html#alternatives-to-built-in-attributes">ASP.NET Core MVC 中的模型验证</a>。</p>
</div>
<p>从 &lt;xref:Microsoft.AspNetCore.Components.ComponentBase&gt; 创建验证器组件：</p>
<ul>
<li>窗体的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 是组件的<a class="xref" href="components/cascading-values-and-parameters.html">级联参数</a>。</li>
<li>初始化验证器组件时，将创建一个新的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessageStore&gt; 来维护当前的窗体错误列表。</li>
<li>当窗体组件中的开发人员代码调用 <code>DisplayErrors</code> 方法时，消息存储接收错误。 这些错误会传递到 <a href="xref:System.Collections.Generic.Dictionary%602"><code>Dictionary&lt;string, List&lt;string&gt;&gt;</code></a> 中的 <code>DisplayErrors</code> 方法。 在字典中，键是具有一个或多个错误的窗体字段的名称。 值为错误列表。</li>
<li>发生以下任一情况时，将清除消息：
<ul>
<li>引发 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 事件时，会在 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext.OnValidationRequested&gt; 上请求验证。 所有错误都将被清除。</li>
<li>引发 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext.OnFieldChanged&gt; 事件时，窗体中的字段会更改。 仅清除字段的错误。</li>
<li><code>ClearErrors</code> 方法由开发人员代码调用。 所有错误都将被清除。</li>
</ul>
</li>
</ul>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;

namespace BlazorSample.Client
{
    public class CustomValidator : ComponentBase
    {
        private ValidationMessageStore messageStore;

        [CascadingParameter]
        private EditContext CurrentEditContext { get; set; }

        protected override void OnInitialized()
        {
            if (CurrentEditContext == null)
            {
                throw new InvalidOperationException(
                    $&quot;{nameof(CustomValidator)} requires a cascading &quot; +
                    $&quot;parameter of type {nameof(EditContext)}. &quot; +
                    $&quot;For example, you can use {nameof(CustomValidator)} &quot; +
                    $&quot;inside an {nameof(EditForm)}.&quot;);
            }

            messageStore = new ValidationMessageStore(CurrentEditContext);

            CurrentEditContext.OnValidationRequested += (s, e) =&gt; 
                messageStore.Clear();
            CurrentEditContext.OnFieldChanged += (s, e) =&gt; 
                messageStore.Clear(e.FieldIdentifier);
        }

        public void DisplayErrors(Dictionary&lt;string, List&lt;string&gt;&gt; errors)
        {
            foreach (var err in errors)
            {
                messageStore.Add(CurrentEditContext.Field(err.Key), err.Value);
            }

            CurrentEditContext.NotifyValidationStateChanged();
        }

        public void ClearErrors()
        {
            messageStore.Clear();
            CurrentEditContext.NotifyValidationStateChanged();
        }
    }
}
</code></pre>
<h2 id="business-logic-validation">业务逻辑验证</h2>
<p>可通过接收字典中的窗体错误的<a href="#validator-components">验证器组件</a>完成业务逻辑验证。</p>
<p>如下示例中：</p>
<ul>
<li>使用本文的<a href="#validator-components">验证器组件</a>部分的 <code>CustomValidator</code> 组件。</li>
<li>如果用户选择 <code>Defense</code> 交付分类 (<code>Classification</code>)，则验证需要交付说明 (<code>Description</code>) 的值。</li>
</ul>
<p>在组件中设置验证消息时，它们将被添加到验证器的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessageStore&gt;，并在 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 中显示：</p>
<pre><code class="lang-razor">@page &quot;/FormsValidation&quot;

&lt;h1&gt;Starfleet Starship Database&lt;/h1&gt;

&lt;h2&gt;New Ship Entry Form&lt;/h2&gt;

&lt;EditForm Model=&quot;@starship&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;CustomValidator @ref=&quot;customValidator&quot; /&gt;
    &lt;ValidationSummary /&gt;

    ...

&lt;/EditForm&gt;

@code {
    private CustomValidator customValidator;
    private Starship starship = new Starship() { ProductionDate = DateTime.UtcNow };

    private void HandleValidSubmit()
    {
        customValidator.ClearErrors();

        var errors = new Dictionary&lt;string, List&lt;string&gt;&gt;();

        if (starship.Classification == &quot;Defense&quot; &amp;&amp;
                string.IsNullOrEmpty(starship.Description))
        {
            errors.Add(nameof(starship.Description),
                new List&lt;string&gt;() { &quot;For a 'Defense' ship classification, &quot; +
                &quot;'Description' is required.&quot; });
        }

        if (errors.Count() &gt; 0)
        {
            customValidator.DisplayErrors(errors);
        }
        else
        {
            // Process the form
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>除了使用<a href="#validator-components">验证组件</a>，还可使用数据注释验证属性。 应用于窗体模型的自定义属性使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件激活。 当与服务器端验证一起使用时，该属性都必须可在服务器上执行。 有关详细信息，请参阅 <a class="xref" href="../mvc/models/validation.html#alternatives-to-built-in-attributes">ASP.NET Core MVC 中的模型验证</a>。</p>
</div>
<h2 id="server-validation">服务器验证</h2>
<p>服务器验证可通过服务器<a href="#validator-components">验证器组件</a>完成：</p>
<ul>
<li>使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件处理窗体中的客户端验证。</li>
<li>当窗体传递客户端验证（调用 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.OnValidSubmit&gt;）时，将 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext.Model?displayProperty=nameWithType&gt; 发送到后端服务器 API 进行窗体处理。</li>
<li>处理服务器上的模型验证。</li>
<li>服务器 API 包括开发人员提供的内置框架数据注释验证和自定义验证逻辑。 如果验证在服务器上传递，则处理窗格并发送回成功状态代码（200 - 正常）。 如果验证失败，则返回失败状态代码（400 - 错误请求）和字段验证错误。</li>
<li>成功时禁用窗体，否则显示错误。</li>
</ul>
<p>下面的示例基于：</p>
<ul>
<li>托管的 Blazor 解决方案，由 <a class="xref" href="hosting-models.html#blazor-webassembly">Blazor 托管项目模板</a>创建。 此示例可与<a class="xref" href="security/webassembly/index.html#implementation-guidance">安全性和 Identity 文档</a>中介绍的任何安全托管 Blazor 方案一起使用。</li>
<li>前面的<a href="#built-in-forms-components">内置窗体组件</a>部分中的 Starfleet Starship 数据库窗体示例。</li>
<li>Blazor 框架的 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件。</li>
<li><a href="#validator-components">验证器组件</a>部分中显示的 <code>CustomValidator</code> 组件。</li>
</ul>
<p>在下面的示例中，如果用户选择 <code>Defense</code> 交付分类 (<code>Classification</code>)，则服务器 API 将验证是否为交付说明 (<code>Description</code>) 提供了值。</p>
<p>将 <code>Starship</code> 模型放入解决方案的 <code>Shared</code> 项目中，以便客户端和服务器应用都可使用该模型。 模型需要数据注释，因此请将 <a href="https://www.nuget.org/packages/System.ComponentModel.Annotations"><code>System.ComponentModel.Annotations</code></a> 的包引用添加到 <code>Shared</code> 项目的项目文件中：</p>
<pre><code class="lang-xml">&lt;ItemGroup&gt;
  &lt;PackageReference Include=&quot;System.ComponentModel.Annotations&quot; Version=&quot;{VERSION}&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>若要确定包的最新非预览版本，请前往 <a href="https://www.nuget.org/packages/System.ComponentModel.Annotations">NuGet.org</a> 查看包版本历史记录。</p>
<p>在服务器 API 项目中，添加控制器来处理 Starship 验证请求 (<code>Controllers/StarshipValidation.cs</code>) 并返回失败的验证消息：</p>
<pre><code class="lang-csharp">using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using BlazorSample.Shared;

namespace BlazorSample.Server.Controllers
{
    [Authorize]
    [ApiController]
    [Route(&quot;[controller]&quot;)]
    public class StarshipValidationController : ControllerBase
    {
        private readonly ILogger&lt;StarshipValidationController&gt; logger;

        public StarshipValidationController(
            ILogger&lt;StarshipValidationController&gt; logger)
        {
            this.logger = logger;
        }

        [HttpPost]
        public async Task&lt;IActionResult&gt; Post(Starship starship)
        {
            try
            {
                if (starship.Classification == &quot;Defense&quot; &amp;&amp; 
                    string.IsNullOrEmpty(starship.Description))
                {
                    ModelState.AddModelError(nameof(starship.Description),
                        &quot;For a 'Defense' ship &quot; +
                        &quot;classification, 'Description' is required.&quot;);
                }
                else
                {
                    // Process the form asynchronously
                    // async ...

                    return Ok(ModelState);
                }
            }
            catch (Exception ex)
            {
                logger.LogError(&quot;Validation Error: {Message}&quot;, ex.Message);
            }

            return BadRequest(ModelState);
        }
    }
}
</code></pre>
<p>当服务器上发生模型绑定验证错误时，<a class="xref" href="../web-api/index.html"><code>ApiController</code></a> (&lt;xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute&gt;) 通常通过 &lt;xref:Microsoft.AspNetCore.Mvc.ValidationProblemDetails&gt; 返回<a class="xref" href="../web-api/index.html#default-badrequest-response">默认错误请求响应</a>。 如下例所示，当“Starfleet Starship 数据库”窗格的部分字段未提交且窗格未通过验证时，响应包含的数据不仅仅是验证错误：</p>
<pre><code class="lang-json">{
  &quot;title&quot;: &quot;One or more validation errors occurred.&quot;,
  &quot;status&quot;: 400,
  &quot;errors&quot;: {
    &quot;Identifier&quot;: [&quot;The Identifier field is required.&quot;],
    &quot;Classification&quot;: [&quot;The Classification field is required.&quot;],
    &quot;IsValidatedDesign&quot;: [&quot;This form disallows unapproved ships.&quot;],
    &quot;MaximumAccommodation&quot;: [&quot;Accommodation invalid (1-100000).&quot;]
  }
}
</code></pre>
<p>如果服务器 API 返回前面的默认 JSON 响应，则客户端可分析响应以获取 <code>errors</code> 节点的子节点。 但是，分析文件不方便。 分析 JSON 需要调用 &lt;xref:System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync%2A&gt; 后的其他代码，以生成窗体验证错误处理的 <a href="xref:System.Collections.Generic.Dictionary%602"><code>Dictionary&lt;string, List&lt;string&gt;&gt;</code></a> 错误。 理想情况下，服务器 API 应只返回验证错误：</p>
<pre><code class="lang-json">{
  &quot;Identifier&quot;: [&quot;The Identifier field is required.&quot;],
  &quot;Classification&quot;: [&quot;The Classification field is required.&quot;],
  &quot;IsValidatedDesign&quot;: [&quot;This form disallows unapproved ships.&quot;],
  &quot;MaximumAccommodation&quot;: [&quot;Accommodation invalid (1-100000).&quot;]
}
</code></pre>
<p>若要修改服务器 API 的响应，使其仅返回验证错误，请更改在 <code>Startup.ConfigureServices</code> 中注释了 &lt;xref:Microsoft.AspNetCore.Mvc.ApiControllerAttribute&gt; 的操作上调用的委托。 对于 API 终结点 (<code>/StarshipValidation</code>)，返回具有 &lt;xref:Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary&gt; 的 &lt;xref:Microsoft.AspNetCore.Mvc.BadRequestObjectResult&gt;。 对于任何其他 API 终结点，通过使用新的 &lt;xref:Microsoft.AspNetCore.Mvc.ValidationProblemDetails&gt; 返回对象结果来保留默认行为：</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

...

services.AddControllersWithViews()
    .ConfigureApiBehaviorOptions(options =&gt;
    {
        options.InvalidModelStateResponseFactory = context =&gt;
        {
            if (context.HttpContext.Request.Path == &quot;/StarshipValidation&quot;)
            {
                return new BadRequestObjectResult(context.ModelState);
            }
            else
            {
                return new BadRequestObjectResult(
                    new ValidationProblemDetails(context.ModelState));
            }
        };
    });
</code></pre>
<p>有关详细信息，请参阅 <a class="xref" href="../web-api/handle-errors.html#validation-failure-error-response">处理 ASP.NET Core Web API 中的错误</a>。</p>
<p>在客户端项目中，添加<a href="#validator-components">验证器组件</a>部分中显示的验证器组件。</p>
<p>在客户端项目中，更新“Starfleet Starship 数据库”窗体，以显示服务器验证错误和 <code>CustomValidator</code> 组件的帮助。 当服务器 API 返回验证消息时，这些消息将添加到 <code>CustomValidator</code> 组件的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessageStore&gt;。 此错误在窗体的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 中提供，以供窗体的 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 显示：</p>
<pre><code class="lang-razor">@page &quot;/FormValidation&quot;
@using System.Net
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using Microsoft.Extensions.Logging
@using BlazorSample.Shared
@attribute [Authorize]
@inject HttpClient Http
@inject ILogger&lt;FormValidation&gt; Logger

&lt;h1&gt;Starfleet Starship Database&lt;/h1&gt;

&lt;h2&gt;New Ship Entry Form&lt;/h2&gt;

&lt;EditForm Model=&quot;@starship&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;CustomValidator @ref=&quot;customValidator&quot; /&gt;
    &lt;ValidationSummary /&gt;

    &lt;p&gt;
        &lt;label&gt;
            Identifier:
            &lt;InputText @bind-Value=&quot;starship.Identifier&quot; disabled=&quot;@disabled&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Description (optional):
            &lt;InputTextArea @bind-Value=&quot;starship.Description&quot; 
                disabled=&quot;@disabled&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Primary Classification:
            &lt;InputSelect @bind-Value=&quot;starship.Classification&quot; disabled=&quot;@disabled&quot;&gt;
                &lt;option value=&quot;&quot;&gt;Select classification ...&lt;/option&gt;
                &lt;option value=&quot;Exploration&quot;&gt;Exploration&lt;/option&gt;
                &lt;option value=&quot;Diplomacy&quot;&gt;Diplomacy&lt;/option&gt;
                &lt;option value=&quot;Defense&quot;&gt;Defense&lt;/option&gt;
            &lt;/InputSelect&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Maximum Accommodation:
            &lt;InputNumber @bind-Value=&quot;starship.MaximumAccommodation&quot; 
                disabled=&quot;@disabled&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Engineering Approval:
            &lt;InputCheckbox @bind-Value=&quot;starship.IsValidatedDesign&quot; 
                disabled=&quot;@disabled&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label&gt;
            Production Date:
            &lt;InputDate @bind-Value=&quot;starship.ProductionDate&quot; disabled=&quot;@disabled&quot; /&gt;
        &lt;/label&gt;
    &lt;/p&gt;

    &lt;button type=&quot;submit&quot; disabled=&quot;@disabled&quot;&gt;Submit&lt;/button&gt;

    &lt;p style=&quot;@messageStyles&quot;&gt;
        @message
    &lt;/p&gt;

    &lt;p&gt;
        &lt;a href=&quot;http://www.startrek.com/&quot;&gt;Star Trek&lt;/a&gt;,
        &amp;copy;1966-2019 CBS Studios, Inc. and
        &lt;a href=&quot;https://www.paramount.com&quot;&gt;Paramount Pictures&lt;/a&gt;
    &lt;/p&gt;
&lt;/EditForm&gt;

@code {
    private bool disabled;
    private string message;
    private string messageStyles = &quot;visibility:hidden&quot;;
    private CustomValidator customValidator;
    private Starship starship = new Starship() { ProductionDate = DateTime.UtcNow };

    private async Task HandleValidSubmit(EditContext editContext)
    {
        customValidator.ClearErrors();

        try
        {
            var response = await Http.PostAsJsonAsync&lt;Starship&gt;(
                &quot;StarshipValidation&quot;, (Starship)editContext.Model);

            var errors = await response.Content
                .ReadFromJsonAsync&lt;Dictionary&lt;string, List&lt;string&gt;&gt;&gt;();

            if (response.StatusCode == HttpStatusCode.BadRequest &amp;&amp; 
                errors.Count() &gt; 0)
            {
                customValidator.DisplayErrors(errors);
            }
            else if (!response.IsSuccessStatusCode)
            {
                throw new HttpRequestException(
                    $&quot;Validation failed. Status Code: {response.StatusCode}&quot;);
            }
            else
            {
                disabled = true;
                messageStyles = &quot;color:green&quot;;
                message = &quot;The form has been processed.&quot;;
            }
        }
        catch (AccessTokenNotAvailableException ex)
        {
            ex.Redirect();
        }
        catch (Exception ex)
        {
            Logger.LogError(&quot;Form processing error: {Message}&quot;, ex.Message);
            disabled = true;
            messageStyles = &quot;color:red&quot;;
            message = &quot;There was an error processing the form.&quot;;
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>除了<a href="#validator-components">验证组件</a>，还可使用数据注释验证属性。 应用于窗体模型的自定义属性使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件激活。 当与服务器端验证一起使用时，该属性都必须可在服务器上执行。 有关详细信息，请参阅 <a class="xref" href="../mvc/models/validation.html#alternatives-to-built-in-attributes">ASP.NET Core MVC 中的模型验证</a>。</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>本部分中的服务器端验证方法适用于本文档集中的所有 Blazor WebAssembly 托管解决方案示例：</p>
<ul>
<li><a class="xref" href="security/webassembly/hosted-with-azure-active-directory.html">Azure Active Directory (AAD)</a></li>
<li><a class="xref" href="security/webassembly/hosted-with-azure-active-directory-b2c.html">Azure Active Directory (AAD) B2C</a></li>
<li><a class="xref" href="security/webassembly/hosted-with-identity-server.html">Identity 服务器</a></li>
</ul>
</div>
<h2 id="inputtext-based-on-the-input-event">基于输入事件的 InputText</h2>
<p>使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt; 组件创建一个使用 <code>input</code> 事件而不是 <code>change</code> 事件的自定义组件。</p>
<p>在下面的示例中，<code>CustomInputText</code> 组件继承框架的 <code>InputText</code> 组件，并将事件绑定 (&lt;xref:Microsoft.AspNetCore.Components.EventCallbackFactoryBinderExtensions.CreateBinder%2A&gt;) 设置为 <code>oninput</code> 事件。</p>
<p><code>Shared/CustomInputText.razor</code>:</p>
<pre><code class="lang-razor">@inherits InputText

&lt;input 
    @attributes=&quot;AdditionalAttributes&quot; 
    class=&quot;@CssClass&quot; 
    value=&quot;@CurrentValue&quot;
    @oninput=&quot;EventCallback.Factory.CreateBinder&lt;string&gt;(
         this, __value =&gt; CurrentValueAsString = __value, 
         CurrentValueAsString)&quot; /&gt;
</code></pre>
<p><code>CustomInputText</code> 组件可在任何使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.InputText&gt; 的位置使用：</p>
<p><code>Pages/TestForm.razor</code>:</p>
<pre><code class="lang-razor">@page &quot;/testform&quot;
@using System.ComponentModel.DataAnnotations;

&lt;EditForm Model=&quot;@exampleModel&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    &lt;CustomInputText @bind-Value=&quot;exampleModel.Name&quot; /&gt;

    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

&lt;p&gt;
    CurrentValue: @exampleModel.Name
&lt;/p&gt;

@code {
    private ExampleModel exampleModel = new ExampleModel();

    private void HandleValidSubmit()
    {
        ...
    }

    public class ExampleModel
    {
        [Required]
        [StringLength(10, ErrorMessage = &quot;Name is too long.&quot;)]
        public string Name { get; set; }
    }
}
</code></pre>
<h2 id="radio-buttons">单选按钮</h2>
<div range="&gt;= aspnetcore-5.0">
<p>结合使用 <code>InputRadio</code> 组件和 <code>InputRadioGroup</code> 组件以创建单选按钮组。 在下面的示例中，将属性添加到<a href="#built-in-forms-components">内置窗体组件</a>部分所述的 <code>Starship</code> 模型中：</p>
<pre><code class="lang-csharp">[Required]
[Range(typeof(Manufacturer), nameof(Manufacturer.SpaceX), 
    nameof(Manufacturer.VirginGalactic), ErrorMessage = &quot;Pick a manufacturer.&quot;)]
public Manufacturer Manufacturer { get; set; } = Manufacturer.Unknown;

[Required, EnumDataType(typeof(Color))]
public Color? Color { get; set; } = null;

[Required, EnumDataType(typeof(Engine))]
public Engine? Engine { get; set; } = null;
</code></pre>
<p>将以下 <code>enums</code> 添加到应用。 创建一个新文件来保存 <code>enums</code>，或将 <code>enums</code> 添加到 <code>Starship.cs</code> 文件中。 使 <code>Starship</code> 模型和 Starfleet Starship 数据库窗体都可访问 <code>enums</code>：</p>
<pre><code class="lang-csharp">public enum Manufacturer { SpaceX, NASA, ULA, Virgin, Unknown }
public enum Color { ImperialRed, SpacecruiserGreen, StarshipBlue, VoyagerOrange }
public enum Engine { Ion, Plasma, Fusion, Warp }
</code></pre>
<p>更新<a href="#built-in-forms-components">内置窗体组件</a>部分所述的 Starfleet Starship 数据库窗体。 添加组件以生成：</p>
<ul>
<li>用于选择飞船制造商的单选按钮组。</li>
<li>用于选择飞船颜色和引擎的嵌套式单选按钮组。</li>
</ul>
<pre><code class="lang-razor">&lt;p&gt;
    &lt;InputRadioGroup @bind-Value=&quot;starship.Manufacturer&quot;&gt;
        Manufacturer:
        &lt;br&gt;
        @foreach (var manufacturer in (Manufacturer[])Enum
            .GetValues(typeof(Manufacturer)))
        {
            &lt;InputRadio Value=&quot;manufacturer&quot; /&gt;
            @manufacturer
            &lt;br&gt;
        }
    &lt;/InputRadioGroup&gt;
&lt;/p&gt;

&lt;p&gt;
    Pick one color and one engine:
    &lt;InputRadioGroup Name=&quot;engine&quot; @bind-Value=&quot;starship.Engine&quot;&gt;
        &lt;InputRadioGroup Name=&quot;color&quot; @bind-Value=&quot;starship.Color&quot;&gt;
            &lt;InputRadio Name=&quot;color&quot; Value=&quot;Color.ImperialRed&quot; /&gt;Imperial Red&lt;br&gt;
            &lt;InputRadio Name=&quot;engine&quot; Value=&quot;Engine.Ion&quot; /&gt;Ion&lt;br&gt;
            &lt;InputRadio Name=&quot;color&quot; Value=&quot;Color.SpacecruiserGreen&quot; /&gt;
                Spacecruiser Green&lt;br&gt;
            &lt;InputRadio Name=&quot;engine&quot; Value=&quot;Engine.Plasma&quot; /&gt;Plasma&lt;br&gt;
            &lt;InputRadio Name=&quot;color&quot; Value=&quot;Color.StarshipBlue&quot; /&gt;Starship Blue&lt;br&gt;
            &lt;InputRadio Name=&quot;engine&quot; Value=&quot;Engine.Fusion&quot; /&gt;Fusion&lt;br&gt;
            &lt;InputRadio Name=&quot;color&quot; Value=&quot;Color.VoyagerOrange&quot; /&gt;
                Voyager Orange&lt;br&gt;
            &lt;InputRadio Name=&quot;engine&quot; Value=&quot;Engine.Warp&quot; /&gt;Warp&lt;br&gt;
        &lt;/InputRadioGroup&gt;
    &lt;/InputRadioGroup&gt;
&lt;/p&gt;
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>如果省略 <code>Name</code>，则 <code>InputRadio</code> 组件按其最新上级进行分组。</p>
</div>
</div>
<div range="&lt; aspnetcore-5.0">
<p>使用窗体中的单选按钮时，数据绑定的处理方式与其他元素不同，因为单选按钮是作为一个组进行计算的。 每个单选按钮的值是固定的，但单选按钮组的值是所选单选按钮的值。 以下示例介绍如何：</p>
<ul>
<li>处理单选按钮组的数据绑定。</li>
<li>使用自定义 <code>InputRadio</code> 组件支持验证。</li>
</ul>
<pre><code class="lang-razor">@using System.Globalization
@typeparam TValue
@inherits InputBase&lt;TValue&gt;

&lt;input @attributes=&quot;AdditionalAttributes&quot; type=&quot;radio&quot; value=&quot;@SelectedValue&quot; 
       checked=&quot;@(SelectedValue.Equals(Value))&quot; @onchange=&quot;OnChange&quot; /&gt;

@code {
    [Parameter]
    public TValue SelectedValue { get; set; }

    private void OnChange(ChangeEventArgs args)
    {
        CurrentValueAsString = args.Value.ToString();
    }

    protected override bool TryParseValueFromString(string value, 
        out TValue result, out string errorMessage)
    {
        var success = BindConverter.TryConvertTo&lt;TValue&gt;(
            value, CultureInfo.CurrentCulture, out var parsedValue);
        if (success)
        {
            result = parsedValue;
            errorMessage = null;

            return true;
        }
        else
        {
            result = default;
            errorMessage = $&quot;{FieldIdentifier.FieldName} field isn't valid.&quot;;

            return false;
        }
    }
}
</code></pre>
<p>以下 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 使用前面的 <code>InputRadio</code> 组件来获取和验证用户的评级：</p>
<pre><code class="lang-razor">@page &quot;/RadioButtonExample&quot;
@using System.ComponentModel.DataAnnotations

&lt;h1&gt;Radio Button Group Test&lt;/h1&gt;

&lt;EditForm Model=&quot;@model&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    @for (int i = 1; i &lt;= 5; i++)
    {
        &lt;label&gt;
            &lt;InputRadio name=&quot;rate&quot; SelectedValue=&quot;i&quot; @bind-Value=&quot;model.Rating&quot; /&gt;
            @i
        &lt;/label&gt;
    }

    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

&lt;p&gt;You chose: @model.Rating&lt;/p&gt;

@code {
    private Model model = new Model();

    private void HandleValidSubmit()
    {
        ...
    }

    public class Model
    {
        [Range(1, 5)]
        public int Rating { get; set; }
    }
}
</code></pre>
</div>
<h2 id="binding-select-element-options-to-c-object-null-values">将 <code>&lt;select&gt;</code> 元素选项绑定到 C# 对象 <code>null</code> 值</h2>
<p>由于以下原因，没有将 <code>&lt;select&gt;</code> 元素选项值表示为 C# 对象 <code>null</code> 值的合理方法：</p>
<ul>
<li>HTML 属性不能具有 <code>null</code> 值。 HTML 中最接近的 <code>null</code> 等效项是 <code>&lt;option&gt;</code> 元素中缺少 HTML <code>value</code> 属性。</li>
<li>选择没有 <code>value</code> 属性的 <code>&lt;option&gt;</code> 时，浏览器会将值视为该 <code>&lt;option&gt;</code> 的元素的 文本内容。</li>
</ul>
<p>Blazor 框架不会尝试取消默认行为，因为这会涉及以下操作：</p>
<ul>
<li>在框架中创建一系列特殊的解决办法。</li>
<li>对当前框架行为进行重大更改。</li>
</ul>
<div range="&gt;= aspnetcore-5.0">
<p>HTML 中最合理的 <code>null</code> 等效项是空字符串 <code>value</code>。 Blazor 框架处理 <code>null</code> 到空字符串之间的转换，以便双向绑定到 <code>&lt;select&gt;</code> 的值。</p>
</div>
<div range="&lt; aspnetcore-5.0">
<p>尝试双向绑定到 <code>&lt;select&gt;</code> 的值时，Blazor 框架不会自动处理 <code>null</code> 到空字符串之间的转换。 有关详细信息，请参阅<a href="https://github.com/dotnet/aspnetcore/pull/23221">修复 <code>&lt;select&gt;</code> 到 null 值的绑定 (dotnet/aspnetcore #23221)</a>。</p>
</div>
<h2 id="validation-support">验证支持</h2>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件使用数据注释将验证支持附加到级联的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt;。 使用数据注释启用对验证的支持需要此显式手势。 若要使用不同于数据注释的验证系统，请用自定义实现替换 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt;。 可在以下参考源中检查 ASP.NET Core 的实现<a href="https://github.com/dotnet/AspNetCore/blob/master/src/Components/Forms/src/DataAnnotationsValidator.cs"><code>DataAnnotationsValidator</code></a>/<a href="https://github.com/dotnet/AspNetCore/blob/master/src/Components/Forms/src/EditContextDataAnnotationsExtensions.cs"><code>AddDataAnnotationsValidation</code></a>： 前面的参考源链接提供了来自存储库 <code>master</code> 分支的代码，该分支表示产品单元当前对 ASP.NET Core 下一版本的开发。 若要为其他版本选择分支，请使用 GitHub 分支选择器（例如 <code>release/3.1</code>）。</p>
<p>Blazor 执行两种类型的验证：</p>
<ul>
<li>当用户从某个字段中跳出时，将执行 <em>字段验证</em> 。 在字段验证期间，&lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件将报告的所有验证结果与该字段相关联。</li>
<li>当用户提交窗体时，将执行 <em>模型验证</em> 。 在模型验证期间，&lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件尝试根据验证结果报告的成员名称来确定字段。 与单个成员无关的验证结果将与模型而不是字段相关联。</li>
</ul>
<h3 id="validation-summary-and-validation-message-components">验证摘要和验证消息组件</h3>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件用于汇总所有验证消息，这与<a class="xref" href="../mvc/views/working-with-forms.html#the-validation-summary-tag-helper">验证摘要标记帮助程序</a>类似：</p>
<pre><code class="lang-razor">&lt;ValidationSummary /&gt;
</code></pre>
<p>使用 <code>Model</code> 参数输出特定模型的验证消息：</p>
<pre><code class="lang-razor">&lt;ValidationSummary Model=&quot;@starship&quot; /&gt;
</code></pre>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessage%601&gt; 组件用于显示特定字段的验证消息，这与<a class="xref" href="../mvc/views/working-with-forms.html#the-validation-message-tag-helper">验证消息标记帮助程序</a>类似。 使用 <code>For</code> 属性和一个为模型属性命名的 Lambda 表达式来指定要验证的字段：</p>
<pre><code class="lang-razor">&lt;ValidationMessage For=&quot;@(() =&gt; starship.MaximumAccommodation)&quot; /&gt;
</code></pre>
<p>&lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationMessage%601&gt; 和 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件支持任意属性。 与某个组件参数不匹配的所有属性都将添加到生成的 <code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code> 元素中。</p>
<p>在应用的样式表（<code>wwwroot/css/app.css</code> 或 <code>wwwroot/css/site.css</code>）中控制验证消息的样式。 默认 <code>validation-message</code> 类将验证消息的文本颜色设置为红色：</p>
<pre><code class="lang-css">.validation-message {
    color: red;
}
</code></pre>
<h3 id="custom-validation-attributes">自定义验证属性</h3>
<p>当使用<a class="xref" href="../mvc/models/validation.html#custom-attributes">自定义验证属性</a>时，为确保验证结果与字段正确关联，请在创建 &lt;xref:System.ComponentModel.DataAnnotations.ValidationResult&gt; 时传递验证上下文的 &lt;xref:System.ComponentModel.DataAnnotations.ValidationContext.MemberName&gt;：</p>
<pre><code class="lang-csharp">using System;
using System.ComponentModel.DataAnnotations;

private class CustomValidator : ValidationAttribute
{
    protected override ValidationResult IsValid(object value, 
        ValidationContext validationContext)
    {
        ...

        return new ValidationResult(&quot;Validation message to user.&quot;,
            new[] { validationContext.MemberName });
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>&lt;xref:System.ComponentModel.DataAnnotations.ValidationContext.GetService%2A?displayProperty=nameWithType&gt; 为 <code>null</code>。 不支持在 <code>IsValid</code> 方法中注入用于验证的服务。</p>
</div>
<div range="&gt;= aspnetcore-5.0">
<h2 id="custom-validation-class-attributes">自定义验证类属性</h2>
<p>与 CSS 框架集成时，自定义验证类名称非常有用，例如<a href="https://getbootstrap.com/">启动</a>。 若要指定自定义验证类名称，请创建从 <code>FieldCssClassProvider</code> 派生的类，并在 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 实例上设置该类：</p>
<pre><code class="lang-csharp">var editContext = new EditContext(model);
editContext.SetFieldCssClassProvider(new MyFieldClassProvider());

...

private class MyFieldClassProvider : FieldCssClassProvider
{
    public override string GetFieldCssClass(EditContext editContext, 
        in FieldIdentifier fieldIdentifier)
    {
        var isValid = !editContext.GetValidationMessages(fieldIdentifier).Any();

        return isValid ? &quot;good field&quot; : &quot;bad field&quot;;
    }
}
</code></pre>
</div>
<h3 id="no-locblazor-data-annotations-validation-package">Blazor 数据注释验证包</h3>
<p><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation"><code>Microsoft.AspNetCore.Components.DataAnnotations.Validation</code></a> 是使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件填补验证经验空白的包。 该包目前处于 <em>试验阶段</em> 。</p>
<div class="NOTE">
<h5>Note</h5>
<p><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation"><code>Microsoft.AspNetCore.Components.DataAnnotations.Validation</code></a> 包具有最新版本的候选发布 (<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation">Nuget.org</a>)。此时继续使用实验性候选发布包。 在将来的版本中，包的程序集可能会移动到框架或运行时。 请观看<a href="https://github.com/aspnet/Announcements">公告 GitHub 存储库</a>、<a href="https://github.com/dotnet/aspnetcore">dotnet/aspnetcore GitHub 存储库</a>或本主题部分，获取进一步更新。</p>
</div>
<h3 id="compareproperty-attribute">[CompareProperty] 属性</h3>
<p>&lt;xref:System.ComponentModel.DataAnnotations.CompareAttribute&gt; 不适用于 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 组件，因为它不会将验证结果与特定成员关联。 这可能会导致字段级验证的行为与提交时整个模型的验证行为不一致。 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation"><code>Microsoft.AspNetCore.Components.DataAnnotations.Validation</code></a> 试验性包引入了一个附加的验证属性 <code>ComparePropertyAttribute</code>，它可以克服这些限制。 在 Blazor 应用中，<code>[CompareProperty]</code> 可直接替代 <a href="xref:System.ComponentModel.DataAnnotations.CompareAttribute"><code>[Compare]</code></a> 特性。</p>
<h3 id="nested-models-collection-types-and-complex-types">嵌套模型、集合类型和复杂类型</h3>
<p>Blazor 支持结合使用数据注释和内置的 &lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 来验证窗体输入。 但是，&lt;xref:Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator&gt; 仅验证绑定到窗体的模型的顶级属性（不包括集合类型或复杂类型的属性）。</p>
<p>若要验证绑定模型的整个对象图（包括集合类型和复杂类型的属性），请使用试验性 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation"><code>Microsoft.AspNetCore.Components.DataAnnotations.Validation</code></a> 包提供的 <code>ObjectGraphDataAnnotationsValidator</code>：</p>
<pre><code class="lang-razor">&lt;EditForm Model=&quot;@model&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;ObjectGraphDataAnnotationsValidator /&gt;
    ...
&lt;/EditForm&gt;
</code></pre>
<p>用 <code>[ValidateComplexType]</code> 注释模型属性。 在以下模型类中，<code>ShipDescription</code> 类包含附加数据注释，用于在将模型绑定到窗体时进行验证：</p>
<p><code>Starship.cs</code>:</p>
<pre><code class="lang-csharp">using System;
using System.ComponentModel.DataAnnotations;

public class Starship
{
    ...

    [ValidateComplexType]
    public ShipDescription ShipDescription { get; set; } = 
        new ShipDescription();

    ...
}
</code></pre>
<p><code>ShipDescription.cs</code>:</p>
<pre><code class="lang-csharp">using System;
using System.ComponentModel.DataAnnotations;

public class ShipDescription
{
    [Required]
    [StringLength(40, ErrorMessage = &quot;Description too long (40 char).&quot;)]
    public string ShortDescription { get; set; }

    [Required]
    [StringLength(240, ErrorMessage = &quot;Description too long (240 char).&quot;)]
    public string LongDescription { get; set; }
}
</code></pre>
<h3 id="enable-the-submit-button-based-on-form-validation">基于窗体验证启用提交按钮</h3>
<p>若要基于窗体验证启用和禁用提交按钮，请执行以下操作：</p>
<ul>
<li>使用窗体的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 在初始化组件时分配模型。</li>
<li>在上下文的 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext.OnFieldChanged&gt; 回调中验证窗体，以启用和禁用提交按钮。</li>
<li>解除挂接 <code>Dispose</code> 方法中的事件处理程序。 有关详细信息，请参阅 <a class="xref" href="components/lifecycle.html#component-disposal-with-idisposable">ASP.NET Core Blazor 生命周期</a>。</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt; 时，也不要将 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.Model&gt; 分配给 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt;。</p>
</div>
<pre><code class="lang-razor">@implements IDisposable

&lt;EditForm EditContext=&quot;@editContext&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;

    ...

    &lt;button type=&quot;submit&quot; disabled=&quot;@formInvalid&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    private Starship starship = new Starship() { ProductionDate = DateTime.UtcNow };
    private bool formInvalid = true;
    private EditContext editContext;

    protected override void OnInitialized()
    {
        editContext = new EditContext(starship);
        editContext.OnFieldChanged += HandleFieldChanged;
    }

    private void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        formInvalid = !editContext.Validate();
        StateHasChanged();
    }

    public void Dispose()
    {
        editContext.OnFieldChanged -= HandleFieldChanged;
    }
}
</code></pre>
<p>在上面的示例中，如果满足以下条件，则将 <code>formInvalid</code> 设置为 <code>false</code>：</p>
<ul>
<li>窗体已预加载有效的默认值。</li>
<li>你希望在加载窗体时启用提交按钮。</li>
</ul>
<p>上述方法的副作用是在用户与任何一个字段进行交互后，&lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件都会填充无效的字段。 可通过以下方式之一解决此情况：</p>
<ul>
<li>不在窗体上使用 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件。</li>
<li>选择提交按钮时，使 &lt;xref:Microsoft.AspNetCore.Components.Forms.ValidationSummary&gt; 组件可见（例如，在 <code>HandleValidSubmit</code> 方法中）。</li>
</ul>
<pre><code class="lang-razor">&lt;EditForm EditContext=&quot;@editContext&quot; OnValidSubmit=&quot;@HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary style=&quot;@displaySummary&quot; /&gt;

    ...

    &lt;button type=&quot;submit&quot; disabled=&quot;@formInvalid&quot;&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    private string displaySummary = &quot;display:none&quot;;

    ...

    private void HandleValidSubmit()
    {
        displaySummary = &quot;display:block&quot;;
    }
}
</code></pre>
<h2 id="troubleshoot">疑难解答</h2>
<blockquote>
<p>InvalidOperationException：EditForm 需要 Model 参数或 EditContext 参数，但不能同时需要这两个参数。</p>
</blockquote>
<p>确认 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm&gt; 是否有 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.Model&gt; 或 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditContext&gt;。 不要对同一窗体使用这两者。</p>
<p>在将 &lt;xref:Microsoft.AspNetCore.Components.Forms.EditForm.Model&gt; 分配到窗体时，请确认模型类型是否已实例化，如下面的示例所示：</p>
<pre><code class="lang-csharp">private ExampleModel exampleModel = new ExampleModel();
</code></pre>
<div range="&gt;= aspnetcore-5.0">
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="file-uploads.html">ASP.NET Core Blazor 文件上传</a></li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
