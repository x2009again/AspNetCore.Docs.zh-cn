<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core &#20013;&#30340;&#36873;&#39033;&#27169;&#24335; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core &#20013;&#30340;&#36873;&#39033;&#27169;&#24335; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="fundamentals/configuration/options">
<h1 id="options-pattern-in-aspnet-core">ASP.NET Core 中的选项模式</h1>

<div range="&gt;= aspnetcore-3.0">
<p>作者：<a href="https://twitter.com/serpent5">Kirk Larkin</a> 和 <a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>。</p>
<p>选项模式使用类来提供对相关设置组的强类型访问。 当<a class="xref" href="index.html">配置设置</a>由方案隔离到单独的类时，应用遵循两个重要软件工程原则：</p>
<ul>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#encapsulation">接口分隔原则 (ISP) 或封装</a>：依赖于配置设置的方案（类）仅依赖于其使用的配置设置。</li>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns">关注点分离</a>：应用的不同部件的设置不彼此依赖或相互耦合。</li>
</ul>
<p>选项还提供验证配置数据的机制。 有关详细信息，请参阅<a href="#options-validation">选项验证</a>部分。</p>
<p>本主题介绍 ASP.NET Core 中的选项模式。 若要了解如何在控制台应用中使用选项模式，请参阅 <a href="/dotnet/core/extensions/options">.NET 中的选项模式</a>。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/configuration/options/samples">查看或下载示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<p><a name="optpat"></a></p>
<h2 id="bind-hierarchical-configuration">绑定分层配置</h2>
<p>读取相关配置值的首选方法是使用<a class="xref" href="options.html">选项模式</a>。 例如，若要读取以下配置值，请执行以下操作：</p>
<pre><code class="lang-json">  &quot;Position&quot;: {
    &quot;Title&quot;: &quot;Editor&quot;,
    &quot;Name&quot;: &quot;Joe Smith&quot;
  }
</code></pre>
<p>创建以下 <code>PositionOptions</code> 类：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>选项类：</p>
<ul>
<li>必须是包含公共无参数构造函数的非抽象类。</li>
<li>类型的所有公共读写属性都已绑定。</li>
<li>不会绑定字段。 在上面的代码中，<code>Position</code> 未绑定。 由于使用了 <code>Position</code> 属性，因此在将类绑定到配置提供程序时，不需要在应用中对字符串 <code>&quot;Position&quot;</code> 进行硬编码。</li>
</ul>
<p>下面的代码：</p>
<ul>
<li>调用 <a href="xref:Microsoft.Extensions.Configuration.ConfigurationBinder.Bind*">ConfigurationBinder.Bind</a> 将 <code>PositionOptions</code> 类绑定到 <code>Position</code> 部分。</li>
<li>显示 <code>Position</code> 配置数据。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，默认读取在应用启动后对 JSON 配置文件所做的更改。</p>
<p><a href="xref:Microsoft.Extensions.Configuration.ConfigurationBinder.Get*"><code>ConfigurationBinder.Get&lt;T&gt;</code></a> 绑定并返回指定的类型。 使用 <code>ConfigurationBinder.Get&lt;T&gt;</code> 可能比使用 <code>ConfigurationBinder.Bind</code> 更方便。 下面的代码演示如何将 <code>ConfigurationBinder.Get&lt;T&gt;</code> 与 <code>PositionOptions</code> 类配合使用：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，默认读取在应用启动后对 JSON 配置文件所做的更改。</p>
<p>使用选项模式时的替代方法是绑定 <code>Position</code> 部分并将它添加到<a class="xref" href="../dependency-injection.html">依赖项注入服务容器</a>。 在以下代码中，<code>PositionOptions</code> 已通过 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsConfigurationServiceCollectionExtensions.Configure*&gt; 被添加到了服务容器并已绑定到了配置：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>通过使用前面的代码，以下代码将读取位置选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，不会读取在应用启动后对 JSON 配置文件所做的更改。 若要读取在应用启动后的更改，请使用 <a class="xref" href="options.html#ios">IOptionsSnapshot</a>。</p>

<p><a name="oi"></a></p>
<h2 id="options-interfaces">选项接口</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt;:</p>
<ul>
<li>不支持：
<ul>
<li>在应用启动后读取配置数据。</li>
<li><a href="#named">命名选项</a></li>
</ul>
</li>
<li>注册为<a class="xref" href="../dependency-injection.html#singleton">单一实例</a>且可以注入到任何<a class="xref" href="../dependency-injection.html#service-lifetimes">服务生存期</a>。</li>
</ul>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;:</p>
<ul>
<li>在每次请求时应重新计算选项的方案中有用。 有关详细信息，请参阅<a href="#ios">使用 IOptionsSnapshot 读取已更新的数据</a>。</li>
<li>注册为<a class="xref" href="../dependency-injection.html#scoped">范围内</a>，因此无法注入到单一实例服务。</li>
<li>支持<a href="#named">命名选项</a></li>
</ul>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt;:</p>
<ul>
<li>用于检索选项并管理 <code>TOptions</code> 实例的选项通知。</li>
<li>注册为<a class="xref" href="../dependency-injection.html#singleton">单一实例</a>且可以注入到任何<a class="xref" href="../dependency-injection.html#service-lifetimes">服务生存期</a>。</li>
<li>支持：
<ul>
<li>更改通知</li>
<li><a href="#named-options-support-with-iconfigurenamedoptions">命名选项</a></li>
<li><a href="#ios">可重载配置</a></li>
<li>选择性选项失效 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt;)</li>
</ul>
</li>
</ul>
<p><a href="#options-post-configuration">后期配置</a>方案允许在进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后设置或更改选项。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 负责新建选项实例。 它具有单个 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory`1.Create*&gt; 方法。 默认实现采用所有已注册 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 并首先运行所有配置，然后才进行后期配置。 它区分 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 且仅调用适当的接口。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 由 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 用于缓存 <code>TOptions</code> 实例。 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 可使监视器中的选项实例无效，以便重新计算值 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryRemove*&gt;)。 可以通过 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryAdd*&gt; 手动引入值。 在应按需重新创建所有命名实例时使用 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.Clear*&gt; 方法。</p>
<p><a name="ios"></a></p>
<h2 id="use-ioptionssnapshot-to-read-updated-data">使用 IOptionsSnapshot 读取已更新的数据</h2>
<p>通过使用 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;，针对请求生存期访问和缓存选项时，每个请求都会计算一次选项。 当使用支持读取已更新的配置值的配置提供程序时，将在应用启动后读取对配置所做的更改。</p>
<p><code>IOptionsMonitor</code> 和 <code>IOptionsSnapshot</code> 之间的区别在于：</p>
<ul>
<li><code>IOptionsMonitor</code> 是一种<a class="xref" href="../dependency-injection.html#singleton">单一示例服务</a>，可随时检索当前选项值，这在单一实例依赖项中尤其有用。</li>
<li><code>IOptionsSnapshot</code> 是一种<a class="xref" href="../dependency-injection.html#scoped">作用域服务</a>，并在构造 <code>IOptionsSnapshot&lt;T&gt;</code> 对象时提供选项的快照。 选项快照旨在用于暂时性和有作用域的依赖项。</li>
</ul>
<p>以下代码使用 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码注册 <code>MyOptions</code> 绑定的配置实例：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，已读取在应用启动后对 JSON 配置文件所做的更改。</p>
<h2 id="ioptionsmonitor">IOptionsMonitor</h2>
<p>以下代码注册 <code>MyOptions</code> 绑定的配置实例。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的示例使用 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt;：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中，默认读取在应用启动后对 JSON 配置文件所做的更改。</p>
<p><a name="named"></a></p>
<h2 id="named-options-support-using-iconfigurenamedoptions">命名选项支持使用 IConfigureNamedOptions</h2>
<p>命名选项：</p>
<ul>
<li>当多个配置节绑定到同一属性时有用。</li>
<li>区分大小写。</li>
</ul>
<p>请考虑使用以下 appsettings.json 文件：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的类用于每个节，而不是创建两个类来绑定 <code>TopItem:Month</code> 和 <code>TopItem:Year</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的代码将配置命名选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的代码将显示命名选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>所有选项都是命名实例。 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 实例将被视为面向 <code>Options.DefaultName</code> 实例，即 <code>string.Empty</code>。 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 还可实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt;。 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 的默认实现具有适当地使用每个实例的逻辑。 <code>null</code> 命名选项用于面向所有命名实例，而不是某一特定命名实例。 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.ConfigureAll*&gt; 和 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 使用此约定。</p>
<h2 id="optionsbuilder-api">OptionsBuilder API</h2>
<p>&lt;xref:Microsoft.Extensions.Options.OptionsBuilder%601&gt; 用于配置 <code>TOptions</code> 实例。 <code>OptionsBuilder</code> 简化了创建命名选项的过程，因为它只是初始 <code>AddOptions&lt;TOptions&gt;(string optionsName)</code> 调用的单个参数，而不会出现在所有后续调用中。 选项验证和接受服务依赖关系的 <code>ConfigureOptions</code> 重载仅可通过 <code>OptionsBuilder</code> 获得。</p>
<p><code>OptionsBuilder</code> 在<a href="#val">选项验证</a>部分中使用。</p>
<h2 id="use-di-services-to-configure-options">使用 DI 服务配置选项</h2>
<p>在配置选项时，可以通过以下两种方式通过依赖关系注入访问服务：</p>
<ul>
<li><p>将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a> 上的 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a>。 <code>OptionsBuilder&lt;TOptions&gt;</code> 提供 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a> 的重载，该重载允许使用最多五个服务来配置选项：</p>
<pre><code class="lang-csharp">services.AddOptions&lt;MyOptions&gt;(&quot;optionalName&quot;)
    .Configure&lt;Service1, Service2, Service3, Service4, Service5&gt;(
        (o, s, s2, s3, s4, s5) =&gt; 
            o.Property = DoSomethingWith(s, s2, s3, s4, s5));
</code></pre>
</li>
<li><p>创建实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 的类型，并将该类型注册为服务。</p>
</li>
</ul>
<p>建议将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a>，因为创建服务较复杂。 在调用 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a> 时，创建类型等效于框架执行的操作。 调用<a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a> 会注册临时泛型 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt;，它具有接受指定的泛型服务类型的构造函数。</p>
<p><a name="val"></a></p>
<h2 id="options-validation">选项验证</h2>
<p>通过选项验证，可以验证选项值。</p>
<p>请考虑使用以下 appsettings.json 文件：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的类绑定到 <code>&quot;MyConfig&quot;</code> 配置节，并应用若干 <code>DataAnnotations</code> 规则：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的代码：</p>
<ul>
<li>调用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.AddOptions%2A&gt; 以获取绑定到 <code>MyConfigOptions</code> 类的 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a>。</li>
<li>调用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsBuilderDataAnnotationsExtensions.ValidateDataAnnotations%2A&gt; 以使用 <code>DataAnnotations</code> 启用验证。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>ValidateDataAnnotations</code> 扩展方法在 <a href="https://www.nuget.org/packages/Microsoft.Extensions.Options.DataAnnotations">Microsoft.Extensions.Options.DataAnnotations</a> NuGet 包中定义。 对于使用 <code>Microsoft.NET.Sdk.Web</code> SDK 的 Web 应用，通过共享框架隐式引用此包。</p>
<p>下面的代码显示配置值或验证错误：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下面的代码使用委托应用更复杂的验证规则：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="ivalidateoptions-for-complex-validation">用于复杂验证的 IValidateOptions</h3>
<p>下面的类实现了 &lt;xref:Microsoft.Extensions.Options.IValidateOptions`1&gt;：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>IValidateOptions</code> 允许将验证代码移出 <code>StartUp</code> 并将其移入类中。</p>
<p>使用前面的代码，使用以下代码在 <code>Startup.ConfigureServices</code> 中启用验证：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><!-- The following comment doesn't seem that useful 
Options validation doesn't guard against options modifications after the options instance is created. For example, `IOptionsSnapshot` options are created and validated once per request when the options are first accessed. The `IOptionsSnapshot` options aren't validated again on subsequent access attempts *for the same request*.

The `Validate` method accepts a `Func<TOptions, bool>`. To fully customize validation, implement `IValidateOptions<TOptions>`, which allows:

* Validation of multiple options types: `class ValidateTwo : IValidateOptions<Option1>, IValidationOptions<Option2>`
* Validation that depends on another option type: `public DependsOnAnotherOptionValidator(IOptionsMonitor<AnotherOption> options)`

`IValidateOptions` validates:

* A specific named options instance.
* All options when `name` is `null`.

Return a `ValidateOptionsResult` from your implementation of the interface:

```csharp
public interface IValidateOptions<TOptions> where TOptions : class
{
    ValidateOptionsResult Validate(string name, TOptions options);
}
```

Data Annotation-based validation is available from the [Microsoft.Extensions.Options.DataAnnotations](https://www.nuget.org/packages/Microsoft.Extensions.Options.DataAnnotations) package by calling the <xref:Microsoft.Extensions.DependencyInjection.OptionsBuilderDataAnnotationsExtensions.ValidateDataAnnotations*> method on `OptionsBuilder<TOptions>`. `Microsoft.Extensions.Options.DataAnnotations` is implicitly referenced in ASP.NET Core apps.

-->
<h2 id="options-post-configuration">选项后期配置</h2>
<p>使用 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 设置后期配置。 进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后运行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>&lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions`1.PostConfigure*&gt; 可用于对命名选项进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(&quot;named_options_1&quot;, myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>使用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 对所有配置实例进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigureAll&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<h2 id="accessing-options-during-startup">在启动期间访问选项</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 可用于 <code>Startup.Configure</code> 中，因为在 <code>Configure</code> 方法执行之前已生成服务。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, 
    IOptionsMonitor&lt;MyOptions&gt; optionsAccessor)
{
    var option1 = optionsAccessor.CurrentValue.Option1;
}
</code></pre>
<p>不使用 <code>Startup.ConfigureServices</code> 中的 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt;。 由于服务注册的顺序，可能存在不一致的选项状态。</p>
<h2 id="optionsconfigurationextensions-nuget-package">ConfigurationExtensions NuGet 包</h2>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Options.ConfigurationExtensions/">Microsoft.Extensions.Options.ConfigurationExtensions</a> 包已在 ASP.NET Core 应用中隐式引用。</p>
</div>
<div range="= aspnetcore-2.2">
<p>选项模式使用类来表示相关设置的组。 当<a class="xref" href="index.html">配置设置</a>由方案隔离到单独的类时，应用遵循两个重要软件工程原则：</p>
<ul>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#encapsulation">接口分隔原则 (ISP) 或封装</a>：依赖于配置设置的方案（类）仅依赖于其使用的配置设置。</li>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns">关注点分离</a>：应用的不同部件的设置不彼此依赖或相互耦合。</li>
</ul>
<p>选项还提供验证配置数据的机制。 有关详细信息，请参阅<a href="#options-validation">选项验证</a>部分。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/configuration/options/samples">查看或下载示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="prerequisites">先决条件</h2>
<p>引用 <a class="xref" href="../metapackage-app.html">Microsoft.AspNetCore.App 元包</a>或将包引用添加到 <a href="https://www.nuget.org/packages/Microsoft.Extensions.Options.ConfigurationExtensions/">Microsoft.Extensions.Options.ConfigurationExtensions</a> 包。</p>
<h2 id="options-interfaces">选项接口</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 用于检索选项并管理 <code>TOptions</code> 实例的选项通知。 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 支持以下方案：</p>
<ul>
<li>更改通知</li>
<li><a href="#named-options-support-with-iconfigurenamedoptions">命名选项</a></li>
<li><a href="#reload-configuration-data-with-ioptionssnapshot">可重载配置</a></li>
<li>选择性选项失效 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt;)</li>
</ul>
<p><a href="#options-post-configuration">后期配置</a>方案允许你在进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后设置或更改选项。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 负责新建选项实例。 它具有单个 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory`1.Create*&gt; 方法。 默认实现采用所有已注册 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 并首先运行所有配置，然后才进行后期配置。 它区分 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 且仅调用适当的接口。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 由 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 用于缓存 <code>TOptions</code> 实例。 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 可使监视器中的选项实例无效，以便重新计算值 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryRemove*&gt;)。 可以通过 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryAdd*&gt; 手动引入值。 在应按需重新创建所有命名实例时使用 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.Clear*&gt; 方法。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt; 在每次请求时应重新计算选项的方案中有用。 有关详细信息，请参阅<a href="#reload-configuration-data-with-ioptionssnapshot">通过 IOptionsSnapshot 重新加载配置数据</a>部分。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 可用于支持选项。 但是，&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 不支持前面的 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 方案。 你可以在已使用 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 接口的现有框架和库中继续使用 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt;，并且不需要 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 提供的方案。</p>
<h2 id="general-options-configuration">常规选项配置</h2>
<p>常规选项配置已作为示例 1 在示例应用中进行了演示。</p>
<p>选项类必须为包含公共无参数构造函数的非抽象类。 以下类 <code>MyOptions</code> 具有两种属性：<code>Option1</code> 和 <code>Option2</code>。 设置默认值为可选，但以下示例中的类构造函数设置了 <code>Option1</code> 的默认值。 <code>Option2</code> 具有通过直接初始化属性设置的默认值 (Models/MyOptions.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>MyOptions</code> 类已通过 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsConfigurationServiceCollectionExtensions.Configure*&gt; 添加到服务容器并绑定到配置：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下页面模型通过 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 使用<a class="xref" href="../../mvc/controllers/dependency-injection.html">构造函数依赖关系注入</a>来访问设置 (Pages/Index.cshtml.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例的 appsettings.json 文件指定 <code>option1</code> 和 <code>option2</code> 的值：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行应用时，页面模型的 <code>OnGet</code> 方法返回显示选项类值的字符串：</p>
<pre><code class="lang-html">option1 = value1_from_json, option2 = -1
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>使用自定义 &lt;xref:System.Configuration.ConfigurationBuilder&gt; 从设置文件加载选项配置时，请确认基路径设置正确：</p>
<pre><code class="lang-csharp">var configBuilder = new ConfigurationBuilder()
   .SetBasePath(Directory.GetCurrentDirectory())
   .AddJsonFile(&quot;appsettings.json&quot;, optional: true);
var config = configBuilder.Build();

services.Configure&lt;MyOptions&gt;(config);
</code></pre>
<p>通过 &lt;xref:Microsoft.AspNetCore.WebHost.CreateDefaultBuilder*&gt; 从设置文件加载选项配置时，不需要显式设置基路径。</p>
</div>
<h2 id="configure-simple-options-with-a-delegate">通过委托配置简单选项</h2>
<p>通过委托配置简单选项已作为示例 2 在示例应用中进行了演示。</p>
<p>使用委托设置选项值。 此示例应用使用 <code>MyOptionsWithDelegateConfig</code> 类 (Models/MyOptionsWithDelegateConfig.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，已向服务容器添加第二个 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务。 它通过 <code>MyOptionsWithDelegateConfig</code> 使用委托来配置绑定：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Index.cshtml.cs:</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>可添加多个配置提供程序。 配置提供程序可从 NuGet 包中获取，并按照注册的顺序应用。 有关详细信息，请参阅 <a class="xref" href="index.html">ASP.NET Core 中的配置</a>。</p>
<p>每次调用 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601.Configure*&gt; 都会将 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务添加到服务容器。 在前面的示例中，<code>Option1</code> 和 <code>Option2</code> 的值同时在 appsettings.json 中指定，但 <code>Option1</code> 和 <code>Option2</code> 的值被配置的委托替代。</p>
<p>当启用多个配置服务时，指定的最后一个配置源优于其他源，由其设置配置值。 运行应用时，页面模型的 <code>OnGet</code> 方法返回显示选项类值的字符串：</p>
<pre><code class="lang-html">delegate_option1 = value1_configured_by_delegate, delegate_option2 = 500
</code></pre>
<h2 id="suboptions-configuration">子选项配置</h2>
<p>子选项配置已作为示例 3 在示例应用中进行了演示。</p>
<p>应用应创建适用于应用中特定方案组（类）的选项类。 需要配置值的部分应用应仅有权访问其使用的配置值。</p>
<p>将选项绑定到配置时，选项类型中的每个属性都将绑定到窗体 <code>property[:sub-property:]</code> 的配置键。 例如，<code>MyOptions.Option1</code> 属性将绑定到从 appsettings.json 中的 <code>option1</code> 属性读取的键 <code>Option1</code>。</p>
<p>在以下代码中，已向服务容器添加第三个 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务。 它将 <code>MySubOptions</code> 绑定到 appsettings.json 文件的 <code>subsection</code> 部分：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>GetSection</code> 方法需要 &lt;xref:Microsoft.Extensions.Configuration?displayProperty=fullName&gt; 命名空间。</p>
<p>示例的 appsettings.json 文件定义具有 <code>suboption1</code> 和 <code>suboption2</code> 的键的 <code>subsection</code> 成员：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>MySubOptions</code> 类将属性 <code>SubOption1</code> 和 <code>SubOption2</code> 定义为保留选项值 (Models/MySubOptions.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>页面模型的 <code>OnGet</code> 方法返回包含选项值的字符串 (Pages/Index.cshtml.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行应用时，<code>OnGet</code> 方法返回显示子选项类值的字符串：</p>
<pre><code class="lang-html">subOption1 = subvalue1_from_json, subOption2 = 200
</code></pre>
<h2 id="options-injection">选项注入</h2>
<p>选项注入已作为示例 4 在示例应用中进行了演示。</p>
<p>将 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 注入：</p>
<ul>
<li>使用 <a class="xref" href="../../mvc/views/razor.html#inject"><code>@inject</code></a> Razor 指令的 Razor 页面或 MVC 视图。</li>
<li>页面或视图模型。</li>
</ul>
<p>示例应用中的以下示例将 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 注入页面模型 (<em>Pages/Index.cshtml.cs</em>)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例应用演示如何使用 <code>@inject</code> 指令注入 <code>IOptionsMonitor&lt;MyOptions&gt;</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>当应用运行时，选项值显示在呈现的页面中：</p>
<p><img src="options/_static/view.png" alt="选项值 Option1：value1_from_json 和 Option2：-1 从模型中加载并注入视图。"></p>
<h2 id="reload-configuration-data-with-ioptionssnapshot">通过 IOptionsSnapshot 重新加载配置数据</h2>
<p>通过 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt; 重新加载配置数据已作为示例 5 在示例应用中进行了演示。</p>
<p>通过使用 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;，针对请求生存期访问和缓存选项时，每个请求都会计算一次选项。</p>
<p><code>IOptionsMonitor</code> 和 <code>IOptionsSnapshot</code> 之间的区别在于：</p>
<ul>
<li><code>IOptionsMonitor</code> 是一种<a class="xref" href="../dependency-injection.html#singleton">单一示例服务</a>，可随时检索当前选项值，这在单一实例依赖项中尤其有用。</li>
<li><code>IOptionsSnapshot</code> 是一种<a class="xref" href="../dependency-injection.html#scoped">作用域服务</a>，并在构造 <code>IOptionsSnapshot&lt;T&gt;</code> 对象时提供选项的快照。 选项快照旨在用于暂时性和有作用域的依赖项。</li>
</ul>
<p>以下示例演示如何在更改 appsettings.json (Pages/Index.cshtml.cs) 后创建新的 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;。 在更改文件和重新加载配置之前，针对服务器的多个请求返回 appsettings.json 文件提供的常数值。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下图显示从 appsettings.json 文件加载的初始 <code>option1</code> 和 <code>option2</code> 值：</p>
<pre><code class="lang-html">snapshot option1 = value1_from_json, snapshot option2 = -1
</code></pre>
<p>将 appsettings.json 文件中的值更改为 <code>value1_from_json UPDATED</code> 和 <code>200</code>。 保存 appsettings.json 文件。 刷新浏览器，查看更新的选项值：</p>
<pre><code class="lang-html">snapshot option1 = value1_from_json UPDATED, snapshot option2 = 200
</code></pre>
<h2 id="named-options-support-with-iconfigurenamedoptions">包含 IConfigureNamedOptions 的命名选项支持</h2>
<p>包含 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 的命名选项支持已作为示例 6 在示例应用中进行了演示。</p>
<p>命名选项支持允许应用在命名选项配置之间进行区分。 在示例应用中，命名选项通过 <a href="xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.Configure*">OptionsServiceCollectionExtensions.Configure</a> 进行声明，其调用 <a href="xref:Microsoft.Extensions.Options.ConfigureNamedOptions%601.Configure*">ConfigureNamedOptions&lt;TOptions&gt;.Configure</a> 扩展方法。 命名选项区分大小写。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例应用通过 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot`1.Get*&gt; (Pages/Index.cshtml.cs) 访问命名选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行示例应用，将返回命名选项：</p>
<pre><code class="lang-html">named_options_1: option1 = value1_from_json, option2 = -1
named_options_2: option1 = named_options_2_value1_from_action, option2 = 5
</code></pre>
<p>从配置中提供从 appsettings.json 文件中加载的 <code>named_options_1</code> 值。 通过以下内容提供 <code>named_options_2</code> 值：</p>
<ul>
<li>针对 <code>Option1</code> 的 <code>ConfigureServices</code> 中的 <code>named_options_2</code> 委托。</li>
<li><code>MyOptions</code> 类提供的 <code>Option2</code> 的默认值。</li>
</ul>
<h2 id="configure-all-options-with-the-configureall-method">使用 ConfigureAll 方法配置所有选项</h2>
<p>使用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.ConfigureAll*&gt; 方法配置所有选项实例。 以下代码将针对包含公共值的所有配置实例配置 <code>Option1</code>。 将以下代码手动添加到 <code>Startup.ConfigureServices</code> 方法：</p>
<pre><code class="lang-csharp">services.ConfigureAll&lt;MyOptions&gt;(myOptions =&gt; 
{
    myOptions.Option1 = &quot;ConfigureAll replacement value&quot;;
});
</code></pre>
<p>添加代码后运行示例应用将产生以下结果：</p>
<pre><code class="lang-html">named_options_1: option1 = ConfigureAll replacement value, option2 = -1
named_options_2: option1 = ConfigureAll replacement value, option2 = 5
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>所有选项都是命名实例。 现有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 实例将被视为面向 <code>Options.DefaultName</code> 实例，即 <code>string.Empty</code>。 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 还可实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt;。 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 的默认实现具有适当地使用每个实例的逻辑。 <code>null</code> 命名选项用于面向所有命名实例而不是某一特定命名实例（&lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.ConfigureAll*&gt; 和 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 使用此约定）。</p>
</div>
<h2 id="optionsbuilder-api">OptionsBuilder API</h2>
<p>&lt;xref:Microsoft.Extensions.Options.OptionsBuilder%601&gt; 用于配置 <code>TOptions</code> 实例。 <code>OptionsBuilder</code> 简化了创建命名选项的过程，因为它只是初始 <code>AddOptions&lt;TOptions&gt;(string optionsName)</code> 调用的单个参数，而不会出现在所有后续调用中。 选项验证和接受服务依赖关系的 <code>ConfigureOptions</code> 重载仅可通过 <code>OptionsBuilder</code> 获得。</p>
<pre><code class="lang-csharp">// Options.DefaultName = &quot;&quot; is used.
services.AddOptions&lt;MyOptions&gt;().Configure(o =&gt; o.Property = &quot;default&quot;);

services.AddOptions&lt;MyOptions&gt;(&quot;optionalName&quot;)
    .Configure(o =&gt; o.Property = &quot;named&quot;);
</code></pre>
<h2 id="use-di-services-to-configure-options">使用 DI 服务配置选项</h2>
<p>在配置选项时，可以通过以下两种方式通过依赖关系注入访问其他服务：</p>
<ul>
<li><p>将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a> 上的 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a>。 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a> 提供 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a> 的重载，该重载允许使用最多五个服务来配置选项：</p>
<pre><code class="lang-csharp">services.AddOptions&lt;MyOptions&gt;(&quot;optionalName&quot;)
    .Configure&lt;Service1, Service2, Service3, Service4, Service5&gt;(
        (o, s, s2, s3, s4, s5) =&gt; 
            o.Property = DoSomethingWith(s, s2, s3, s4, s5));
</code></pre>
</li>
<li><p>创建实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 的你自己的类型，并将该类型注册为服务。</p>
</li>
</ul>
<p>建议将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a>，因为创建服务较复杂。 在使用<a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a>时，创建你自己的类型等效于框架为你执行的操作。 调用<a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a> 会注册临时泛型 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt;，它具有接受指定的泛型服务类型的构造函数。</p>
<h2 id="options-validation">选项验证</h2>
<p>借助选项验证，可以验证已配置的选项。 使用验证方法调用 <code>Validate</code>。如果选项有效，方法返回 <code>true</code>；如果无效，方法返回 <code>false</code>：</p>
<pre><code class="lang-csharp">// Registration
services.AddOptions&lt;MyOptions&gt;(&quot;optionalOptionsName&quot;)
    .Configure(o =&gt; { }) // Configure the options
    .Validate(o =&gt; YourValidationShouldReturnTrueIfValid(o), 
        &quot;custom error&quot;);

// Consumption
var monitor = services.BuildServiceProvider()
    .GetService&lt;IOptionsMonitor&lt;MyOptions&gt;&gt;();

try
{
    var options = monitor.Get(&quot;optionalOptionsName&quot;);
}
catch (OptionsValidationException e) 
{
   // e.OptionsName returns &quot;optionalOptionsName&quot;
   // e.OptionsType returns typeof(MyOptions)
   // e.Failures returns a list of errors, which would contain 
   //     &quot;custom error&quot;
}
</code></pre>
<p>上面的示例将命名选项实例设置为 <code>optionalOptionsName</code>。 默认选项实例为 <code>Options.DefaultName</code>。</p>
<p>选项验证在选项实例创建后运行。 系统保证在选项实例首次获得访问时通过验证。</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>选项验证无法防止在创建选项实例后发生选项修改。 例如，在首次访问选项时按请求创建并验证 <code>IOptionsSnapshot</code> 选项。 对于同一个请求，在后续访问尝试时不会再次验证 <code>IOptionsSnapshot</code> 选项。</p>
</div>
<p><code>Validate</code> 方法接受 <code>Func&lt;TOptions, bool&gt;</code>。 若要完全自定义验证，请实现 <code>IValidateOptions&lt;TOptions&gt;</code>，它支持：</p>
<ul>
<li>验证多种类型的选项：<code>class ValidateTwo : IValidateOptions&lt;Option1&gt;, IValidationOptions&lt;Option2&gt;</code></li>
<li>验证取决于其他选项类型：<code>public DependsOnAnotherOptionValidator(IOptionsMonitor&lt;AnotherOption&gt; options)</code></li>
</ul>
<p><code>IValidateOptions</code> 验证：</p>
<ul>
<li>特定的命名选项实例。</li>
<li>所有选项（如果 <code>name</code> 为 <code>null</code> 的话）。</li>
</ul>
<p>通过接口实现返回 <code>ValidateOptionsResult</code>：</p>
<pre><code class="lang-csharp">public interface IValidateOptions&lt;TOptions&gt; where TOptions : class
{
    ValidateOptionsResult Validate(string name, TOptions options);
}
</code></pre>
<p>通过调用 <code>OptionsBuilder&lt;TOptions&gt;</code> 上的 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsBuilderDataAnnotationsExtensions.ValidateDataAnnotations*&gt; 方法，可以从 <a href="https://www.nuget.org/packages/Microsoft.Extensions.Options.DataAnnotations">Microsoft.Extensions.Options.DataAnnotations</a> 包中获得基于数据注释的验证。 <code>Microsoft.Extensions.Options.DataAnnotations</code> 包含在 <a class="xref" href="../metapackage-app.html">Microsoft.AspNetCore.App 元包</a>中。</p>
<pre><code class="lang-csharp">using Microsoft.Extensions.DependencyInjection;

private class AnnotatedOptions
{
    [Required]
    public string Required { get; set; }

    [StringLength(5, ErrorMessage = &quot;Too long.&quot;)]
    public string StringLength { get; set; }

    [Range(-5, 5, ErrorMessage = &quot;Out of range.&quot;)]
    public int IntRange { get; set; }
}

[Fact]
public void CanValidateDataAnnotations()
{
    var services = new ServiceCollection();
    services.AddOptions&lt;AnnotatedOptions&gt;()
        .Configure(o =&gt;
        {
            o.StringLength = &quot;111111&quot;;
            o.IntRange = 10;
            o.Custom = &quot;nowhere&quot;;
        })
        .ValidateDataAnnotations();

    var sp = services.BuildServiceProvider();

    var error = Assert.Throws&lt;OptionsValidationException&gt;(() =&gt; 
        sp.GetRequiredService&lt;IOptionsMonitor&lt;AnnotatedOptions&gt;&gt;().CurrentValue);
    ValidateFailure&lt;AnnotatedOptions&gt;(error, Options.DefaultName, 1,
        &quot;DataAnnotation validation failed for members Required &quot; +
            &quot;with the error 'The Required field is required.'.&quot;,
        &quot;DataAnnotation validation failed for members StringLength &quot; +
            &quot;with the error 'Too long.'.&quot;,
        &quot;DataAnnotation validation failed for members IntRange &quot; +
            &quot;with the error 'Out of range.'.&quot;);
}
</code></pre>
<p>设计团队正在考虑为未来版本提供预先验证（在启动时快速失败）。</p>
<h2 id="options-post-configuration">选项后期配置</h2>
<p>使用 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 设置后期配置。 进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后运行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>&lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions`1.PostConfigure*&gt; 可用于对命名选项进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(&quot;named_options_1&quot;, myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>使用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 对所有配置实例进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigureAll&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<h2 id="accessing-options-during-startup">在启动期间访问选项</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 可用于 <code>Startup.Configure</code> 中，因为在 <code>Configure</code> 方法执行之前已生成服务。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IOptionsMonitor&lt;MyOptions&gt; optionsAccessor)
{
    var option1 = optionsAccessor.CurrentValue.Option1;
}
</code></pre>
<p>不使用 <code>Startup.ConfigureServices</code> 中的 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt;。 由于服务注册的顺序，可能存在不一致的选项状态。</p>
</div>
<div range="= aspnetcore-2.1">
<p>选项模式使用类来表示相关设置的组。 当<a class="xref" href="index.html">配置设置</a>由方案隔离到单独的类时，应用遵循两个重要软件工程原则：</p>
<ul>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#encapsulation">接口分隔原则 (ISP) 或封装</a>：依赖于配置设置的方案（类）仅依赖于其使用的配置设置。</li>
<li><a href="/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns">关注点分离</a>：应用的不同部件的设置不彼此依赖或相互耦合。</li>
</ul>
<p>选项还提供验证配置数据的机制。 有关详细信息，请参阅<a href="#options-validation">选项验证</a>部分。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/configuration/options/samples">查看或下载示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="prerequisites">先决条件</h2>
<p>引用 <a class="xref" href="../metapackage-app.html">Microsoft.AspNetCore.App 元包</a>或将包引用添加到 <a href="https://www.nuget.org/packages/Microsoft.Extensions.Options.ConfigurationExtensions/">Microsoft.Extensions.Options.ConfigurationExtensions</a> 包。</p>
<h2 id="options-interfaces">选项接口</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 用于检索选项并管理 <code>TOptions</code> 实例的选项通知。 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 支持以下方案：</p>
<ul>
<li>更改通知</li>
<li><a href="#named-options-support-with-iconfigurenamedoptions">命名选项</a></li>
<li><a href="#reload-configuration-data-with-ioptionssnapshot">可重载配置</a></li>
<li>选择性选项失效 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt;)</li>
</ul>
<p><a href="#options-post-configuration">后期配置</a>方案允许你在进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后设置或更改选项。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 负责新建选项实例。 它具有单个 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory`1.Create*&gt; 方法。 默认实现采用所有已注册 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 并首先运行所有配置，然后才进行后期配置。 它区分 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 且仅调用适当的接口。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 由 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 用于缓存 <code>TOptions</code> 实例。 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache%601&gt; 可使监视器中的选项实例无效，以便重新计算值 (&lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryRemove*&gt;)。 可以通过 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.TryAdd*&gt; 手动引入值。 在应按需重新创建所有命名实例时使用 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitorCache`1.Clear*&gt; 方法。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt; 在每次请求时应重新计算选项的方案中有用。 有关详细信息，请参阅<a href="#reload-configuration-data-with-ioptionssnapshot">通过 IOptionsSnapshot 重新加载配置数据</a>部分。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 可用于支持选项。 但是，&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 不支持前面的 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 方案。 你可以在已使用 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 接口的现有框架和库中继续使用 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt;，并且不需要 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 提供的方案。</p>
<h2 id="general-options-configuration">常规选项配置</h2>
<p>常规选项配置已作为示例 1 在示例应用中进行了演示。</p>
<p>选项类必须为包含公共无参数构造函数的非抽象类。 以下类 <code>MyOptions</code> 具有两种属性：<code>Option1</code> 和 <code>Option2</code>。 设置默认值为可选，但以下示例中的类构造函数设置了 <code>Option1</code> 的默认值。 <code>Option2</code> 具有通过直接初始化属性设置的默认值 (Models/MyOptions.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>MyOptions</code> 类已通过 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsConfigurationServiceCollectionExtensions.Configure*&gt; 添加到服务容器并绑定到配置：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下页面模型通过 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 使用<a class="xref" href="../../mvc/controllers/dependency-injection.html">构造函数依赖关系注入</a>来访问设置 (Pages/Index.cshtml.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例的 appsettings.json 文件指定 <code>option1</code> 和 <code>option2</code> 的值：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行应用时，页面模型的 <code>OnGet</code> 方法返回显示选项类值的字符串：</p>
<pre><code class="lang-html">option1 = value1_from_json, option2 = -1
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>使用自定义 &lt;xref:System.Configuration.ConfigurationBuilder&gt; 从设置文件加载选项配置时，请确认基路径设置正确：</p>
<pre><code class="lang-csharp">var configBuilder = new ConfigurationBuilder()
   .SetBasePath(Directory.GetCurrentDirectory())
   .AddJsonFile(&quot;appsettings.json&quot;, optional: true);
var config = configBuilder.Build();

services.Configure&lt;MyOptions&gt;(config);
</code></pre>
<p>通过 &lt;xref:Microsoft.AspNetCore.WebHost.CreateDefaultBuilder*&gt; 从设置文件加载选项配置时，不需要显式设置基路径。</p>
</div>
<h2 id="configure-simple-options-with-a-delegate">通过委托配置简单选项</h2>
<p>通过委托配置简单选项已作为示例 2 在示例应用中进行了演示。</p>
<p>使用委托设置选项值。 此示例应用使用 <code>MyOptionsWithDelegateConfig</code> 类 (Models/MyOptionsWithDelegateConfig.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，已向服务容器添加第二个 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务。 它通过 <code>MyOptionsWithDelegateConfig</code> 使用委托来配置绑定：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Index.cshtml.cs:</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>可添加多个配置提供程序。 配置提供程序可从 NuGet 包中获取，并按照注册的顺序应用。 有关详细信息，请参阅 <a class="xref" href="index.html">ASP.NET Core 中的配置</a>。</p>
<p>每次调用 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601.Configure*&gt; 都会将 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务添加到服务容器。 在前面的示例中，<code>Option1</code> 和 <code>Option2</code> 的值同时在 appsettings.json 中指定，但 <code>Option1</code> 和 <code>Option2</code> 的值被配置的委托替代。</p>
<p>当启用多个配置服务时，指定的最后一个配置源优于其他源，由其设置配置值。 运行应用时，页面模型的 <code>OnGet</code> 方法返回显示选项类值的字符串：</p>
<pre><code class="lang-html">delegate_option1 = value1_configured_by_delegate, delegate_option2 = 500
</code></pre>
<h2 id="suboptions-configuration">子选项配置</h2>
<p>子选项配置已作为示例 3 在示例应用中进行了演示。</p>
<p>应用应创建适用于应用中特定方案组（类）的选项类。 需要配置值的部分应用应仅有权访问其使用的配置值。</p>
<p>将选项绑定到配置时，选项类型中的每个属性都将绑定到窗体 <code>property[:sub-property:]</code> 的配置键。 例如，<code>MyOptions.Option1</code> 属性将绑定到从 appsettings.json 中的 <code>option1</code> 属性读取的键 <code>Option1</code>。</p>
<p>在以下代码中，已向服务容器添加第三个 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 服务。 它将 <code>MySubOptions</code> 绑定到 appsettings.json 文件的 <code>subsection</code> 部分：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>GetSection</code> 方法需要 &lt;xref:Microsoft.Extensions.Configuration?displayProperty=fullName&gt; 命名空间。</p>
<p>示例的 appsettings.json 文件定义具有 <code>suboption1</code> 和 <code>suboption2</code> 的键的 <code>subsection</code> 成员：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>MySubOptions</code> 类将属性 <code>SubOption1</code> 和 <code>SubOption2</code> 定义为保留选项值 (Models/MySubOptions.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>页面模型的 <code>OnGet</code> 方法返回包含选项值的字符串 (Pages/Index.cshtml.cs)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行应用时，<code>OnGet</code> 方法返回显示子选项类值的字符串：</p>
<pre><code class="lang-html">subOption1 = subvalue1_from_json, subOption2 = 200
</code></pre>
<h2 id="options-provided-by-a-view-model-or-with-direct-view-injection">视图模型或通过直接视图注入提供的选项</h2>
<p>视图模型或通过直接视图注入提供的选项已作为示例 4 在示例应用中进行了演示。</p>
<p>可在视图模型中或通过将 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 直接注入到视图 (Pages/Index.cshtml.cs) 来提供选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例应用演示如何使用 <code>@inject</code> 指令注入 <code>IOptionsMonitor&lt;MyOptions&gt;</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>当应用运行时，选项值显示在呈现的页面中：</p>
<p><img src="options/_static/view.png" alt="选项值 Option1：value1_from_json 和 Option2：-1 从模型中加载并注入视图。"></p>
<h2 id="reload-configuration-data-with-ioptionssnapshot">通过 IOptionsSnapshot 重新加载配置数据</h2>
<p>通过 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt; 重新加载配置数据已作为示例 5 在示例应用中进行了演示。</p>
<p>&lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt; 支持包含最小处理开销的重新加载选项。</p>
<p>针对请求生存期访问和缓存选项时，每个请求只能计算一次选项。</p>
<p>以下示例演示如何在更改 appsettings.json (Pages/Index.cshtml.cs) 后创建新的 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot%601&gt;。 在更改文件和重新加载配置之前，针对服务器的多个请求返回 appsettings.json 文件提供的常数值。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>下图显示从 appsettings.json 文件加载的初始 <code>option1</code> 和 <code>option2</code> 值：</p>
<pre><code class="lang-html">snapshot option1 = value1_from_json, snapshot option2 = -1
</code></pre>
<p>将 appsettings.json 文件中的值更改为 <code>value1_from_json UPDATED</code> 和 <code>200</code>。 保存 appsettings.json 文件。 刷新浏览器，查看更新的选项值：</p>
<pre><code class="lang-html">snapshot option1 = value1_from_json UPDATED, snapshot option2 = 200
</code></pre>
<h2 id="named-options-support-with-iconfigurenamedoptions">包含 IConfigureNamedOptions 的命名选项支持</h2>
<p>包含 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 的命名选项支持已作为示例 6 在示例应用中进行了演示。</p>
<p>命名选项支持允许应用在命名选项配置之间进行区分。 在示例应用中，命名选项通过 <a href="xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.Configure*">OptionsServiceCollectionExtensions.Configure</a> 进行声明，其调用 <a href="xref:Microsoft.Extensions.Options.ConfigureNamedOptions%601.Configure*">ConfigureNamedOptions&lt;TOptions&gt;.Configure</a> 扩展方法。 命名选项区分大小写。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>示例应用通过 &lt;xref:Microsoft.Extensions.Options.IOptionsSnapshot`1.Get*&gt; (Pages/Index.cshtml.cs) 访问命名选项：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>运行示例应用，将返回命名选项：</p>
<pre><code class="lang-html">named_options_1: option1 = value1_from_json, option2 = -1
named_options_2: option1 = named_options_2_value1_from_action, option2 = 5
</code></pre>
<p>从配置中提供从 appsettings.json 文件中加载的 <code>named_options_1</code> 值。 通过以下内容提供 <code>named_options_2</code> 值：</p>
<ul>
<li>针对 <code>Option1</code> 的 <code>ConfigureServices</code> 中的 <code>named_options_2</code> 委托。</li>
<li><code>MyOptions</code> 类提供的 <code>Option2</code> 的默认值。</li>
</ul>
<h2 id="configure-all-options-with-the-configureall-method">使用 ConfigureAll 方法配置所有选项</h2>
<p>使用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.ConfigureAll*&gt; 方法配置所有选项实例。 以下代码将针对包含公共值的所有配置实例配置 <code>Option1</code>。 将以下代码手动添加到 <code>Startup.ConfigureServices</code> 方法：</p>
<pre><code class="lang-csharp">services.ConfigureAll&lt;MyOptions&gt;(myOptions =&gt; 
{
    myOptions.Option1 = &quot;ConfigureAll replacement value&quot;;
});
</code></pre>
<p>添加代码后运行示例应用将产生以下结果：</p>
<pre><code class="lang-html">named_options_1: option1 = ConfigureAll replacement value, option2 = -1
named_options_2: option1 = ConfigureAll replacement value, option2 = 5
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>所有选项都是命名实例。 现有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 实例将被视为面向 <code>Options.DefaultName</code> 实例，即 <code>string.Empty</code>。 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 还可实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt;。 &lt;xref:Microsoft.Extensions.Options.IOptionsFactory%601&gt; 的默认实现具有适当地使用每个实例的逻辑。 <code>null</code> 命名选项用于面向所有命名实例而不是某一特定命名实例（&lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.ConfigureAll*&gt; 和 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 使用此约定）。</p>
</div>
<h2 id="optionsbuilder-api">OptionsBuilder API</h2>
<p>&lt;xref:Microsoft.Extensions.Options.OptionsBuilder%601&gt; 用于配置 <code>TOptions</code> 实例。 <code>OptionsBuilder</code> 简化了创建命名选项的过程，因为它只是初始 <code>AddOptions&lt;TOptions&gt;(string optionsName)</code> 调用的单个参数，而不会出现在所有后续调用中。 选项验证和接受服务依赖关系的 <code>ConfigureOptions</code> 重载仅可通过 <code>OptionsBuilder</code> 获得。</p>
<pre><code class="lang-csharp">// Options.DefaultName = &quot;&quot; is used.
services.AddOptions&lt;MyOptions&gt;().Configure(o =&gt; o.Property = &quot;default&quot;);

services.AddOptions&lt;MyOptions&gt;(&quot;optionalName&quot;)
    .Configure(o =&gt; o.Property = &quot;named&quot;);
</code></pre>
<h2 id="use-di-services-to-configure-options">使用 DI 服务配置选项</h2>
<p>在配置选项时，可以通过以下两种方式通过依赖关系注入访问其他服务：</p>
<ul>
<li><p>将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a> 上的 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a>。 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601">OptionsBuilder&lt;TOptions&gt;</a> 提供 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a> 的重载，该重载允许使用最多五个服务来配置选项：</p>
<pre><code class="lang-csharp">services.AddOptions&lt;MyOptions&gt;(&quot;optionalName&quot;)
    .Configure&lt;Service1, Service2, Service3, Service4, Service5&gt;(
        (o, s, s2, s3, s4, s5) =&gt; 
            o.Property = DoSomethingWith(s, s2, s3, s4, s5));
</code></pre>
</li>
<li><p>创建实现 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt; 的你自己的类型，并将该类型注册为服务。</p>
</li>
</ul>
<p>建议将配置委托传递给 <a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*">Configure</a>，因为创建服务较复杂。 在使用<a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a>时，创建你自己的类型等效于框架为你执行的操作。 调用<a href="xref:Microsoft.Extensions.Options.OptionsBuilder%601.Configure*"> Configure</a> 会注册临时泛型 &lt;xref:Microsoft.Extensions.Options.IConfigureNamedOptions%601&gt;，它具有接受指定的泛型服务类型的构造函数。</p>
<h2 id="options-post-configuration">选项后期配置</h2>
<p>使用 &lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions%601&gt; 设置后期配置。 进行所有 &lt;xref:Microsoft.Extensions.Options.IConfigureOptions%601&gt; 配置后运行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>&lt;xref:Microsoft.Extensions.Options.IPostConfigureOptions`1.PostConfigure*&gt; 可用于对命名选项进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigure&lt;MyOptions&gt;(&quot;named_options_1&quot;, myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<p>使用 &lt;xref:Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.PostConfigureAll*&gt; 对所有配置实例进行后期配置：</p>
<pre><code class="lang-csharp">services.PostConfigureAll&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Option1 = &quot;post_configured_option1_value&quot;;
});
</code></pre>
<h2 id="accessing-options-during-startup">在启动期间访问选项</h2>
<p>&lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 和 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt; 可用于 <code>Startup.Configure</code> 中，因为在 <code>Configure</code> 方法执行之前已生成服务。</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IOptionsMonitor&lt;MyOptions&gt; optionsAccessor)
{
    var option1 = optionsAccessor.CurrentValue.Option1;
}
</code></pre>
<p>不使用 <code>Startup.ConfigureServices</code> 中的 &lt;xref:Microsoft.Extensions.Options.IOptions%601&gt; 或 &lt;xref:Microsoft.Extensions.Options.IOptionsMonitor%601&gt;。 由于服务注册的顺序，可能存在不一致的选项状态。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="index.html">ASP.NET Core 中的配置</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
