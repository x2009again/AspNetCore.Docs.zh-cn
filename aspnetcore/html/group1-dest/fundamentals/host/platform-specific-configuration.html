<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#22312; ASP.NET Core &#20013;&#20351;&#29992;&#25215;&#36733;&#21551;&#21160;&#31243;&#24207;&#38598; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#22312; ASP.NET Core &#20013;&#20351;&#29992;&#25215;&#36733;&#21551;&#21160;&#31243;&#24207;&#38598; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="fundamentals/configuration/platform-specific-configuration">
<h1 id="use-hosting-startup-assemblies-in-aspnet-core">在 ASP.NET Core 中使用承载启动程序集</h1>

<p>作者：<a href="https://github.com/pakrym">Pavel Krymets</a></p>
<div range="&gt;= aspnetcore-3.0">
<p>通过 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup&gt;（承载启动）实现，在启动时从外部程序集向应用添加增强功能。 例如，外部库可使用承载启动实现为应用提供其他配置提供程序或服务。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">查看或下载示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="hostingstartup-attribute">HostingStartup 属性</h2>
<p><a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性表示存在要在运行时激活的承载启动程序集。</p>
<p>将自动扫描输入程序集或包含 <code>Startup</code> 类的程序集以查找 <code>HostingStartup</code> 属性。 用于搜索 <code>HostingStartup</code> 属性的程序集列表在运行时从 <a href="xref:Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupAssembliesKey">WebHostDefaults.HostingStartupAssembliesKey</a> 中的配置加载。 要从发现中排除的程序集列表从 <a href="xref:Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupExcludeAssembliesKey">WebHostDefaults.HostingStartupExcludeAssembliesKey</a> 加载。</p>
<p>在以下示例中，承载启动程序集的命名空间为 <code>StartupEnhancement</code>。 包含承载启动代码的类是 <code>StartupEnhancementHostingStartup</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>HostingStartup</code> 属性通常位于承载启动程序集的 <code>IHostingStartup</code> 实现类文件中。</p>
<h2 id="discover-loaded-hosting-startup-assemblies">发现加载的承载启动程序集</h2>
<p>要发现加载的承载启动程序集，请启用日志记录并检查应用的日志。 记录加载程序集时发生的错误。 会在调试级别记录加载的承载启动程序集，并记录所有错误。</p>
<h2 id="disable-automatic-loading-of-hosting-startup-assemblies">禁用承载启动程序集的自动加载</h2>
<p>要禁用承载启动程序集的自动加载，请使用以下方法之一：</p>
<ul>
<li><p>要阻止加载所有承载启动程序集，请将以下内容之一设置为 <code>true</code> 或 <code>1</code>：</p>
<ul>
<li><p>阻止承载启动主机配置设置：</p>
<pre><code class="lang-csharp">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseSetting(
                    WebHostDefaults.PreventHostingStartupKey, &quot;true&quot;)
                .UseStartup&lt;Startup&gt;();
        });
</code></pre>
</li>
<li><p><code>ASPNETCORE_PREVENTHOSTINGSTARTUP</code> 环境变量。</p>
</li>
</ul>
</li>
<li><p>要阻止加载特定的承载启动程序集，请将以下之一设置为以分号分隔的承载启动程序集字符串，以便在启动时排除：</p>
<ul>
<li><p>承载启动排除程序集承载配置设置：</p>
<pre><code class="lang-csharp">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseSetting(
                    WebHostDefaults.HostingStartupExcludeAssembliesKey, 
                    &quot;{ASSEMBLY1;ASSEMBLY2; ...}&quot;)
                .UseStartup&lt;Startup&gt;();
        });
</code></pre>
</li>
<li><p><code>ASPNETCORE_HOSTINGSTARTUPEXCLUDEASSEMBLIES</code> 环境变量。</p>
</li>
</ul>
</li>
</ul>
<p>如果同时设置了主机配置设置和环境变量，则主机设置将控制行为。</p>
<p>如果使用主机设置或环境变量来禁用承载启动程序集，将全局禁用程序集，并可能会禁用应用的多个特征。</p>
<h2 id="project">项目</h2>
<p>使用以下任一项目类型创建承载启动：</p>
<ul>
<li><a href="#class-library">类库</a></li>
<li><a href="#console-app-without-an-entry-point">无入口点的控制台应用</a></li>
</ul>
<h3 id="class-library">类库</h3>
<p>可在类库中提供承载启动增强。 库包含 <code>HostingStartup</code> 属性。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>包括 Razor Pages 应用、HostingStartupApp 和类库 HostingStartupLibrary 。 类库：</p>
<ul>
<li>包含承载启动类 <code>ServiceKeyInjection</code>，用于实现 <code>IHostingStartup</code>。 <code>ServiceKeyInjection</code> 使用内存中配置提供程序 (<a href="xref:Microsoft.Extensions.Configuration.MemoryConfigurationBuilderExtensions.AddInMemoryCollection*">AddInMemoryCollection</a>) 将一对服务字符串添加到应用的配置中。</li>
<li>包含 <code>HostingStartup</code> 属性，用于标识承载启动的命名空间和类。</li>
</ul>
<p><code>ServiceKeyInjection</code> 类的 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法使用 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder&gt; 向应用添加增强功能。</p>
<p>HostingStartupLibrary/ServiceKeyInjection.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>应用的索引页读取并呈现类库承载启动程序集设置的两个键的配置值：</p>
<p>HostingStartupApp/Pages/Index.cshtml.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>还包括一个 NuGet 包项目，该项目提供单独的承载启动 HostingStartupPackage。 该包具有与前述类库相同的特征。 包：</p>
<ul>
<li>包含承载启动类 <code>ServiceKeyInjection</code>，用于实现 <code>IHostingStartup</code>。 <code>ServiceKeyInjection</code> 将一对服务字符串添加到应用的配置中。</li>
<li>包含 <code>HostingStartup</code> 属性。</li>
</ul>
<p>HostingStartupPackage/ServiceKeyInjection.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>应用的索引页读取并呈现包承载启动程序集设置的两个键的配置值：</p>
<p>HostingStartupApp/Pages/Index.cshtml.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="console-app-without-an-entry-point">无入口点的控制台应用</h3>
<p>此方法仅适用于 .NET Core 应用，不适用于 .NET Framework。</p>
<p>可在包含 <code>HostingStartup</code> 属性的无入口点的控制台应用中提供动态承载启动增强功能，该功能无需编译时引用进行激活。 发布控制台应用会生成可从运行时存储中使用的承载启动程序集。</p>
<p>此过程中使用没有入口点的控制台应用，因为：</p>
<ul>
<li>需要依赖项文件来使用承载启动程序集中的承载启动。 依赖项文件是一种可运行的应用资产，它通过发布应用而不是库来生成。</li>
<li>无法直接将库添加到<a href="/dotnet/core/deploying/runtime-store">运行时包存储</a>，该过程需要一个以已共享运行时为目标的可运行项目。</li>
</ul>
<p>创建动态承载启动过程中：</p>
<ul>
<li>从控制台应用创建承载启动程序集，无需以下入口点：
<ul>
<li>包含 <code>IHostingStartup</code> 实现的类。</li>
<li>包含用于识别 <code>IHostingStartup</code> 实现类的 <a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性。</li>
</ul>
</li>
<li>发布控制台应用，获取承载启动的依赖项。 发布控制台应用的结果是从依赖项文件中删除了未使用的依赖项。</li>
<li>修改依赖项文件以设置承载启动程序集的运行时位置。</li>
<li>承载启动程序集及其依赖项文件位于运行时包存储中。 要发现承载启动程序集及其依赖项文件，它们将在一对环境变量中列出。</li>
</ul>
<p>控制台应用引用 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Hosting.Abstractions/">Microsoft.AspNetCore.Hosting.Abstractions</a> 包：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>生成 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHost&gt; 时，<a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性将类标识为 <code>IHostingStartup</code> 的实现，用于加载和执行。 在下面的示例中，命名空间为 <code>StartupEnhancement</code>，类为 <code>StartupEnhancementHostingStartup</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>类实现 <code>IHostingStartup</code>。 该类的 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法使用 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder&gt; 向应用添加增强功能。 用户代码中 <code>Startup.Configure</code> 之前的运行时调用托管启动程序集中的 <code>IHostingStartup.Configure</code>，允许用户代码覆盖托管启动程序集提供的任何配置。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>生成 <code>IHostingStartup</code> 项目时，依赖项文件 (.deps.json) 将程序集的 <code>runtime</code> 位置设为 bin 文件夹 ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>仅显示部分文件。 示例中程序集的名称是 <code>StartupEnhancement</code>。</p>
<h2 id="configuration-provided-by-the-hosting-startup">托管启动提供的配置</h2>
<p>处理配置有两种方法，具体取决于是希望托管启动的配置优先还是应用的配置优先：</p>
<ol>
<li>使用 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 为应用提供配置，在应用的 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 委托执行后加载配置。 使用此方法，托管启动配置优先于应用的配置。</li>
<li>使用 &lt;xref:Microsoft.AspNetCore.Hosting.HostingAbstractionsWebHostBuilderExtensions.UseConfiguration*&gt; 为应用提供配置，在应用的 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 委托执行之前加载配置。 使用此方法，应用的配置值优先于托管启动程序提供的值。</li>
</ol>
<pre><code class="lang-csharp">public class ConfigurationInjection : IHostingStartup
{
    public void Configure(IWebHostBuilder builder)
    {
        Dictionary&lt;string, string&gt; dict;

        builder.ConfigureAppConfiguration(config =&gt;
        {
            dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;ConfigurationKey1&quot;, 
                    &quot;From IHostingStartup: Higher priority &quot; +
                    &quot;than the app's configuration.&quot;},
            };

            config.AddInMemoryCollection(dict);
        });

        dict = new Dictionary&lt;string, string&gt;
        {
            {&quot;ConfigurationKey2&quot;, 
                &quot;From IHostingStartup: Lower priority &quot; +
                &quot;than the app's configuration.&quot;},
        };

        var builtConfig = new ConfigurationBuilder()
            .AddInMemoryCollection(dict)
            .Build();

        builder.UseConfiguration(builtConfig);
    }
}
</code></pre>
<h2 id="specify-the-hosting-startup-assembly">指定承载启动程序集</h2>
<p>对于类库或控制台应用提供的承载启动，请在 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中指定承载启动程序集的名称。 环境变量是以分号分隔的程序集列表。</p>
<p>仅扫描承载启动程序集以查找 <code>HostingStartup</code> 属性。 对于示例应用 HostingStartupApp，要发现前述的承载启动，请将环境变量设置为以下值：</p>
<pre><code>HostingStartupLibrary;HostingStartupPackage;StartupDiagnostics
</code></pre>
<p>还可使用承载启动程序集主机配置设置来设置此承载启动程序集：</p>
<pre><code class="lang-csharp">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseSetting(
                    WebHostDefaults.HostingStartupAssembliesKey, 
                    &quot;{ASSEMBLY1;ASSEMBLY2; ...}&quot;)
                .UseStartup&lt;Startup&gt;();
        });
</code></pre>
<p>存在多个托管启动程序集时，将按列出程序集的顺序执行 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法。</p>
<h2 id="activation">激活</h2>
<p>承载启动激活的选项包括：</p>
<ul>
<li><a href="#runtime-store">运行时存储</a>：激活无需用于激活的编译时引用。 示例应用将承载启动程序集和依赖项文件放入文件夹“deployment”，以便在多计算机环境中部署承载启动。 “deployment”文件夹还包括 PowerShell 脚本，该脚本可在部署系统上创建或修改环境变量以启用承载启动。</li>
<li>激活所需的编译时引用
<ul>
<li><a href="#nuget-package">NuGet 包</a></li>
<li><a href="#project-bin-folder">项目 bin 文件夹</a></li>
</ul>
</li>
</ul>
<h3 id="runtime-store">运行时存储</h3>
<p>承载启动实现位于<a href="/dotnet/core/deploying/runtime-store">运行时存储</a>中。 增强型应用无需对程序集进行编译时引用。</p>
<p>构建承载启动后，使用清单项目文件和 <a href="/dotnet/core/tools/dotnet-store">dotnet store</a> 命令生成运行时存储。</p>
<pre><code class="lang-dotnetcli">dotnet store --manifest {MANIFEST FILE} --runtime {RUNTIME IDENTIFIER} --output {OUTPUT LOCATION} --skip-optimization
</code></pre>
<p>在示例应用（<em>RuntimeStore</em> 项目）中，使用以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet store --manifest store.manifest.csproj --runtime win7-x64 --output ./deployment/store --skip-optimization
</code></pre>
<p>对于发现运行时存储的运行时，运行时存储的位置将添加到 <code>DOTNET_SHARED_STORE</code> 环境变量中。</p>
<p><strong>修改并放置承载启动的依赖项文件</strong></p>
<p>要在未包引用增强功能的情况下激活增强功能，请使用 <code>additionalDeps</code> 为运行时指定附加依赖项。 使用 <code>additionalDeps</code>，你可以：</p>
<ul>
<li>通过提供一组附加的 .deps.json 文件来扩展应用的库图，以便在启动时与应用自身的 .deps.json 文件合并 。</li>
<li>使承载启动程序集可被发现并可加载。</li>
</ul>
<p>生成附加依赖项文件的推荐方法是：</p>
<ol>
<li>对上一节中引用的运行时存储清单文件执行 <code>dotnet publish</code>。</li>
<li>从库中删除清单引用，以及生成的 deps.json 文件的 <code>runtime</code> 部分。</li>
</ol>
<p>在示例项目中，<code>store.manifest/1.0.0</code> 属性已从 <code>targets</code> 和 <code>libraries</code> 部分中删除：</p>
<pre><code class="lang-json">{
  &quot;runtimeTarget&quot;: {
    &quot;name&quot;: &quot;.NETCoreApp,Version=v3.0&quot;,
    &quot;signature&quot;: &quot;&quot;
  },
  &quot;compilationOptions&quot;: {},
  &quot;targets&quot;: {
    &quot;.NETCoreApp,Version=v3.0&quot;: {
      &quot;store.manifest/1.0.0&quot;: {
        &quot;dependencies&quot;: {
          &quot;StartupDiagnostics&quot;: &quot;1.0.0&quot;
        },
        &quot;runtime&quot;: {
          &quot;store.manifest.dll&quot;: {}
        }
      },
      &quot;StartupDiagnostics/1.0.0&quot;: {
        &quot;runtime&quot;: {
          &quot;lib/netcoreapp3.0/StartupDiagnostics.dll&quot;: {
            &quot;assemblyVersion&quot;: &quot;1.0.0.0&quot;,
            &quot;fileVersion&quot;: &quot;1.0.0.0&quot;
          }
        }
      }
    }
  },
  &quot;libraries&quot;: {
    &quot;store.manifest/1.0.0&quot;: {
      &quot;type&quot;: &quot;project&quot;,
      &quot;serviceable&quot;: false,
      &quot;sha512&quot;: &quot;&quot;
    },
    &quot;StartupDiagnostics/1.0.0&quot;: {
      &quot;type&quot;: &quot;package&quot;,
      &quot;serviceable&quot;: true,
      &quot;sha512&quot;: &quot;sha512-xrhzuNSyM5/f4ZswhooJ9dmIYLP64wMnqUJSyTKVDKDVj5T+qtzypl8JmM/aFJLLpYrf0FYpVWvGujd7/FfMEw==&quot;,
      &quot;path&quot;: &quot;startupdiagnostics/1.0.0&quot;,
      &quot;hashPath&quot;: &quot;startupdiagnostics.1.0.0.nupkg.sha512&quot;
    }
  }
}
</code></pre>
<p>将 .deps.json 文件放入以下位置：</p>
<pre><code>{ADDITIONAL DEPENDENCIES PATH}/shared/{SHARED FRAMEWORK NAME}/{SHARED FRAMEWORK VERSION}/{ENHANCEMENT ASSEMBLY NAME}.deps.json
</code></pre>
<ul>
<li><code>{ADDITIONAL DEPENDENCIES PATH}</code>：添加到 <code>DOTNET_ADDITIONAL_DEPS</code> 环境变量的位置。</li>
<li><code>{SHARED FRAMEWORK NAME}</code>：此附加依赖项文件所必需的共享框架。</li>
<li><code>{SHARED FRAMEWORK VERSION}</code>：最低共享框架版本。</li>
<li><code>{ENHANCEMENT ASSEMBLY NAME}</code>：增强程序集名称。</li>
</ul>
<p>在示例应用（<em>RuntimeStore</em>  项目）中，附加依赖项文件放于以下位置：</p>
<pre><code>deployment/additionalDeps/shared/Microsoft.AspNetCore.App/3.0.0/StartupDiagnostics.deps.json
</code></pre>
<p>对于发现运行时存储位置的运行时，附加依赖项文件位置将添加到 <code>DOTNET_ADDITIONAL_DEPS</code> 环境变量中。</p>
<p>在示例应用（<em>RuntimeStore</em> 项目）中，使用 <a href="/powershell/scripting/powershell-scripting">PowerShell</a> 脚本完成构建运行时存储并生成附加依赖项文件。</p>
<p>有关如何设置各种操作系统的环境变量的示例，请参阅<a class="xref" href="../environments.html">使用多个环境</a>。</p>
<p><strong>部署</strong></p>
<p>为了便于在多计算机环境中部署托承载启动，示例应用在已发布的输出中创建一个“deployment”文件夹，其中包含：</p>
<ul>
<li>承载启动运行时存储。</li>
<li>承载启动依赖项文件。</li>
<li>PowerShell 脚本，用于创建或修改 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code>、<code>DOTNET_SHARED_STORE</code> 和 <code>DOTNET_ADDITIONAL_DEPS</code> 以支持激活承载启动。 从部署系统上的管理 PowerShell 命令提示符运行脚本。</li>
</ul>
<h3 id="nuget-package">NuGet 程序包</h3>
<p>可在 NuGet 包中提供承载启动增强。 该包含有 <code>HostingStartup</code> 属性。 包提供的承载启动类型使用以下任一方法提供给应用：</p>
<ul>
<li>增强型应用的项目文件在应用的项目文件（编译时引用）中为承载启动提供了包引用。 有了编译时引用，承载启动程序集及其所有依赖项都会合并到应用的依赖项文件 (.deps.json) 中。 此方法适用于已发布到 <a href="https://www.nuget.org/">nuget.org</a> 的承载启动程序集包。</li>
<li>承载启动的依赖项文件可用于增强型应用，如<a href="#runtime-store">运行时存储</a>部分所述（无编译时引用）。</li>
</ul>
<p>有关 NuGet 包和运行时存储的详细信息，请参阅以下主题：</p>
<ul>
<li><a href="/dotnet/core/deploying/creating-nuget-packages">如何使用跨平台工具创建 NuGet 包</a></li>
<li><a href="/nuget/create-packages/publish-a-package">发布包</a></li>
<li><a href="/dotnet/core/deploying/runtime-store">运行时包存储</a></li>
</ul>
<h3 id="project-bin-folder">项目 bin 文件夹</h3>
<p>承载启动增强功能可通过增强型应用中的 bin -deployed 程序集提供。 程序集提供的承载启动类型使用以下方法之一提供给应用：</p>
<ul>
<li>增强型应用的项目文件对承载启动进行了程序集引用（编译时引用）。 有了编译时引用，承载启动程序集及其所有依赖项都会合并到应用的依赖项文件 (.deps.json) 中。 当部署方案要求对承载启动程序集（.dll 文件）进行编译时引用并将程序集移动到以下任一位置时，此方法适用：
<ul>
<li>进行中的项目。</li>
<li>进行中的项目可访问的位置。</li>
</ul>
</li>
<li>承载启动的依赖项文件可用于增强型应用，如<a href="#runtime-store">运行时存储</a>部分所述（无编译时引用）。</li>
<li>在以 .NET Framework 为目标时，程序集可在默认加载上下文中加载，这在 .NET Framework 上表示程序集位于以下任一位置：
<ul>
<li>应用程序基路径：应用的可执行文件 (.exe) 所在的 bin 文件夹。</li>
<li>全局程序集缓存 (GAC)：GAC 存储多个 .NET Framework 应用共享的程序集。 有关详细信息，请参阅<a href="/dotnet/framework/app-domains/how-to-install-an-assembly-into-the-gac">如何：将程序集安装到 .NET Framework 文档中的全局程序集缓存</a>中。</li>
</ul>
</li>
</ul>
<h2 id="sample-code">示例代码</h2>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）演示了承载启动实现方案：</p>
<ul>
<li>两个承载启动程序集（类库）分别设置一对内存中配置键值对：
<ul>
<li>NuGet 包 (HostingStartupPackage)</li>
<li>类库 (HostingStartupLibrary)</li>
</ul>
</li>
<li>从运行时存储部署的程序集 (StartupDiagnostics) 激活承载启动。 该程序集在启动时将两个中间件添加到应用，用于提供以下内容的诊断信息：
<ul>
<li>已注册服务</li>
<li>地址（方案、主机、基路径、路径、查询字符串）</li>
<li>连接（远程 IP、远程端口、本地 IP、本地端口、客户端证书）</li>
<li>请求标头</li>
<li>环境变量</li>
</ul>
</li>
</ul>
<p>运行示例：</p>
<p><strong>从 NuGet 包激活</strong></p>
<ol>
<li><p>使用 <a href="/dotnet/core/tools/dotnet-pack">dotnet pack</a> 命令编译 HostingStartupPackage 包。</p>
</li>
<li><p>将包的程序集名称 HostingStartupPackage 添加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中。</p>
</li>
<li><p>编译并运行应用。 增强型应用中存在包引用（编译时引用）。 应用项目文件中的 <code>&lt;PropertyGroup&gt;</code> 指定包项目的输出 (../HostingStartupPackage/bin/Debug) 作为包源。 这允许应用使用该包而无需将包上传到 <a href="https://www.nuget.org/">nuget.org</a>。有关详细信息，请参阅 HostingStartupApp 项目文件中的说明。</p>
<pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;RestoreSources&gt;$(RestoreSources);https://api.nuget.org/v3/index.json;../HostingStartupPackage/bin/Debug&lt;/RestoreSources&gt;
&lt;/PropertyGroup&gt;
</code></pre>
</li>
<li><p>观察到索引页呈现的服务配置键值与包的 <code>ServiceKeyInjection.Configure</code> 方法设置的值匹配。</p>
</li>
</ol>
<p>如果更改并重新编译 HostingStartupPackage 项目，请清除本地 NuGet 包缓存，确保 HostingStartupApp 从本地缓存中收到更新后的包而不是旧包 。 要清除本地 NuGet 缓存，请执行以下 <a href="/dotnet/core/tools/dotnet-nuget-locals">dotnet nuget locals</a> 命令：</p>
<pre><code class="lang-dotnetcli">dotnet nuget locals all --clear
</code></pre>
<p><strong>从类库激活</strong></p>
<ol>
<li><p>使用 <a href="/dotnet/core/tools/dotnet-build">dotnet build</a> 命令编译 HostingStartupLibrary 类库。</p>
</li>
<li><p>将类库的程序集名称 HostingStartupLibrary 添加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中。</p>
</li>
<li><p>bin - 通过将类库编译输出中的 HostingStartupLibrary.dll 文件复制到应用的 bin/Debug 文件夹，将类库程序集部署到应用  。</p>
</li>
<li><p>编译并运行应用。 应用项目文件中的 <code>&lt;ItemGroup&gt;</code> 引用类库的程序集 (.\bin\Debug\netcoreapp3.0\HostingStartupLibrary.dll)（编译时引用）。 有关详细信息，请参阅 HostingStartupApp 项目文件中的说明。</p>
<pre><code class="lang-xml">&lt;ItemGroup&gt;
  &lt;Reference Include=&quot;.\\bin\\Debug\\netcoreapp3.0\\HostingStartupLibrary.dll&quot;&gt;
    &lt;HintPath&gt;.\bin\Debug\netcoreapp3.0\HostingStartupLibrary.dll&lt;/HintPath&gt;
    &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt; 
  &lt;/Reference&gt;
&lt;/ItemGroup&gt;
</code></pre>
</li>
<li><p>观察到索引页呈现的服务配置键值与类库的 <code>ServiceKeyInjection.Configure</code> 方法设置的值匹配。</p>
</li>
</ol>
<p><strong>从运行时存储部署的程序集激活</strong></p>
<ol>
<li>StartupDiagnostics 项目使用 <a href="/powershell/scripting/powershell-scripting">PowerShell</a> 修改其 StartupDiagnostics.deps.json 文件 。 默认情况下，Windows 7 SP1 和 Windows Server 2008 R2 SP1 及以后版本的 Windows 上安装有 PowerShell。 若要在其他平台上获取 PowerShell，请参阅<a href="/powershell/scripting/install/installing-powershell">安装各种版本的 PowerShell</a>。</li>
<li>执行 RuntimeStore文件夹中的 build.ps1 脚本 。 脚本：
<ul>
<li>在 obj\packages 文件夹中生成 <code>StartupDiagnostics</code> 包。</li>
<li>在 store 文件夹中生成 <code>StartupDiagnostics</code> 的运行时存储。 该脚本中的 <code>dotnet store</code> 命令使用 <code>win7-x64</code> <a href="/dotnet/core/rid-catalog">运行时标识符 (RID)</a> 将托管启动部署到 Windows。 为其他运行时提供托管启动程序集时，在脚本第 37 行上替换为正确的 RID。 <code>StartupDiagnostics</code> 的运行时存储稍后会移动到将使用程序集的计算机上的用户或系统的运行时存储。 <code>StartupDiagnostics</code> 程序集的用户运行时存储安装位置是 .dotnet/store/x64/netcoreapp3.0/startupdiagnostics/1.0.0/lib/netcoreapp3.0/StartupDiagnostics.dll。</li>
<li>在 additionalDeps 文件夹中生成 <code>StartupDiagnostics</code> 的 <code>additionalDeps</code>。 附加依赖项稍后会移动到用户或系统的附加依赖项。 用户 <code>StartupDiagnostics</code> 附加依赖项安装位置是 .dotnet/x64/additionalDeps/StartupDiagnostics/shared/Microsoft.NETCore.App/3.0.0/StartupDiagnostics.deps.json。</li>
<li>将 deploy.ps1 文件放置在 deployment 文件夹中。</li>
</ul>
</li>
<li>运行 deployment 文件夹中的 deploy.ps1 脚本 。 脚本将：
<ul>
<li><code>StartupDiagnostics</code> 追加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量。</li>
<li><code>DOTNET_ADDITIONAL_DEPS</code> 环境变量的承载启动依赖项路径（在 RuntimeStore 项目的 deployment 文件夹中）。</li>
<li><code>DOTNET_SHARED_STORE</code> 环境变量的运行时存储路径（在 RuntimeStore 项目的 deployment 文件夹中）。</li>
</ul>
</li>
<li>运行示例应用。</li>
<li>请求 <code>/services</code> 终结点以查看应用的注册服务。 请求 <code>/diag</code> 终结点以查看诊断信息。</li>
</ol>
</div>
<div range="&lt; aspnetcore-3.0">
<p>通过 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup&gt;（承载启动）实现，在启动时从外部程序集向应用添加增强功能。 例如，外部库可使用承载启动实现为应用提供其他配置提供程序或服务。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">查看或下载示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="hostingstartup-attribute">HostingStartup 属性</h2>
<p><a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性表示存在要在运行时激活的承载启动程序集。</p>
<p>将自动扫描输入程序集或包含 <code>Startup</code> 类的程序集以查找 <code>HostingStartup</code> 属性。 用于搜索 <code>HostingStartup</code> 属性的程序集列表在运行时从 <a href="xref:Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupAssembliesKey">WebHostDefaults.HostingStartupAssembliesKey</a> 中的配置加载。 要从发现中排除的程序集列表从 <a href="xref:Microsoft.AspNetCore.Hosting.WebHostDefaults.HostingStartupExcludeAssembliesKey">WebHostDefaults.HostingStartupExcludeAssembliesKey</a> 加载。 有关详细信息，请参阅 <a class="xref" href="web-host.html#hosting-startup-assemblies">Web 主机：承载启动程序集</a>和 <a class="xref" href="web-host.html#hosting-startup-exclude-assemblies">Web 主机：承载启动排除程序集</a>。</p>
<p>在以下示例中，承载启动程序集的命名空间为 <code>StartupEnhancement</code>。 包含承载启动代码的类是 <code>StartupEnhancementHostingStartup</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>HostingStartup</code> 属性通常位于承载启动程序集的 <code>IHostingStartup</code> 实现类文件中。</p>
<h2 id="discover-loaded-hosting-startup-assemblies">发现加载的承载启动程序集</h2>
<p>要发现加载的承载启动程序集，请启用日志记录并检查应用的日志。 记录加载程序集时发生的错误。 会在调试级别记录加载的承载启动程序集，并记录所有错误。</p>
<h2 id="disable-automatic-loading-of-hosting-startup-assemblies">禁用承载启动程序集的自动加载</h2>
<p>要禁用承载启动程序集的自动加载，请使用以下方法之一：</p>
<ul>
<li>要阻止加载所有承载启动程序集，请将以下内容之一设置为 <code>true</code> 或 <code>1</code>：
<ul>
<li><a class="xref" href="web-host.html#prevent-hosting-startup">阻止承载启动</a>主机配置设置。</li>
<li><code>ASPNETCORE_PREVENTHOSTINGSTARTUP</code> 环境变量。</li>
</ul>
</li>
<li>要阻止加载特定的承载启动程序集，请将以下之一设置为以分号分隔的承载启动程序集字符串，以便在启动时排除：
<ul>
<li><a class="xref" href="web-host.html#hosting-startup-exclude-assemblies">承载启动排除程序集</a>承载配置设置。</li>
<li><code>ASPNETCORE_HOSTINGSTARTUPEXCLUDEASSEMBLIES</code> 环境变量。</li>
</ul>
</li>
</ul>
<p>如果同时设置了主机配置设置和环境变量，则主机设置将控制行为。</p>
<p>如果使用主机设置或环境变量来禁用承载启动程序集，将全局禁用程序集，并可能会禁用应用的多个特征。</p>
<h2 id="project">项目</h2>
<p>使用以下任一项目类型创建承载启动：</p>
<ul>
<li><a href="#class-library">类库</a></li>
<li><a href="#console-app-without-an-entry-point">无入口点的控制台应用</a></li>
</ul>
<h3 id="class-library">类库</h3>
<p>可在类库中提供承载启动增强。 库包含 <code>HostingStartup</code> 属性。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>包括 Razor Pages 应用、HostingStartupApp 和类库 HostingStartupLibrary 。 类库：</p>
<ul>
<li>包含承载启动类 <code>ServiceKeyInjection</code>，用于实现 <code>IHostingStartup</code>。 <code>ServiceKeyInjection</code> 使用内存中配置提供程序 (<a href="xref:Microsoft.Extensions.Configuration.MemoryConfigurationBuilderExtensions.AddInMemoryCollection*">AddInMemoryCollection</a>) 将一对服务字符串添加到应用的配置中。</li>
<li>包含 <code>HostingStartup</code> 属性，用于标识承载启动的命名空间和类。</li>
</ul>
<p><code>ServiceKeyInjection</code> 类的 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法使用 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder&gt; 向应用添加增强功能。</p>
<p>HostingStartupLibrary/ServiceKeyInjection.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>应用的索引页读取并呈现类库承载启动程序集设置的两个键的配置值：</p>
<p>HostingStartupApp/Pages/Index.cshtml.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>还包括一个 NuGet 包项目，该项目提供单独的承载启动 HostingStartupPackage。 该包具有与前述类库相同的特征。 包：</p>
<ul>
<li>包含承载启动类 <code>ServiceKeyInjection</code>，用于实现 <code>IHostingStartup</code>。 <code>ServiceKeyInjection</code> 将一对服务字符串添加到应用的配置中。</li>
<li>包含 <code>HostingStartup</code> 属性。</li>
</ul>
<p>HostingStartupPackage/ServiceKeyInjection.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>应用的索引页读取并呈现包承载启动程序集设置的两个键的配置值：</p>
<p>HostingStartupApp/Pages/Index.cshtml.cs：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="console-app-without-an-entry-point">无入口点的控制台应用</h3>
<p>此方法仅适用于 .NET Core 应用，不适用于 .NET Framework。</p>
<p>可在包含 <code>HostingStartup</code> 属性的无入口点的控制台应用中提供动态承载启动增强功能，该功能无需编译时引用进行激活。 发布控制台应用会生成可从运行时存储中使用的承载启动程序集。</p>
<p>此过程中使用没有入口点的控制台应用，因为：</p>
<ul>
<li>需要依赖项文件来使用承载启动程序集中的承载启动。 依赖项文件是一种可运行的应用资产，它通过发布应用而不是库来生成。</li>
<li>无法直接将库添加到<a href="/dotnet/core/deploying/runtime-store">运行时包存储</a>，该过程需要一个以已共享运行时为目标的可运行项目。</li>
</ul>
<p>创建动态承载启动过程中：</p>
<ul>
<li>从控制台应用创建承载启动程序集，无需以下入口点：
<ul>
<li>包含 <code>IHostingStartup</code> 实现的类。</li>
<li>包含用于识别 <code>IHostingStartup</code> 实现类的 <a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性。</li>
</ul>
</li>
<li>发布控制台应用，获取承载启动的依赖项。 发布控制台应用的结果是从依赖项文件中删除了未使用的依赖项。</li>
<li>修改依赖项文件以设置承载启动程序集的运行时位置。</li>
<li>承载启动程序集及其依赖项文件位于运行时包存储中。 要发现承载启动程序集及其依赖项文件，它们将在一对环境变量中列出。</li>
</ul>
<p>控制台应用引用 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Hosting.Abstractions/">Microsoft.AspNetCore.Hosting.Abstractions</a> 包：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>生成 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHost&gt; 时，<a href="xref:Microsoft.AspNetCore.Hosting.HostingStartupAttribute">HostingStartup</a> 属性将类标识为 <code>IHostingStartup</code> 的实现，用于加载和执行。 在下面的示例中，命名空间为 <code>StartupEnhancement</code>，类为 <code>StartupEnhancementHostingStartup</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>类实现 <code>IHostingStartup</code>。 该类的 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法使用 &lt;xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder&gt; 向应用添加增强功能。 用户代码中 <code>Startup.Configure</code> 之前的运行时调用托管启动程序集中的 <code>IHostingStartup.Configure</code>，允许用户代码覆盖托管启动程序集提供的任何配置。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>生成 <code>IHostingStartup</code> 项目时，依赖项文件 (.deps.json) 将程序集的 <code>runtime</code> 位置设为 bin 文件夹 ：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>仅显示部分文件。 示例中程序集的名称是 <code>StartupEnhancement</code>。</p>
<h2 id="configuration-provided-by-the-hosting-startup">托管启动提供的配置</h2>
<p>处理配置有两种方法，具体取决于是希望托管启动的配置优先还是应用的配置优先：</p>
<ol>
<li>使用 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 为应用提供配置，在应用的 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 委托执行后加载配置。 使用此方法，托管启动配置优先于应用的配置。</li>
<li>使用 &lt;xref:Microsoft.AspNetCore.Hosting.HostingAbstractionsWebHostBuilderExtensions.UseConfiguration*&gt; 为应用提供配置，在应用的 &lt;xref:Microsoft.AspNetCore.Hosting.WebHostBuilder.ConfigureAppConfiguration*&gt; 委托执行之前加载配置。 使用此方法，应用的配置值优先于托管启动程序提供的值。</li>
</ol>
<pre><code class="lang-csharp">public class ConfigurationInjection : IHostingStartup
{
    public void Configure(IWebHostBuilder builder)
    {
        Dictionary&lt;string, string&gt; dict;

        builder.ConfigureAppConfiguration(config =&gt;
        {
            dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;ConfigurationKey1&quot;, 
                    &quot;From IHostingStartup: Higher priority &quot; +
                    &quot;than the app's configuration.&quot;},
            };

            config.AddInMemoryCollection(dict);
        });

        dict = new Dictionary&lt;string, string&gt;
        {
            {&quot;ConfigurationKey2&quot;, 
                &quot;From IHostingStartup: Lower priority &quot; +
                &quot;than the app's configuration.&quot;},
        };

        var builtConfig = new ConfigurationBuilder()
            .AddInMemoryCollection(dict)
            .Build();

        builder.UseConfiguration(builtConfig);
    }
}
</code></pre>
<h2 id="specify-the-hosting-startup-assembly">指定承载启动程序集</h2>
<p>对于类库或控制台应用提供的承载启动，请在 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中指定承载启动程序集的名称。 环境变量是以分号分隔的程序集列表。</p>
<p>仅扫描承载启动程序集以查找 <code>HostingStartup</code> 属性。 对于示例应用 HostingStartupApp，要发现前述的承载启动，请将环境变量设置为以下值：</p>
<pre><code>HostingStartupLibrary;HostingStartupPackage;StartupDiagnostics
</code></pre>
<p>还可使用<a class="xref" href="web-host.html#hosting-startup-assemblies">承载启动程序集</a>主机配置设置来设置此承载启动程序集。</p>
<p>存在多个托管启动程序集时，将按列出程序集的顺序执行 &lt;xref:Microsoft.AspNetCore.Hosting.IHostingStartup.Configure*&gt; 方法。</p>
<h2 id="activation">激活</h2>
<p>承载启动激活的选项包括：</p>
<ul>
<li><a href="#runtime-store">运行时存储</a>：激活无需用于激活的编译时引用。 示例应用将承载启动程序集和依赖项文件放入文件夹“deployment”，以便在多计算机环境中部署承载启动。 “deployment”文件夹还包括 PowerShell 脚本，该脚本可在部署系统上创建或修改环境变量以启用承载启动。</li>
<li>激活所需的编译时引用
<ul>
<li><a href="#nuget-package">NuGet 包</a></li>
<li><a href="#project-bin-folder">项目 bin 文件夹</a></li>
</ul>
</li>
</ul>
<h3 id="runtime-store">运行时存储</h3>
<p>承载启动实现位于<a href="/dotnet/core/deploying/runtime-store">运行时存储</a>中。 增强型应用无需对程序集进行编译时引用。</p>
<p>构建承载启动后，使用清单项目文件和 <a href="/dotnet/core/tools/dotnet-store">dotnet store</a> 命令生成运行时存储。</p>
<pre><code class="lang-dotnetcli">dotnet store --manifest {MANIFEST FILE} --runtime {RUNTIME IDENTIFIER} --output {OUTPUT LOCATION} --skip-optimization
</code></pre>
<p>在示例应用（<em>RuntimeStore</em> 项目）中，使用以下命令：</p>
<pre><code class="lang-dotnetcli">dotnet store --manifest store.manifest.csproj --runtime win7-x64 --output ./deployment/store --skip-optimization
</code></pre>
<p>对于发现运行时存储的运行时，运行时存储的位置将添加到 <code>DOTNET_SHARED_STORE</code> 环境变量中。</p>
<p><strong>修改并放置承载启动的依赖项文件</strong></p>
<p>要在未包引用增强功能的情况下激活增强功能，请使用 <code>additionalDeps</code> 为运行时指定附加依赖项。 使用 <code>additionalDeps</code>，你可以：</p>
<ul>
<li>通过提供一组附加的 .deps.json 文件来扩展应用的库图，以便在启动时与应用自身的 .deps.json 文件合并 。</li>
<li>使承载启动程序集可被发现并可加载。</li>
</ul>
<p>生成附加依赖项文件的推荐方法是：</p>
<ol>
<li>对上一节中引用的运行时存储清单文件执行 <code>dotnet publish</code>。</li>
<li>从库中删除清单引用，以及生成的 deps.json 文件的 <code>runtime</code> 部分。</li>
</ol>
<p>在示例项目中，<code>store.manifest/1.0.0</code> 属性已从 <code>targets</code> 和 <code>libraries</code> 部分中删除：</p>
<pre><code class="lang-json">{
  &quot;runtimeTarget&quot;: {
    &quot;name&quot;: &quot;.NETCoreApp,Version=v2.1&quot;,
    &quot;signature&quot;: &quot;4ea77c7b75ad1895ae1ea65e6ba2399010514f99&quot;
  },
  &quot;compilationOptions&quot;: {},
  &quot;targets&quot;: {
    &quot;.NETCoreApp,Version=v2.1&quot;: {
      &quot;store.manifest/1.0.0&quot;: {
        &quot;dependencies&quot;: {
          &quot;StartupDiagnostics&quot;: &quot;1.0.0&quot;
        },
        &quot;runtime&quot;: {
          &quot;store.manifest.dll&quot;: {}
        }
      },
      &quot;StartupDiagnostics/1.0.0&quot;: {
        &quot;runtime&quot;: {
          &quot;lib/netcoreapp2.1/StartupDiagnostics.dll&quot;: {
            &quot;assemblyVersion&quot;: &quot;1.0.0.0&quot;,
            &quot;fileVersion&quot;: &quot;1.0.0.0&quot;
          }
        }
      }
    }
  },
  &quot;libraries&quot;: {
    &quot;store.manifest/1.0.0&quot;: {
      &quot;type&quot;: &quot;project&quot;,
      &quot;serviceable&quot;: false,
      &quot;sha512&quot;: &quot;&quot;
    },
    &quot;StartupDiagnostics/1.0.0&quot;: {
      &quot;type&quot;: &quot;package&quot;,
      &quot;serviceable&quot;: true,
      &quot;sha512&quot;: &quot;sha512-oiQr60vBQW7+nBTmgKLSldj06WNLRTdhOZpAdEbCuapoZ+M2DJH2uQbRLvFT8EGAAv4TAKzNtcztpx5YOgBXQQ==&quot;,
      &quot;path&quot;: &quot;startupdiagnostics/1.0.0&quot;,
      &quot;hashPath&quot;: &quot;startupdiagnostics.1.0.0.nupkg.sha512&quot;
    }
  }
}
</code></pre>
<p>将 .deps.json 文件放入以下位置：</p>
<pre><code>{ADDITIONAL DEPENDENCIES PATH}/shared/{SHARED FRAMEWORK NAME}/{SHARED FRAMEWORK VERSION}/{ENHANCEMENT ASSEMBLY NAME}.deps.json
</code></pre>
<ul>
<li><code>{ADDITIONAL DEPENDENCIES PATH}</code>：添加到 <code>DOTNET_ADDITIONAL_DEPS</code> 环境变量的位置。</li>
<li><code>{SHARED FRAMEWORK NAME}</code>：此附加依赖项文件所必需的共享框架。</li>
<li><code>{SHARED FRAMEWORK VERSION}</code>：最低共享框架版本。</li>
<li><code>{ENHANCEMENT ASSEMBLY NAME}</code>：增强程序集名称。</li>
</ul>
<p>在示例应用（<em>RuntimeStore</em>  项目）中，附加依赖项文件放于以下位置：</p>
<pre><code>deployment/additionalDeps/shared/Microsoft.AspNetCore.App/2.1.0/StartupDiagnostics.deps.json
</code></pre>
<p>对于发现运行时存储位置的运行时，附加依赖项文件位置将添加到 <code>DOTNET_ADDITIONAL_DEPS</code> 环境变量中。</p>
<p>在示例应用（<em>RuntimeStore</em> 项目）中，使用 <a href="/powershell/scripting/powershell-scripting">PowerShell</a> 脚本完成构建运行时存储并生成附加依赖项文件。</p>
<p>有关如何设置各种操作系统的环境变量的示例，请参阅<a class="xref" href="../environments.html">使用多个环境</a>。</p>
<p><strong>部署</strong></p>
<p>为了便于在多计算机环境中部署托承载启动，示例应用在已发布的输出中创建一个“deployment”文件夹，其中包含：</p>
<ul>
<li>承载启动运行时存储。</li>
<li>承载启动依赖项文件。</li>
<li>PowerShell 脚本，用于创建或修改 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code>、<code>DOTNET_SHARED_STORE</code> 和 <code>DOTNET_ADDITIONAL_DEPS</code> 以支持激活承载启动。 从部署系统上的管理 PowerShell 命令提示符运行脚本。</li>
</ul>
<h3 id="nuget-package">NuGet 程序包</h3>
<p>可在 NuGet 包中提供承载启动增强。 该包含有 <code>HostingStartup</code> 属性。 包提供的承载启动类型使用以下任一方法提供给应用：</p>
<ul>
<li>增强型应用的项目文件在应用的项目文件（编译时引用）中为承载启动提供了包引用。 有了编译时引用，承载启动程序集及其所有依赖项都会合并到应用的依赖项文件 (.deps.json) 中。 此方法适用于已发布到 <a href="https://www.nuget.org/">nuget.org</a> 的承载启动程序集包。</li>
<li>承载启动的依赖项文件可用于增强型应用，如<a href="#runtime-store">运行时存储</a>部分所述（无编译时引用）。</li>
</ul>
<p>有关 NuGet 包和运行时存储的详细信息，请参阅以下主题：</p>
<ul>
<li><a href="/dotnet/core/deploying/creating-nuget-packages">如何使用跨平台工具创建 NuGet 包</a></li>
<li><a href="/nuget/create-packages/publish-a-package">发布包</a></li>
<li><a href="/dotnet/core/deploying/runtime-store">运行时包存储</a></li>
</ul>
<h3 id="project-bin-folder">项目 bin 文件夹</h3>
<p>承载启动增强功能可通过增强型应用中的 bin -deployed 程序集提供。 程序集提供的承载启动类型使用以下方法之一提供给应用：</p>
<ul>
<li>增强型应用的项目文件对承载启动进行了程序集引用（编译时引用）。 有了编译时引用，承载启动程序集及其所有依赖项都会合并到应用的依赖项文件 (.deps.json) 中。 当部署方案要求对承载启动程序集（.dll 文件）进行编译时引用并将程序集移动到以下任一位置时，此方法适用：
<ul>
<li>进行中的项目。</li>
<li>进行中的项目可访问的位置。</li>
</ul>
</li>
<li>承载启动的依赖项文件可用于增强型应用，如<a href="#runtime-store">运行时存储</a>部分所述（无编译时引用）。</li>
<li>在以 .NET Framework 为目标时，程序集可在默认加载上下文中加载，这在 .NET Framework 上表示程序集位于以下任一位置：
<ul>
<li>应用程序基路径：应用的可执行文件 (.exe) 所在的 bin 文件夹。</li>
<li>全局程序集缓存 (GAC)：GAC 存储多个 .NET Framework 应用共享的程序集。 有关详细信息，请参阅<a href="/dotnet/framework/app-domains/how-to-install-an-assembly-into-the-gac">如何：将程序集安装到 .NET Framework 文档中的全局程序集缓存</a>中。</li>
</ul>
</li>
</ul>
<h2 id="sample-code">示例代码</h2>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/platform-specific-configuration/samples/">示例代码</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）演示了承载启动实现方案：</p>
<ul>
<li>两个承载启动程序集（类库）分别设置一对内存中配置键值对：
<ul>
<li>NuGet 包 (HostingStartupPackage)</li>
<li>类库 (HostingStartupLibrary)</li>
</ul>
</li>
<li>从运行时存储部署的程序集 (StartupDiagnostics) 激活承载启动。 该程序集在启动时将两个中间件添加到应用，用于提供以下内容的诊断信息：
<ul>
<li>已注册服务</li>
<li>地址（方案、主机、基路径、路径、查询字符串）</li>
<li>连接（远程 IP、远程端口、本地 IP、本地端口、客户端证书）</li>
<li>请求标头</li>
<li>环境变量</li>
</ul>
</li>
</ul>
<p>运行示例：</p>
<p><strong>从 NuGet 包激活</strong></p>
<ol>
<li><p>使用 <a href="/dotnet/core/tools/dotnet-pack">dotnet pack</a> 命令编译 HostingStartupPackage 包。</p>
</li>
<li><p>将包的程序集名称 HostingStartupPackage 添加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中。</p>
</li>
<li><p>编译并运行应用。 增强型应用中存在包引用（编译时引用）。 应用项目文件中的 <code>&lt;PropertyGroup&gt;</code> 指定包项目的输出 (../HostingStartupPackage/bin/Debug) 作为包源。 这允许应用使用该包而无需将包上传到 <a href="https://www.nuget.org/">nuget.org</a>。有关详细信息，请参阅 HostingStartupApp 项目文件中的说明。</p>
<pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;RestoreSources&gt;$(RestoreSources);https://api.nuget.org/v3/index.json;../HostingStartupPackage/bin/Debug&lt;/RestoreSources&gt;
&lt;/PropertyGroup&gt;
</code></pre>
</li>
<li><p>观察到索引页呈现的服务配置键值与包的 <code>ServiceKeyInjection.Configure</code> 方法设置的值匹配。</p>
</li>
</ol>
<p>如果更改并重新编译 HostingStartupPackage 项目，请清除本地 NuGet 包缓存，确保 HostingStartupApp 从本地缓存中收到更新后的包而不是旧包 。 要清除本地 NuGet 缓存，请执行以下 <a href="/dotnet/core/tools/dotnet-nuget-locals">dotnet nuget locals</a> 命令：</p>
<pre><code class="lang-dotnetcli">dotnet nuget locals all --clear
</code></pre>
<p><strong>从类库激活</strong></p>
<ol>
<li><p>使用 <a href="/dotnet/core/tools/dotnet-build">dotnet build</a> 命令编译 HostingStartupLibrary 类库。</p>
</li>
<li><p>将类库的程序集名称 HostingStartupLibrary 添加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量中。</p>
</li>
<li><p>bin - 通过将类库编译输出中的 HostingStartupLibrary.dll 文件复制到应用的 bin/Debug 文件夹，将类库程序集部署到应用  。</p>
</li>
<li><p>编译并运行应用。 应用项目文件中的 <code>&lt;ItemGroup&gt;</code> 引用类库的程序集 (.\bin\Debug\netcoreapp2.1\HostingStartupLibrary.dll)（编译时引用）。 有关详细信息，请参阅 HostingStartupApp 项目文件中的说明。</p>
<pre><code class="lang-xml">&lt;ItemGroup&gt;
  &lt;Reference Include=&quot;.\\bin\\Debug\\netcoreapp2.1\\HostingStartupLibrary.dll&quot;&gt;
    &lt;HintPath&gt;.\bin\Debug\netcoreapp2.1\HostingStartupLibrary.dll&lt;/HintPath&gt;
    &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
  &lt;/Reference&gt;
&lt;/ItemGroup&gt;
</code></pre>
</li>
<li><p>观察到索引页呈现的服务配置键值与类库的 <code>ServiceKeyInjection.Configure</code> 方法设置的值匹配。</p>
</li>
</ol>
<p><strong>从运行时存储部署的程序集激活</strong></p>
<ol>
<li>StartupDiagnostics 项目使用 <a href="/powershell/scripting/powershell-scripting">PowerShell</a> 修改其 StartupDiagnostics.deps.json 文件 。 默认情况下，Windows 7 SP1 和 Windows Server 2008 R2 SP1 及以后版本的 Windows 上安装有 PowerShell。 若要在其他平台上获取 PowerShell，请参阅<a href="/powershell/scripting/install/installing-powershell">安装各种版本的 PowerShell</a>。</li>
<li>执行 RuntimeStore文件夹中的 build.ps1 脚本 。 脚本：
<ul>
<li>在 obj\packages 文件夹中生成 <code>StartupDiagnostics</code> 包。</li>
<li>在 store 文件夹中生成 <code>StartupDiagnostics</code> 的运行时存储。 该脚本中的 <code>dotnet store</code> 命令使用 <code>win7-x64</code> <a href="/dotnet/core/rid-catalog">运行时标识符 (RID)</a> 将托管启动部署到 Windows。 为其他运行时提供托管启动程序集时，在脚本第 37 行上替换为正确的 RID。 <code>StartupDiagnostics</code> 的运行时存储稍后会移动到将使用程序集的计算机上的用户或系统的运行时存储。 <code>StartupDiagnostics</code> 程序集的用户运行时存储安装位置是 .dotnet/store/x64/netcoreapp2.2/startupdiagnostics/1.0.0/lib/netcoreapp2.2/StartupDiagnostics.dll。</li>
<li>在 additionalDeps 文件夹中生成 <code>StartupDiagnostics</code> 的 <code>additionalDeps</code>。 附加依赖项稍后会移动到用户或系统的附加依赖项。 用户 <code>StartupDiagnostics</code> 附加依赖项安装位置是 .dotnet/x64/additionalDeps/StartupDiagnostics/shared/Microsoft.NETCore.App/2.2.0/StartupDiagnostics.deps.json。</li>
<li>将 deploy.ps1 文件放置在 deployment 文件夹中。</li>
</ul>
</li>
<li>运行 deployment 文件夹中的 deploy.ps1 脚本 。 脚本将：
<ul>
<li><code>StartupDiagnostics</code> 追加到 <code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code> 环境变量。</li>
<li><code>DOTNET_ADDITIONAL_DEPS</code> 环境变量的承载启动依赖项路径（在 RuntimeStore 项目的 deployment 文件夹中）。</li>
<li><code>DOTNET_SHARED_STORE</code> 环境变量的运行时存储路径（在 RuntimeStore 项目的 deployment 文件夹中）。</li>
</ul>
</li>
<li>运行示例应用。</li>
<li>请求 <code>/services</code> 终结点以查看应用的注册服务。 请求 <code>/diag</code> 终结点以查看诊断信息。</li>
</ol>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
