<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core Web &#20027;&#26426; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core Web &#20027;&#26426; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="fundamentals/host/web-host">
<h1 id="aspnet-core-web-host">ASP.NET Core Web 主机</h1>

<p>ASP.NET Core 应用配置和启动“主机”。 主机负责应用程序启动和生存期管理。 至少，主机配置服务器和请求处理管道。 主机还可以设置日志记录、依赖关系注入和配置。</p>
<div range="&gt;= aspnetcore-3.0">
<p>本文介绍了只适用于实现后向兼容性的 Web 主机。 建议对所有应用类型使用<a class="xref" href="generic-host.html">通用主机</a>。</p>
</div>
<div range="&lt; aspnetcore-3.0">
<p>本文介绍了用于托管 Web 应用的 Web 主机。 对于其他类型的应用，请使用<a class="xref" href="generic-host.html">通用主机</a>。</p>
</div>
<h2 id="set-up-a-host">设置主机</h2>
<p>创建使用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.iwebhostbuilder">IWebHostBuilder</a> 实例的主机。 通常在应用的入口点来执行 <code>Main</code> 方法。</p>
<p>在项目模板中，<code>Main</code> 位于 Program.cs。 典型应用调用 <a href="/dotnet/api/microsoft.aspnetcore.webhost.createdefaultbuilder">CreateDefaultBuilder</a> 来开始创建主机：</p>
<pre><code class="lang-csharp">public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&lt;Startup&gt;();
}
</code></pre>
<p>调用 <code>CreateDefaultBuilder</code> 的代码位于名为 <code>CreateWebHostBuilder</code> 的方法中，这让它区分于 <code>Main</code> 中对生成器对象调用 <code>Run</code> 的代码。 如果使用 <a href="/ef/core/miscellaneous/cli/">Entity Framework Core 工具</a>，必须有这种区分。 这些工具希望找到 <code>CreateWebHostBuilder</code> 方法，可以在设计时调用此方法来配置主机，而无需运行应用。 一种替代方法是实现 <code>IDesignTimeDbContextFactory</code>。 有关详细信息，请参阅<a href="/ef/core/miscellaneous/cli/dbcontext-creation">设计时 DbContext 创建</a>。</p>
<p><code>CreateDefaultBuilder</code> 执行下列任务：</p>
<ul>
<li>使用应用的托管配置提供程序将 <a class="xref" href="../servers/kestrel.html">Kestrel</a> 服务器配置为 Web 服务器。 有关 Kestrel 服务器默认选项，请参阅 <a class="xref" href="../servers/kestrel.html#kestrel-options">ASP.NET Core 中的 Kestrel Web 服务器实现</a>。</li>
<li>将<a class="xref" href="../index.html#content-root">内容根目录</a>设置为由 <a href="/dotnet/api/system.io.directory.getcurrentdirectory">Directory.GetCurrentDirectory</a> 返回的路径。</li>
<li>通过以下对象加载<a href="#host-configuration-values">主机配置</a>：
<ul>
<li>前缀为 <code>ASPNETCORE_</code> 的环境变量（例如，<code>ASPNETCORE_ENVIRONMENT</code>）。</li>
<li>命令行参数。</li>
</ul>
</li>
<li>按以下顺序加载应用配置：
<ul>
<li>appsettings.json。</li>
<li>appsettings.{Environment}.json。</li>
<li>应用在使用入口程序集的 <code>Development</code> 环境中运行时的<a class="xref" href="../../security/app-secrets.html">机密管理器</a>。</li>
<li>环境变量。</li>
<li>命令行参数。</li>
</ul>
</li>
<li>配置控制台和调试输出的<a class="xref" href="../logging/index.html">日志记录</a>。 日志记录包含 appsettings.json 或 appsettings.{Environment}.json 文件的日志记录配置部分中指定的<a class="xref" href="../logging/index.html#log-filtering">日志筛选</a>规则 。</li>
<li>使用 <a class="xref" href="../../host-and-deploy/aspnet-core-module.html">ASP.NET Core 模块</a>在 IIS 后面运行时，<code>CreateDefaultBuilder</code> 会启用 <a class="xref" href="../../host-and-deploy/iis/index.html">IIS 集成</a>，这会配置应用的基址和端口。 IIS 集成还配置应用以<a href="#capture-startup-errors">捕获启动错误</a>。 有关 IIS 默认选项，请参阅 <a class="xref" href="../../host-and-deploy/iis/index.html#iis-options">使用 IIS 在 Windows 上托管 ASP.NET Core</a>。</li>
<li>如果应用环境为“开发”，请将 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions.validatescopes">ServiceProviderOptions.ValidateScopes</a> 设为 <code>true</code>。 有关详细信息，请参阅<a href="#scope-validation">作用域验证</a>。</li>
</ul>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.configureappconfiguration">ConfigureAppConfiguration</a>、<a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.configurelogging">ConfigureLogging</a> 以及 <a href="/dotnet/api/microsoft.aspnetcore.hosting.iwebhostbuilder">IWebHostBuilder</a> 的其他方法和扩展方法可重写和增强 <code>CreateDefaultBuilder</code> 定义的配置。 下面是一些示例：</p>
<ul>
<li><p><a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.configureappconfiguration">ConfigureAppConfiguration</a> 用于指定应用的其他 <code>IConfiguration</code>。 下面的 <code>ConfigureAppConfiguration</code> 调用添加委托，以在 appsettings.xml 文件中添加应用配置。 可多次调用 <code>ConfigureAppConfiguration</code>。 请注意，此配置不适用于主机（例如，服务器 URL 或环境）。 请参阅<a href="#host-configuration-values">主机配置值</a>部分。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((hostingContext, config) =&gt;
    {
        config.AddXmlFile(&quot;appsettings.xml&quot;, optional: true, reloadOnChange: true);
    })
    ...
</code></pre>
</li>
<li><p>下面的 <code>ConfigureLogging</code> 调用添加委托，以将最小日志记录级别 (<a href="/dotnet/api/microsoft.extensions.logging.loggingbuilderextensions.setminimumlevel">SetMinimumLevel</a>) 配置为 <a href="/dotnet/api/microsoft.extensions.logging.loglevel">LogLevel.Warning</a>。 此设置重写 <code>CreateDefaultBuilder</code> 在 appsettings.Development.json 和 appsettings.Production.json 中配置的设置，分别为 <code>LogLevel.Debug</code> 和 <code>LogLevel.Error</code>。 可多次调用 <code>ConfigureLogging</code>。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .ConfigureLogging(logging =&gt; 
    {
        logging.SetMinimumLevel(LogLevel.Warning);
    })
    ...
</code></pre>
</li>
</ul>
<div range="&gt;= aspnetcore-2.2">
<ul>
<li><p>下面调用 <code>ConfigureKestrel</code> 来重写 <code>CreateDefaultBuilder</code> 在配置 Kestrel 时建立的 30,000,000 字节默认 <a href="/dotnet/api/microsoft.aspnetcore.server.kestrel.core.kestrelserverlimits.maxrequestbodysize">Limits.MaxRequestBodySize</a>：</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .ConfigureKestrel((context, options) =&gt;
    {
        options.Limits.MaxRequestBodySize = 20000000;
    });
</code></pre>
</li>
</ul>
</div>
<div range="&lt; aspnetcore-2.2">
<ul>
<li><p>下面调用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderkestrelextensions.usekestrel">UseKestrel</a> 来重写 <code>CreateDefaultBuilder</code> 在配置 Kestrel 时建立的 30,000,000 字节默认 <a href="/dotnet/api/microsoft.aspnetcore.server.kestrel.core.kestrelserverlimits.maxrequestbodysize">Limits.MaxRequestBodySize</a>：</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseKestrel(options =&gt;
    {
        options.Limits.MaxRequestBodySize = 20000000;
    });
</code></pre>
</li>
</ul>
</div>
<p><a class="xref" href="../index.html#content-root">内容根</a> 确定主机搜索内容文件（如 MVC 视图文件）的位置。 应用从项目的根文件夹启动时，会将项目的根文件夹用作内容根。 这是 <a href="https://visualstudio.microsoft.com">Visual Studio</a> 和 <a href="/dotnet/core/tools/dotnet-new">dotnet new 模板</a>中使用的默认值。</p>
<p>有关应用配置的详细信息，请参阅 <a class="xref" href="../configuration/index.html">ASP.NET Core 中的配置</a>。</p>
<div class="NOTE">
<h5>Note</h5>
<p>作为使用静态 <code>CreateDefaultBuilder</code> 方法的替代方法，从 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder">WebHostBuilder</a> 创建主机是一种受 ASP.NET Core 2.x 支持的方法。</p>
</div>
<p>设置主机时，可以提供<a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.configure">配置</a>和 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder.configureservices">ConfigureServices</a> 方法。 如果指定 <code>Startup</code> 类，必须定义 <code>Configure</code> 方法。 有关详细信息，请参阅 <a class="xref" href="../startup.html">ASP.NET Core 中的应用启动</a>。 多次调用 <code>ConfigureServices</code> 将追加到另一个。 多次调用 <code>WebHostBuilder</code> 上的 <code>Configure</code> 或 <code>UseStartup</code> 将替换以前的设置。</p>
<h2 id="host-configuration-values">主机配置值</h2>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder">WebHostBuilder</a> 依赖于以下的方法设置主机配置值：</p>
<ul>
<li>主机生成器配置，其中包括格式 <code>ASPNETCORE_{configurationKey}</code> 的环境变量。 例如 <code>ASPNETCORE_ENVIRONMENT</code>。</li>
<li><a href="/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.usecontentroot">UseContentRoot</a> 和 <a href="/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.useconfiguration">UseConfiguration</a> 等扩展（请参阅<a href="#override-configuration">重写配置</a>部分）。</li>
<li><a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder.usesetting">UseSetting</a> 和关联键。 使用 <code>UseSetting</code> 设置值时，该值设置为无论何种类型的字符串。</li>
</ul>
<p>主机使用任何一个选项设置上一个值。 有关详细信息，请参阅下一部分中的<a href="#override-configuration">重写配置</a>。</p>
<h3 id="application-key-name">应用程序键（名称）</h3>
<div range="&gt;= aspnetcore-3.0">
<p>在主机构造期间调用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestartup">UseStartup</a> 或 <a href="/dotnet/api/microsoft.aspnetcore.hosting.istartup.configure">Configure</a> 时，会自动设置 <code>IWebHostEnvironment.ApplicationName</code> 属性。 该值设置为包含应用入口点的程序集的名称。 要显式设置值，请使用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostdefaults.applicationkey">WebHostDefaults.ApplicationKey</a>：</p>
</div>
<div range="&lt; aspnetcore-3.0">
<p>在主机构造期间调用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestartup">UseStartup</a> 或 <a href="/dotnet/api/microsoft.aspnetcore.hosting.istartup.configure">Configure</a> 时，会自动设置 <a href="/dotnet/api/microsoft.extensions.hosting.ihostingenvironment.applicationname">IHostingEnvironment.ApplicationName</a> 属性。 该值设置为包含应用入口点的程序集的名称。 要显式设置值，请使用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostdefaults.applicationkey">WebHostDefaults.ApplicationKey</a>：</p>
</div>
<p><strong>密钥</strong>：applicationName<br>
<strong>类型</strong>：string<br>
<strong>默认值</strong>：包含应用入口点的程序集的名称。<br>
<strong>设置使用</strong>：<code>UseSetting</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_APPLICATIONNAME</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(WebHostDefaults.ApplicationKey, &quot;CustomApplicationName&quot;)
</code></pre>
<h3 id="capture-startup-errors">捕获启动错误</h3>
<p>此设置控制启动错误的捕获。</p>
<p><strong>键</strong>：captureStartupErrors<br>
<strong>类型</strong>：布尔型（<code>true</code> 或 <code>1</code>）<br>
<strong>默认</strong>：默认为 <code>false</code>，除非应用使用 Kestrel 在 IIS 后方运行，其中默认值是 <code>true</code>。<br>
<strong>设置使用</strong>：<code>CaptureStartupErrors</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_CAPTURESTARTUPERRORS</code></p>
<p>当 <code>false</code> 时，启动期间出错导致主机退出。 当 <code>true</code> 时，主机在启动期间捕获异常并尝试启动服务器。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .CaptureStartupErrors(true)
</code></pre>
<h3 id="content-root">内容根</h3>
<p>此设置确定 ASP.NET Core 开始搜索内容文件。</p>
<p><strong>键</strong>：contentRoot<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：默认为应用程序集所在的文件夹。<br>
<strong>设置使用</strong>：<code>UseContentRoot</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_CONTENTROOT</code></p>
<p>内容根目录也用作 <a class="xref" href="../index.html#web-root">Web 根目录</a>的基路径。 如果内容根路径不存在，主机将无法启动。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseContentRoot(&quot;c:\\&lt;content-root&gt;&quot;)
</code></pre>
<p>有关详情，请参阅：</p>
<ul>
<li><a class="xref" href="../index.html#content-root">基础知识：内容根目录</a></li>
<li><a href="#web-root">Web 根目录</a></li>
</ul>
<h3 id="detailed-errors">详细错误</h3>
<p>确定是否应捕获详细错误。</p>
<p><strong>键</strong>：detailedErrors<br>
<strong>类型</strong>：布尔型（<code>true</code> 或 <code>1</code>）<br>
<strong>默认值</strong>：false<br>
<strong>设置使用</strong>：<code>UseSetting</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_DETAILEDERRORS</code></p>
<p>启用（或当<a href="#environment">环境</a>设置为 <code>Development</code> ）时，应用捕获详细的异常。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(WebHostDefaults.DetailedErrorsKey, &quot;true&quot;)
</code></pre>
<h3 id="environment">环境</h3>
<p>设置应用的环境。</p>
<p><strong>键</strong>：环境<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：生产<br>
<strong>设置使用</strong>：<code>UseEnvironment</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_ENVIRONMENT</code></p>
<p>可将环境设置为任何值。 框架定义的值包括 <code>Development``Staging</code> 和 <code>Production</code>。 值不区分大小写。 默认情况下，从 <code>ASPNETCORE_ENVIRONMENT</code> 环境变量读取环境。 使用 <a href="https://visualstudio.microsoft.com">Visual Studio</a> 时，可在 launchSettings.json 文件中设置环境变量。 有关详细信息，请参阅 <a class="xref" href="../environments.html">在 ASP.NET Core 中使用多个环境</a>。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseEnvironment(EnvironmentName.Development)
</code></pre>
<h3 id="hosting-startup-assemblies">承载启动程序集</h3>
<p>设置应用的承载启动程序集。</p>
<p><strong>键</strong>：hostingStartupAssemblies<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：空字符串<br>
<strong>设置使用</strong>：<code>UseSetting</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_HOSTINGSTARTUPASSEMBLIES</code></p>
<p>承载启动程序集的以分号分隔的字符串在启动时加载。</p>
<p>虽然配置值默认为空字符串，但是承载启动程序集会始终包含应用的程序集。 提供承载启动程序集时，当应用在启动过程中生成其公用服务时将它们添加到应用的程序集加载。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;assembly1;assembly2&quot;)
</code></pre>
<h3 id="https-port">HTTPS 端口</h3>
<p>设置 HTTPS 重定向端口。 用于<a class="xref" href="../../security/enforcing-ssl.html">强制实施 HTTPS</a>。</p>
<p>键：https_port；类型：字符串；
默认值 ：未设置默认值。
设置使用：<code>UseSetting</code>
环境变量：<code>ASPNETCORE_HTTPS_PORT</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(&quot;https_port&quot;, &quot;8080&quot;)
</code></pre>
<h3 id="hosting-startup-exclude-assemblies">承载启动排除程序集</h3>
<p>承载启动程序集的以分号分隔的字符串在启动时排除。</p>
<p>键：hostingStartupExcludeAssemblies<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：空字符串<br>
<strong>设置使用</strong>：<code>UseSetting</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_HOSTINGSTARTUPEXCLUDEASSEMBLIES</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(WebHostDefaults.HostingStartupExcludeAssembliesKey, &quot;assembly1;assembly2&quot;)
</code></pre>
<h3 id="prefer-hosting-urls">首选承载 URL</h3>
<p>指示主机是否应该侦听使用 <code>WebHostBuilder</code> 配置的 URL，而不是使用 <code>IServer</code> 实现配置的 URL。</p>
<p><strong>键</strong>：preferHostingUrls<br>
<strong>类型</strong>：布尔型（<code>true</code> 或 <code>1</code>）<br>
<strong>默认值</strong>：true<br>
<strong>设置使用</strong>：<code>PreferHostingUrls</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_PREFERHOSTINGURLS</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .PreferHostingUrls(false)
</code></pre>
<h3 id="prevent-hosting-startup">阻止承载启动</h3>
<p>阻止承载启动程序集自动加载，包括应用的程序集所配置的承载启动程序集。 有关详细信息，请参阅 <a class="xref" href="platform-specific-configuration.html">在 ASP.NET Core 中使用承载启动程序集</a>。</p>
<p><strong>键</strong>：preventHostingStartup<br>
<strong>类型</strong>：布尔型（<code>true</code> 或 <code>1</code>）<br>
<strong>默认值</strong>：false<br>
<strong>设置使用</strong>：<code>UseSetting</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_PREVENTHOSTINGSTARTUP</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseSetting(WebHostDefaults.PreventHostingStartupKey, &quot;true&quot;)
</code></pre>
<h3 id="server-urls">服务器 URL</h3>
<p>指示 IP 地址或主机地址，其中包含服务器应针对请求侦听的端口和协议。</p>
<p><strong>键</strong>：urls<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>： http://localhost:5000<br>
<strong>设置使用</strong>：<code>UseUrls</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_URLS</code></p>
<p>设置为服务器应响应的以分号分隔 (;) 的 URL 前缀列表。 例如 <code>http://localhost:123</code>。 使用“*”指示服务器应针对请求侦听的使用特定端口和协议（例如 <code>http://*:5000</code>）的 IP 地址或主机名。 协议（<code>http://</code> 或 <code>https://</code>）必须包含每个 URL。 不同的服务器支持的格式有所不同。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseUrls(&quot;http://*:5000;http://localhost:5001;https://hostname:5002&quot;)
</code></pre>
<p>Kestrel 具有自己的终结点配置 API。 有关详细信息，请参阅 <a class="xref" href="../servers/kestrel.html#endpoint-configuration">ASP.NET Core 中的 Kestrel Web 服务器实现</a>。</p>
<h3 id="shutdown-timeout">关闭超时</h3>
<p>指定等待 Web 主机关闭的时长。</p>
<p><strong>键</strong>：shutdownTimeoutSeconds<br>
<strong>类型</strong>：int<br>
<strong>默认</strong>：5<br>
<strong>设置使用</strong>：<code>UseShutdownTimeout</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_SHUTDOWNTIMEOUTSECONDS</code></p>
<p>虽然键使用 <code>UseSetting</code> 接受 int（例如 <code>.UseSetting(WebHostDefaults.ShutdownTimeoutKey, &quot;10&quot;)</code>），但是 <a href="/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.useshutdowntimeout">UseShutdownTimeout</a> 扩展方法采用 <a href="/dotnet/api/system.timespan">TimeSpan</a>。</p>
<p>在超时时间段中，托管：</p>
<ul>
<li>触发器 <a href="/dotnet/api/microsoft.aspnetcore.hosting.iapplicationlifetime.applicationstopping">IApplicationLifetime.ApplicationStopping</a>。</li>
<li>尝试停止托管服务，对服务停止失败的任何错误进行日志记录。</li>
</ul>
<p>如果在所有托管服务停止之前就达到了超时时间，则会在应用关闭时会终止剩余的所有活动的服务。 即使没有完成处理工作，服务也会停止。 如果停止服务需要额外的时间，请增加超时时间。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseShutdownTimeout(TimeSpan.FromSeconds(10))
</code></pre>
<h3 id="startup-assembly">启动程序集</h3>
<p>确定要在其中搜索 <code>Startup</code> 类的程序集。</p>
<p><strong>键</strong>：startupAssembly<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：应用的程序集<br>
<strong>设置使用</strong>：<code>UseStartup</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_STARTUPASSEMBLY</code></p>
<p>按名称（<code>string</code>）或类型（<code>TStartup</code>）的程序集可以引用。 如果调用多个 <code>UseStartup</code> 方法，优先选择最后一个方法。</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseStartup(&quot;StartupAssemblyName&quot;)
</code></pre>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseStartup&lt;TStartup&gt;()
</code></pre>
<h3 id="web-root">Web 根</h3>
<p>设置应用的静态资产的相对路径。</p>
<p><strong>键</strong>：webroot<br>
<strong>类型</strong>：string<br>
<strong>默认</strong>：默认值为 <code>wwwroot</code>。 {content root}/wwwroot 的路径必须存在。 如果该路径不存在，则使用无操作文件提供程序。<br>
<strong>设置使用</strong>：<code>UseWebRoot</code><br>
<strong>环境变量</strong>：<code>ASPNETCORE_WEBROOT</code></p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseWebRoot(&quot;public&quot;)
</code></pre>
<p>有关详情，请参阅：</p>
<ul>
<li><a class="xref" href="../index.html#web-root">基础知识：Web 根目录</a></li>
<li><a href="#content-root">内容根目录</a></li>
</ul>
<h2 id="override-configuration">重写配置</h2>
<p>使用<a class="xref" href="../configuration/index.html">配置</a>可以配置 Web 主机。 在下面的示例中，主机配置是根据需要在 hostsettings.json 文件中指定。 命令行参数可能会重写从 hostsettings.json 文件加载的任何配置。 生成的配置（在 <code>config</code> 中）用于通过 <a href="/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.useconfiguration">UseConfiguration</a> 配置主机。 <code>IWebHostBuilder</code> 配置会添加到应用配置中，但反之不亦然—<code>ConfigureAppConfiguration</code> 不影响 <code>IWebHostBuilder</code> 配置。</p>
<p>先用 hostsettings.json config 重写 <code>UseUrls</code> 提供的配置，再用命令行参数 config：</p>
<pre><code class="lang-csharp">public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args)
    {
        var config = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;hostsettings.json&quot;, optional: true)
            .AddCommandLine(args)
            .Build();

        return WebHost.CreateDefaultBuilder(args)
            .UseUrls(&quot;http://*:5000&quot;)
            .UseConfiguration(config)
            .Configure(app =&gt;
            {
                app.Run(context =&gt; 
                    context.Response.WriteAsync(&quot;Hello, World!&quot;));
            });
    }
}
</code></pre>
<p>hostsettings.json：</p>
<pre><code class="lang-json">{
    urls: &quot;http://*:5005&quot;
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.useconfiguration">UseConfiguration</a> 只将所提供的 <code>IConfiguration</code> 中的密钥复制到主机生成器配置中。 因此，JSON、INI 和 XML 设置文件的设置 <code>reloadOnChange: true</code> 没有任何影响。</p>
</div>
<p>若要指定在特定的 URL 上运行的主机，所需的值可以在执行 <a href="/dotnet/core/tools/dotnet-run">dotnet 运行</a>时从命令提示符传入。 命令行参数重写 hostsettings.json 文件中的 <code>urls</code> 值，且服务器侦听端口 8080：</p>
<pre><code class="lang-dotnetcli">dotnet run --urls &quot;http://*:8080&quot;
</code></pre>
<h2 id="manage-the-host">管理主机</h2>
<p><strong>运行</strong></p>
<p><code>Run</code> 方法启动 Web 应用并阻止调用线程，直到关闭主机：</p>
<pre><code class="lang-csharp">host.Run();
</code></pre>
<p><strong>Start</strong></p>
<p>通过调用 <code>Start</code> 方法以非阻止方式运行主机：</p>
<pre><code class="lang-csharp">using (host)
{
    host.Start();
    Console.ReadLine();
}
</code></pre>
<p>如果 URL 列表传递给 <code>Start</code> 方法，该列表侦听指定的 URL：</p>
<pre><code class="lang-csharp">var urls = new List&lt;string&gt;()
{
    &quot;http://*:5000&quot;,
    &quot;http://localhost:5001&quot;
};

var host = new WebHostBuilder()
    .UseKestrel()
    .UseStartup&lt;Startup&gt;()
    .Start(urls.ToArray());

using (host)
{
    Console.ReadLine();
}
</code></pre>
<p>应用可以使用通过静态便捷方法预配置的 <code>CreateDefaultBuilder</code> 默认值初始化并启动新的主机。 这些方法在没有控制台输出的情况下启动服务器，并使用 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostextensions.waitforshutdown">WaitForShutdown</a> 等待中断（Ctrl-C/SIGINT 或 SIGTERM）：</p>
<p><strong>Start(RequestDelegate app)</strong></p>
<p>从 <code>RequestDelegate</code> 开始：</p>
<pre><code class="lang-csharp">using (var host = WebHost.Start(app =&gt; app.Response.WriteAsync(&quot;Hello, World!&quot;)))
{
    Console.WriteLine(&quot;Use Ctrl-C to shutdown the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>在浏览器中向 <code>http://localhost:5000</code> 发出请求，接收响应“Hello World!” <code>WaitForShutdown</code> 受到阻止，直到发出中断（Ctrl-C/SIGINT 或 SIGTERM）。 应用显示 <code>Console.WriteLine</code> 消息并等待 keypress 退出。</p>
<p><strong>Start(string url, RequestDelegate app)</strong></p>
<p>从 URL 和 <code>RequestDelegate</code> 开始：</p>
<pre><code class="lang-csharp">using (var host = WebHost.Start(&quot;http://localhost:8080&quot;, app =&gt; app.Response.WriteAsync(&quot;Hello, World!&quot;)))
{
    Console.WriteLine(&quot;Use Ctrl-C to shutdown the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>生成与 Start(RequestDelegate app) 相同的结果，除非应用在 <code>http://localhost:8080</code> 上响应。</p>
<p><strong>Start(Action&lt;IRouteBuilder&gt; routeBuilder)</strong></p>
<p>使用 <code>IRouteBuilder</code> 的实例 (<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Routing/">Microsoft.AspNetCore.Routing</a>) 用于路由中间件：</p>
<pre><code class="lang-csharp">using (var host = WebHost.Start(router =&gt; router
    .MapGet(&quot;hello/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;Hello, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;buenosdias/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;Buenos dias, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;throw/{message?}&quot;, (req, res, data) =&gt; 
        throw new Exception((string)data.Values[&quot;message&quot;] ?? &quot;Uh oh!&quot;))
    .MapGet(&quot;{greeting}/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;{data.Values[&quot;greeting&quot;]}, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;&quot;, (req, res, data) =&gt; res.WriteAsync(&quot;Hello, World!&quot;))))
{
    Console.WriteLine(&quot;Use Ctrl-C to shutdown the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>该示例中使用以下浏览器请求：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>响应</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http://localhost:5000/hello/Martin</code></td>
<td>Hello, Martin!</td>
</tr>
<tr>
<td><code>http://localhost:5000/buenosdias/Catrina</code></td>
<td>Buenos dias, Catrina!</td>
</tr>
<tr>
<td><code>http://localhost:5000/throw/ooops!</code></td>
<td>使用“ooops!”字符串引发异常</td>
</tr>
<tr>
<td><code>http://localhost:5000/throw</code></td>
<td>使用“Uh oh!”字符串引发异常</td>
</tr>
<tr>
<td><code>http://localhost:5000/Sante/Kevin</code></td>
<td>Sante, Kevin!</td>
</tr>
<tr>
<td><code>http://localhost:5000</code></td>
<td>Hello World!</td>
</tr>
</tbody>
</table>
<p><code>WaitForShutdown</code> 受到阻止，直到发出中断（Ctrl-C/SIGINT 或 SIGTERM）。 应用显示 <code>Console.WriteLine</code> 消息并等待 keypress 退出。</p>
<p><strong>Start(string url, Action&lt;IRouteBuilder&gt; routeBuilder)</strong></p>
<p>使用 URL 和 <code>IRouteBuilder</code> 实例：</p>
<pre><code class="lang-csharp">using (var host = WebHost.Start(&quot;http://localhost:8080&quot;, router =&gt; router
    .MapGet(&quot;hello/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;Hello, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;buenosdias/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;Buenos dias, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;throw/{message?}&quot;, (req, res, data) =&gt; 
        throw new Exception((string)data.Values[&quot;message&quot;] ?? &quot;Uh oh!&quot;))
    .MapGet(&quot;{greeting}/{name}&quot;, (req, res, data) =&gt; 
        res.WriteAsync($&quot;{data.Values[&quot;greeting&quot;]}, {data.Values[&quot;name&quot;]}!&quot;))
    .MapGet(&quot;&quot;, (req, res, data) =&gt; res.WriteAsync(&quot;Hello, World!&quot;))))
{
    Console.WriteLine(&quot;Use Ctrl-C to shut down the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>生成与 Start(Action&lt;IRouteBuilder&gt; routeBuilder) 相同的结果，除非应用在 <code>http://localhost:8080</code> 上响应。</p>
<p><strong>StartWith(Action&lt;IApplicationBuilder&gt; app)</strong></p>
<p>提供委托以配置 <code>IApplicationBuilder</code>：</p>
<pre><code class="lang-csharp">using (var host = WebHost.StartWith(app =&gt; 
    app.Use(next =&gt; 
    {
        return async context =&gt; 
        {
            await context.Response.WriteAsync(&quot;Hello World!&quot;);
        };
    })))
{
    Console.WriteLine(&quot;Use Ctrl-C to shut down the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>在浏览器中向 <code>http://localhost:5000</code> 发出请求，接收响应“Hello World!” <code>WaitForShutdown</code> 受到阻止，直到发出中断（Ctrl-C/SIGINT 或 SIGTERM）。 应用显示 <code>Console.WriteLine</code> 消息并等待 keypress 退出。</p>
<p><strong>StartWith(string url, Action&lt;IApplicationBuilder&gt; app)</strong></p>
<p>提供 URL 和委托以配置 <code>IApplicationBuilder</code>：</p>
<pre><code class="lang-csharp">using (var host = WebHost.StartWith(&quot;http://localhost:8080&quot;, app =&gt; 
    app.Use(next =&gt; 
    {
        return async context =&gt; 
        {
            await context.Response.WriteAsync(&quot;Hello World!&quot;);
        };
    })))
{
    Console.WriteLine(&quot;Use Ctrl-C to shut down the host...&quot;);
    host.WaitForShutdown();
}
</code></pre>
<p>生成与 StartWith(Action&lt;IApplicationBuilder&gt; app) 相同的结果，除非应用在 <code>http://localhost:8080</code> 上响应。</p>
<div range="&gt;= aspnetcore-3.0">
<h2 id="iwebhostenvironment-interface">IWebHostEnvironment 接口</h2>
<p><code>IWebHostEnvironment</code> 接口提供有关应用的 Web 托管环境的信息。 使用<a class="xref" href="../dependency-injection.html">构造函数注入</a>获取 <code>IWebHostEnvironment</code> 以使用其属性和扩展方法：</p>
<pre><code class="lang-csharp">public class CustomFileReader
{
    private readonly IWebHostEnvironment _env;

    public CustomFileReader(IWebHostEnvironment env)
    {
        _env = env;
    }

    public string ReadFile(string filePath)
    {
        var fileProvider = _env.WebRootFileProvider;
        // Process the file here
    }
}
</code></pre>
<p><a class="xref" href="../environments.html#environment-based-startup-class-and-methods">基于约定的方法</a>可以用于在启动时基于环境配置应用。 或者，将 <code>IWebHostEnvironment</code> 注入到 <code>Startup</code> 构造函数用于 <code>ConfigureServices</code>：</p>
<pre><code class="lang-csharp">public class Startup
{
    public Startup(IWebHostEnvironment env)
    {
        HostingEnvironment = env;
    }

    public IWebHostEnvironment HostingEnvironment { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        if (HostingEnvironment.IsDevelopment())
        {
            // Development configuration
        }
        else
        {
            // Staging/Production configuration
        }

        var contentRootPath = HostingEnvironment.ContentRootPath;
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>除了 <code>IsDevelopment</code> 扩展方法，<code>IWebHostEnvironment</code> 提供 <code>IsStaging</code>、<code>IsProduction</code> 和 <code>IsEnvironment(string environmentName)</code> 方法。 有关详细信息，请参阅 <a class="xref" href="../environments.html">在 ASP.NET Core 中使用多个环境</a>。</p>
</div>
<p><code>IWebHostEnvironment</code> 服务还可以直接注入到 <code>Configure</code> 方法以设置处理管道：</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        // In Development, use the Developer Exception Page
        app.UseDeveloperExceptionPage();
    }
    else
    {
        // In Staging/Production, route exceptions to /error
        app.UseExceptionHandler(&quot;/error&quot;);
    }

    var contentRootPath = env.ContentRootPath;
}
</code></pre>
<p>创建自定义<a class="xref" href="../middleware/write.html">中间件</a>时可以将 <code>IWebHostEnvironment</code> 注入 <code>Invoke</code> 方法：</p>
<pre><code class="lang-csharp">public async Task Invoke(HttpContext context, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        // Configure middleware for Development
    }
    else
    {
        // Configure middleware for Staging/Production
    }

    var contentRootPath = env.ContentRootPath;
}
</code></pre>
</div>
<div range="&lt; aspnetcore-3.0">
<h2 id="ihostingenvironment-interface">IHostingEnvironment 接口</h2>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.ihostingenvironment">IHostingEnvironment 接口</a>提供有关应用的 Web 承载环境的信息。 使用<a class="xref" href="../dependency-injection.html">构造函数注入</a>获取 <code>IHostingEnvironment</code> 以使用其属性和扩展方法：</p>
<pre><code class="lang-csharp">public class CustomFileReader
{
    private readonly IHostingEnvironment _env;

    public CustomFileReader(IHostingEnvironment env)
    {
        _env = env;
    }

    public string ReadFile(string filePath)
    {
        var fileProvider = _env.WebRootFileProvider;
        // Process the file here
    }
}
</code></pre>
<p><a class="xref" href="../environments.html#environment-based-startup-class-and-methods">基于约定的方法</a>可以用于在启动时基于环境配置应用。 或者，将 <code>IHostingEnvironment</code> 注入到 <code>Startup</code> 构造函数用于 <code>ConfigureServices</code>：</p>
<pre><code class="lang-csharp">public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        HostingEnvironment = env;
    }

    public IHostingEnvironment HostingEnvironment { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        if (HostingEnvironment.IsDevelopment())
        {
            // Development configuration
        }
        else
        {
            // Staging/Production configuration
        }

        var contentRootPath = HostingEnvironment.ContentRootPath;
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>除了 <code>IsDevelopment</code> 扩展方法，<code>IHostingEnvironment</code> 提供 <code>IsStaging</code>、<code>IsProduction</code> 和 <code>IsEnvironment(string environmentName)</code> 方法。 有关详细信息，请参阅 <a class="xref" href="../environments.html">在 ASP.NET Core 中使用多个环境</a>。</p>
</div>
<p><code>IHostingEnvironment</code> 服务还可以直接注入到 <code>Configure</code> 方法以设置处理管道：</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        // In Development, use the Developer Exception Page
        app.UseDeveloperExceptionPage();
    }
    else
    {
        // In Staging/Production, route exceptions to /error
        app.UseExceptionHandler(&quot;/error&quot;);
    }

    var contentRootPath = env.ContentRootPath;
}
</code></pre>
<p>创建自定义<a class="xref" href="../middleware/write.html">中间件</a>时可以将 <code>IHostingEnvironment</code> 注入 <code>Invoke</code> 方法：</p>
<pre><code class="lang-csharp">public async Task Invoke(HttpContext context, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        // Configure middleware for Development
    }
    else
    {
        // Configure middleware for Staging/Production
    }

    var contentRootPath = env.ContentRootPath;
}
</code></pre>
</div>
<div range="&gt;= aspnetcore-3.0">
<h2 id="ihostapplicationlifetime-interface">IHostApplicationLifetime 接口</h2>
<p><code>IHostApplicationLifetime</code> 允许后启动和关闭活动。 接口上的三个属性是用于注册 <code>Action</code> 方法（用于定义启动和关闭事件）的取消标记。</p>
<table>
<thead>
<tr>
<th>取消标记</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationStarted</code></td>
<td>主机已完全启动。</td>
</tr>
<tr>
<td><code>ApplicationStopped</code></td>
<td>主机正在完成正常关闭。 应处理所有请求。 关闭受到阻止，直到完成此事件。</td>
</tr>
<tr>
<td><code>ApplicationStopping</code></td>
<td>主机正在执行正常关闭。 仍在处理请求。 关闭受到阻止，直到完成此事件。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-csharp">public class Startup
{
    public void Configure(IApplicationBuilder app, IHostApplicationLifetime appLifetime)
    {
        appLifetime.ApplicationStarted.Register(OnStarted);
        appLifetime.ApplicationStopping.Register(OnStopping);
        appLifetime.ApplicationStopped.Register(OnStopped);

        Console.CancelKeyPress += (sender, eventArgs) =&gt;
        {
            appLifetime.StopApplication();
            // Don't terminate the process immediately, wait for the Main thread to exit gracefully.
            eventArgs.Cancel = true;
        };
    }

    private void OnStarted()
    {
        // Perform post-startup activities here
    }

    private void OnStopping()
    {
        // Perform on-stopping activities here
    }

    private void OnStopped()
    {
        // Perform post-stopped activities here
    }
}
</code></pre>
<p><code>StopApplication</code> 请求终止应用。 以下类在调用类的 <code>Shutdown</code> 方法时使用 <code>StopApplication</code> 正常关闭应用：</p>
<pre><code class="lang-csharp">public class MyClass
{
    private readonly IHostApplicationLifetime _appLifetime;

    public MyClass(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public void Shutdown()
    {
        _appLifetime.StopApplication();
    }
}
</code></pre>
</div>
<div range="&lt; aspnetcore-3.0">
<h2 id="iapplicationlifetime-interface">IApplicationLifetime 接口</h2>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.iapplicationlifetime">IApplicationLifetime</a> 允许后启动和关闭活动。 接口上的三个属性是用于注册 <code>Action</code> 方法（用于定义启动和关闭事件）的取消标记。</p>
<table>
<thead>
<tr>
<th>取消标记</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/dotnet/api/microsoft.extensions.hosting.iapplicationlifetime.applicationstarted">ApplicationStarted</a></td>
<td>主机已完全启动。</td>
</tr>
<tr>
<td><a href="/dotnet/api/microsoft.extensions.hosting.iapplicationlifetime.applicationstopped">ApplicationStopped</a></td>
<td>主机正在完成正常关闭。 应处理所有请求。 关闭受到阻止，直到完成此事件。</td>
</tr>
<tr>
<td><a href="/dotnet/api/microsoft.extensions.hosting.iapplicationlifetime.applicationstopping">ApplicationStopping</a></td>
<td>主机正在执行正常关闭。 仍在处理请求。 关闭受到阻止，直到完成此事件。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-csharp">public class Startup
{
    public void Configure(IApplicationBuilder app, IApplicationLifetime appLifetime)
    {
        appLifetime.ApplicationStarted.Register(OnStarted);
        appLifetime.ApplicationStopping.Register(OnStopping);
        appLifetime.ApplicationStopped.Register(OnStopped);

        Console.CancelKeyPress += (sender, eventArgs) =&gt;
        {
            appLifetime.StopApplication();
            // Don't terminate the process immediately, wait for the Main thread to exit gracefully.
            eventArgs.Cancel = true;
        };
    }

    private void OnStarted()
    {
        // Perform post-startup activities here
    }

    private void OnStopping()
    {
        // Perform on-stopping activities here
    }

    private void OnStopped()
    {
        // Perform post-stopped activities here
    }
}
</code></pre>
<p><a href="/dotnet/api/microsoft.aspnetcore.hosting.iapplicationlifetime.stopapplication">StopApplication</a> 请求应用终止。 以下类在调用类的 <code>Shutdown</code> 方法时使用 <code>StopApplication</code> 正常关闭应用：</p>
<pre><code class="lang-csharp">public class MyClass
{
    private readonly IApplicationLifetime _appLifetime;

    public MyClass(IApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public void Shutdown()
    {
        _appLifetime.StopApplication();
    }
}
</code></pre>
</div>
<h2 id="scope-validation">作用域验证</h2>
<p>如果应用环境为“开发”，则 <a href="/dotnet/api/microsoft.aspnetcore.webhost.createdefaultbuilder">CreateDefaultBuilder</a> 将 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions.validatescopes">ServiceProviderOptions.ValidateScopes</a> 设为 <code>true</code>。</p>
<p>若将 <code>ValidateScopes</code> 设为 <code>true</code>，默认服务提供程序会执行检查来验证以下内容：</p>
<ul>
<li>没有从根服务提供程序直接或间接解析到有作用域的服务。</li>
<li>未将有作用域的服务直接或间接注入到单一实例。</li>
</ul>
<p>调用 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectioncontainerbuilderextensions.buildserviceprovider">BuildServiceProvider</a> 时，会创建根服务提供程序。 在启动提供程序和应用时，根服务提供程序的生存期对应于应用/服务的生存期，并在关闭应用时释放。</p>
<p>有作用域的服务由创建它们的容器释放。 如果作用域创建于根容器，则该服务的生存会有效地提升至单一实例，因为根容器只会在应用/服务关闭时将其释放。 验证服务作用域，将在调用 <code>BuildServiceProvider</code> 时收集这类情况。</p>
<p>若要始终验证作用域（包括在生存环境中验证），请使用主机生成器上的 <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usedefaultserviceprovider">UseDefaultServiceProvider</a> 配置 <a href="/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions">ServiceProviderOptions</a>：</p>
<pre><code class="lang-csharp">WebHost.CreateDefaultBuilder(args)
    .UseDefaultServiceProvider((context, options) =&gt; {
        options.ValidateScopes = true;
    })
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="../../host-and-deploy/iis/index.html">使用 IIS 在 Windows 上托管 ASP.NET Core</a></li>
<li><a class="xref" href="../../host-and-deploy/linux-nginx.html">使用 Nginx 在 Linux 上托管 ASP.NET Core</a></li>
<li><a class="xref" href="../../host-and-deploy/linux-apache.html">使用 Apache 在 Linux 上托管 ASP.NET Core</a></li>
<li><a class="xref" href="../../host-and-deploy/windows-service.html">在 Windows 服务中托管 ASP.NET Core</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
