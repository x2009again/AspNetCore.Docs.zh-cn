<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core &#20840;&#29699;&#21270;&#21644;&#26412;&#22320;&#21270; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core &#20840;&#29699;&#21270;&#21644;&#26412;&#22320;&#21270; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="fundamentals/localization">
<h1 id="globalization-and-localization-in-aspnet-core">ASP.NET Core 全球化和本地化</h1>

<div range="&gt;= aspnetcore-3.0 &lt; aspnetcore-5.0">
<p>作者：<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://twitter.com/damien_bod">Damien Bowden</a>、<a href="https://twitter.com/bartmax">Bart Calixto</a>、<a href="https://afana.me/">Nadeem Afana</a> 和 <a href="https://twitter.com/hishambinateya">Hisham Bin Ateya</a></p>
<p>多语言网站使网站可以覆盖更广泛的受众。 ASP.NET Core 提供的服务和中间件可将网站本地化为不同的语言和文化。</p>
<p>国际化涉及<a href="/dotnet/api/system.globalization">全球化</a>和<a href="/dotnet/standard/globalization-localization/localization">本地化</a>。 全球化是设计支持不同区域性的应用程序的过程。 全球化添加了对一组有关特定地理区域的已定义语言脚本的输入、显示和输出支持。</p>
<p>本地化是将已经针对可本地化性进行处理的全球化应用调整为特定的区域性/区域设置的过程。 有关详细信息，请参阅本文档邻近末尾的全球化和本地化术语。</p>
<p>应用本地化涉及以下内容：</p>
<ol>
<li>使应用内容可本地化</li>
<li>为支持的语言和区域性提供本地化资源</li>
<li>实施策略，为每个请求选择语言/区域性</li>
</ol>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/localization/sample/3.x/Localization">查看或下载示例代码</a>（<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="make-the-apps-content-localizable">使应用内容可本地化</h2>
<p>已为 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer&gt; 和 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer%601&gt; 设置架构，可以为开发本地化应用提高工作效率。 <code>IStringLocalizer</code> 使用 &lt;xref:System.Resources.ResourceManager&gt; 和 &lt;xref:System.Resources.ResourceReader&gt; 在运行时提供特定于区域性的资源。 接口具有一个索引器和一个用于返回本地化字符串的 <code>IEnumerable</code>。 <code>IStringLocalizer</code> 不要求在资源文件中存储默认语言字符串。 你可以开发针对本地化的应用，且无需在开发初期创建资源资源文件。 下面的代码演示如何针对本地化包装字符串“About Title”。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，<code>IStringLocalizer&lt;T&gt;</code> 实现来源于<a href="dependency-injection.html">依赖关系注入</a>。 如果找不到“About Title”的本地化值，则返回索引器键，即字符串“About Title”。 可将默认语言文本字符串保留在应用中并将它们包装在本地化工具中，以便你可集中精力开发应用。 你使用默认语言开发应用，并针对本地化步骤进行准备，而无需首先创建默认资源文件。 或者，你可以使用传统方法，并提供键以检索默认语言字符串。 对于许多开发者而言，不具有默认语言 .resx 文件且简单包装字符串文本的新工作流可以减少本地化应用的开销。 其他开发者将首选传统工作流，因为它可以更轻松地使用较长字符串文本，更轻松地更新本地化字符串。</p>
<p>对包含 HTML 的资源使用 <code>IHtmlLocalizer&lt;T&gt;</code> 实现。 <code>IHtmlLocalizer</code> 对资源字符串中格式化的参数进行 HTML 编码，但不对资源字符串本身进行 HTML 编码。 在下面突出显示的示例中，仅 <code>name</code> 参数的值被 HTML 编码。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>最低程度，你可以从<a href="dependency-injection.html">依赖关系注入</a>获取 <code>IStringLocalizerFactory</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>上面的代码演示了这两种工厂创建方法。</p>
<p>可以按控制器、区域对本地化字符串分区，或只有一个容器。 在示例应用中，名为 <code>SharedResource</code> 的虚拟类用于共享资源。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>某些开发者使用 <code>Startup</code> 类，以包含全局或共享字符串。 在下面的示例中，使用 <code>InfoController</code> 和 <code>SharedResource</code> 本地化工具：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="view-localization">视图本地化</h2>
<p><code>IViewLocalizer</code> 服务可为<a class="xref" href="../mvc/views/overview.html">视图</a>提供本地化字符串。 <code>ViewLocalizer</code> 类可实现此接口，并从视图文件路径找到资源位置。 下面的代码演示如何使用 <code>IViewLocalizer</code> 的默认实现：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>IViewLocalizer</code> 的默认实现可根据视图的文件名查找资源文件。 没有使用全局共享资源文件的选项。 <code>ViewLocalizer</code> 使用 <code>IHtmlLocalizer</code> 实现本地化工具，因此 Razor 不会对本地化字符串进行 HTML 编码。 你可以参数化资源字符串，<code>IViewLocalizer</code> 将对参数进行 HTML 编码，但不会对资源字符串进行。 请考虑以下 Razor 标记：</p>
<pre><code class="lang-cshtml">@Localizer[&quot;&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;&quot;, UserManager.GetUserName(User)]
</code></pre>
<p>法语资源文件可以包含以下信息：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>“值”</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;</code></td>
<td><code>&lt;i&gt;Bonjour&lt;/i&gt; &lt;b&gt;{0} !&lt;/b&gt;</code></td>
</tr>
</tbody>
</table>
<p>呈现的视图可能包含资源文件中的 HTML 标记。</p>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>若要在视图中使用共享资源文件，请注入 <code>IHtmlLocalizer&lt;T&gt;</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="dataannotations-localization">DataAnnotations 本地化</h2>
<p>DataAnnotations 错误消息已使用 <code>IStringLocalizer&lt;T&gt;</code> 本地化。 使用选项 <code>ResourcesPath = &quot;Resources&quot;</code>，<code>RegisterViewModel</code> 中的错误消息可以存储在以下路径之一：</p>
<ul>
<li><em>Resources/ViewModels.Account.RegisterViewModel.fr.resx</em></li>
<li><em>Resources/ViewModels/Account/RegisterViewModel.fr.resx</em></li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在 ASP.NET Core MVC 1.1.0 和更高版本中，非验证属性已经进行了本地化。 ASP.NET Core MVC 1.0 不会为非验证属性查找本地化字符串。</p>
<p><a name="one-resource-string-multiple-classes"></a></p>
<h3 id="using-one-resource-string-for-multiple-classes">对多个类使用一个资源字符串</h3>
<p>下面的代码演示如何针对具有多个类的验证属性使用一个资源字符串：</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc()
        .AddDataAnnotationsLocalization(options =&gt; {
            options.DataAnnotationLocalizerProvider = (type, factory) =&gt;
                factory.Create(typeof(SharedResource));
        });
}
</code></pre>
<p>在上面的代码中，<code>SharedResource</code> 是对应于存储验证消息的 resx 的类。 使用此方法，DataAnnotations 将仅使用 <code>SharedResource</code>，而不是每个类的资源。</p>
<h2 id="provide-localized-resources-for-the-languages-and-cultures-you-support">为支持的语言和区域性提供本地化资源</h2>
<h3 id="supportedcultures-and-supporteduicultures">SupportedCultures 和 SupportedUICultures</h3>
<p>ASP.NET Core 允许指定两个区域性值，<code>SupportedCultures</code> 和 <code>SupportedUICultures</code>。 <code>SupportedCultures</code> 的 <a href="/dotnet/api/system.globalization.cultureinfo">CultureInfo</a> 对象可决定区域性相关函数的结果，如日期、时间、数字和货币格式等。 <code>SupportedCultures</code> 确定文本的排序顺序、大小写约定和字符串比较。 请参阅 <a href="/dotnet/api/system.stringcomparer.currentculture#System_StringComparer_CurrentCulture">CultureInfo.CurrentCulture</a> 详细了解服务器如何获取区域性。 <code>SupportedUICultures</code> 可确定按 <a href="/dotnet/api/system.resources.resourcemanager">ResourceManager</a> 来查找哪些转换字符串（位于 .resx 文件）。 <code>ResourceManager</code> 只需查找 <code>CurrentUICulture</code> 决定的区域性特定字符串。 .NET 中的每个线程都具有 <code>CurrentCulture</code> 和 <code>CurrentUICulture</code> 对象。 呈现区域性相关函数时，ASP.NET Core 可检查这些值。 例如，如果当前线程的区域性设置为“en-US”（英语，美国），<code>DateTime.Now.ToLongDateString()</code> 将显示“Thursday, February 18, 2016”，但如果 <code>CurrentCulture</code> 设置为“es-ES”（西班牙语，西班牙），则输出将为“jueves，18 de febrero de 2016”。</p>
<h2 id="resource-files">资源文件</h2>
<p>资源文件是将可本地化的字符串与代码分离的有用机制。 非默认语言的转换字符串在 .resx 资源文件中单独显示。 例如，你可能想要创建包含转换字符串、名为 Welcome.es.resx 的西班牙语资源文件。 “es”是西班牙语的语言代码。 要在 Visual Studio 中创建此资源文件，请支持以下操作：</p>
<ol>
<li><p>在“解决方案资源管理器”中，右键单击将包含资源文件的文件夹 &gt;“添加”&gt;“新项”  。</p>
<p><img src="localization/_static/newi.png" alt="嵌套的上下文菜单：在“解决方案资源管理器”中，“资源”可打开上下文菜单。 “添加”可打开第二个上下文菜单，突出显示“新项”命令。"></p>
</li>
<li><p>在“搜索已安装的模板”框中，输入“资源”并命名该文件。</p>
<p><img src="localization/_static/res.png" alt="“添加新项”对话框"></p>
</li>
<li><p>在“名称”列中输入键值（本机字符串），在“值”列中输入转换字符串 。</p>
<p><img src="localization/_static/hola.png" alt="Welcome.es.resx 文件（西班牙语版 Welcome 资源文件）的单词 Hello 位于“名称”列，Hola（西班牙语版 Hello）位于“值”列"></p>
<p>Visual Studio 将显示 Welcome.es.resx 文件。</p>
<p><img src="localization/_static/se.png" alt="显示 Welcome Spanish (es) 资源文件的解决方案资源管理器"></p>
</li>
</ol>
<h2 id="resource-file-naming">资源文件命名</h2>
<p>资源名称是类的完整类型名称减去程序集名称。 例如，类 <code>LocalizationWebsite.Web.Startup</code> 的主要程序集为 <code>LocalizationWebsite.Web.dll</code> 的项目中的法语资源将命名为 Startup.fr.resx。 类 <code>LocalizationWebsite.Web.Controllers.HomeController</code> 的资源将命名为 Controllers.HomeController.fr.resx。 如果目标类的命名空间与将需要完整类型名称的程序集名称不同。 例如，在示例项目中，类型 <code>ExtraNamespace.Tools</code> 的资源将命名为 ExtraNamespace.Tools.fr.resx。</p>
<p>在示例项目中，<code>ConfigureServices</code> 方法将 <code>ResourcesPath</code> 设置为“资源”，因此主控制器的法语资源文件的项目相对路径是 Resources/Controllers.HomeController.fr.resx。 或者，你可以使用文件夹组织资源文件。 对于主控制器，该路径将为 Resources/Controllers/HomeController.fr.resx。 如果不使用 <code>ResourcesPath</code> 选项，.resx 文件将转到项目的基目录中。 <code>HomeController</code> 的资源文件将命名为 Controllers.HomeController.fr.resx。 是选择使用圆点还是路径命名约定，具体取决于你想如何组织资源文件。</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>圆点或路径命名</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resources/Controllers.HomeController.fr.resx</td>
<td>圆点</td>
</tr>
<tr>
<td>Resources/Controllers/HomeController.fr.resx</td>
<td>路径</td>
</tr>
</tbody>
</table>
<p>Razor 视图中使用 <code>@inject IViewLocalizer</code> 的资源文件遵循类似的模式。 可以使用圆点命名或路径命名约定对视图的资源文件进行命名。 Razor 视图资源文件可模拟其关联视图文件的路径。 假设我们将 <code>ResourcesPath</code> 设置为“Resources”，与 <em>Views/Home/About.cshtml</em> 视图关联的法语资源文件可能是下面其中之一 ：</p>
<ul>
<li><p>Resources/Views/Home/About.fr.resx</p>
</li>
<li><p>Resources/Views.Home.About.fr.resx</p>
</li>
</ul>
<p>如果不使用 <code>ResourcesPath</code> 选项，视图的 .resx 文件将位于视图所在的文件夹。</p>
<h3 id="rootnamespaceattribute">RootNamespaceAttribute</h3>
<p><a href="/dotnet/api/microsoft.extensions.localization.rootnamespaceattribute?view=aspnetcore-2.1">RootNamespace</a> 属性在程序集的根命名空间不同于程序集名称时，提供程序集的根命名空间。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>当项目名称不是有效的 .NET 标识符时，可能会发生这种情况。 例如，<code>my-project-name.csproj</code> 将使用根命名空间 <code>my_project_name</code> 和导致此错误的程序集名称 <code>my-project-name</code>。</p>
</div>
<p>如果程序集的根命名空间不同于程序集名称：</p>
<ul>
<li>默认情况下无法进行本地化。</li>
<li>因程序集内搜索资源的方式导致本地化失败。 <code>RootNamespace</code> 是生成时间值，不可用于正在执行的进程。</li>
</ul>
<p>如果 <code>RootNamespace</code> 不同于 <code>AssemblyName</code>，请在 AssemblyInfo.cs 中包括以下内容（参数值替换为实际值）：</p>
<pre><code class="lang-csharp">using System.Reflection;
using Microsoft.Extensions.Localization;

[assembly: ResourceLocation(&quot;Resource Folder Name&quot;)]
[assembly: RootNamespace(&quot;App Root Namespace&quot;)]
</code></pre>
<p>上述代码可成功解析 resx 文件。</p>
<h2 id="culture-fallback-behavior">区域性回退行为</h2>
<p>在搜索资源时，本地化会进行“区域性回退”。 从所请求的区域性开始，如果未能找到，则还原至该区域性的父区域性。 另外，<a href="/dotnet/api/system.globalization.cultureinfo.parent">CultureInfo.Parent</a> 属性代表父区域性。 这通常（但并不是总是）意味着从 ISO 中移除区域签名。 例如，墨西哥的西班牙语方言为“es-MX”。 它具备一个父级“es”西班牙，没有特别指定国家/地区。</p>
<p>假设你的站点接收到了一个区域性为“fr-CA”的“Welcome”资源的请求。 本地化系统按顺序查找以下资源，并选择第一个匹配项：</p>
<ul>
<li><em>Welcome.fr-CA.resx</em></li>
<li><em>Welcome.fr.resx</em></li>
<li><em>Welcome.resx</em>（如果 <code>NeutralResourcesLanguage</code> 为“fr-CA”）</li>
</ul>
<p>例如，如果删除了“.fr”区域性指示符，而且已将区域性设置为“法语”，将读取默认资源文件，并本地化字符串。 对于不满足所请求区域性的情况，资源管理器可指定默认资源或回退资源。 缺少适用于请求区域性的资源时，如果只想返回键，不得具有默认资源文件。</p>
<h3 id="generate-resource-files-with-visual-studio">使用 Visual Studio 生成资源文件</h3>
<p>如果在 Visual Studio 中创建文件名没有区域性的资源文件（例如 Welcome.resx），Visual Studio 将创建一个 C# 类，并且具有每个字符串的属性。 这通常不是你想在 ASP.NET Core 中使用的。 你通常没有默认的 .resx 资源文件（没有区域性名称的 .resx 文件） 。 建议创建具有区域性名称（例如 Welcome.fr.resx）的 .resx 文件 。 创建具有区域性名称的 .resx 文件时，Visual Studio 不会生成类文件。</p>
<h3 id="add-other-cultures">添加其他区域性</h3>
<p>每个语言和区域性组合（除默认语言外）都需要唯一资源文件。 通过新建 ISO 语言代码属于名称一部分的资源文件，为不同的区域性和区域设置创建资源文件（例如，en-us、fr-ca 和 en-gb）  。 这些 ISO 编码位于文件名和 .resx 文件扩展之间，如 Welcome.es-MX.resx（西班牙语/墨西哥） 。</p>
<h2 id="implement-a-strategy-to-select-the-languageculture-for-each-request">实施策略，为每个请求选择语言/区域性</h2>
<h3 id="configure-localization">配置本地化</h3>
<p>通过 <code>Startup.ConfigureServices</code> 方法配置本地化：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<ul>
<li><p><code>AddLocalization</code> 将本地化服务添加到服务容器。 上面的代码还将资源路径设置为“Resources”。</p>
</li>
<li><p><code>AddViewLocalization</code> 添加对本地化视图文件的支持。 在此示例视图中，本地化基于视图文件后缀。 例如，Index.fr.cshtml 文件中的“fr”。</p>
</li>
<li><p><code>AddDataAnnotationsLocalization</code> 添加通过 <code>IStringLocalizer</code> 抽象对本地化 <code>DataAnnotations</code> 验证消息的支持。</p>
</li>
</ul>
<h3 id="localization-middleware">本地化中间件</h3>
<p>在本地化<a class="xref" href="middleware/index.html">中间件</a>中设置有关请求的当前区域性。 在 <code>Startup.Configure</code> 方法中启用本地化中间件。 必须在中间件前面配置本地化中间件，它可能检查请求区域性（例如，<code>app.UseMvcWithDefaultRoute()</code>）。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><p>若要查看翻译为非英语语言的代码注释，请在 <a href="https://github.com/MicrosoftDocs/feedback/issues/2515">此 GitHub 讨论问题</a>中告诉我们。</p>

<p><code>UseRequestLocalization</code> 初始化 <code>RequestLocalizationOptions</code> 对象。 在每个请求上，枚举了 <code>RequestLocalizationOptions</code> 的 <code>RequestCultureProvider</code> 列表，使用了可成功决定请求区域性的第一个提供程序。 默认提供程序来自 <code>RequestLocalizationOptions</code> 类：</p>
<ol>
<li><code>QueryStringRequestCultureProvider</code></li>
<li><code>CookieRequestCultureProvider</code></li>
<li><code>AcceptLanguageHeaderRequestCultureProvider</code></li>
</ol>
<p>默认列表从最具体到最不具体排序。 在本文的后面部分，我们将了解如何更改顺序，甚至添加一个自定义区域性提供程序。 如果没有一个提供程序可以确定请求区域性，则使用 <code>DefaultRequestCulture</code>。</p>
<h3 id="querystringrequestcultureprovider">QueryStringRequestCultureProvider</h3>
<p>某些应用将使用查询字符串来设置<a href="https://docs.microsoft.com/dotnet/api/system.globalization.cultureinfo?view=netcore-3.1">https://docs.microsoft.com/dotnet/api/system.globalization.cultureinfo?view=netcore-3.1</a>。 对于使用 cookie 或接受语言标题方法的应用，向 URL 添加查询字符串有助于调试和测试代码。 默认情况下，<code>QueryStringRequestCultureProvider</code> 注册为 <code>RequestCultureProvider</code> 列表中的第一个本地化提供程序。 传递查询字符串参数 <code>culture</code> 和 <code>ui-culture</code>。 下面的示例将特定区域性（语言和区域）设置为“西班牙语/墨西哥”：</p>
<p><code>http://localhost:5000/?culture=es-MX&amp;ui-culture=es-MX</code></p>
<p>如果仅传入两种区域性之一（<code>culture</code> 或 <code>ui-culture</code>，查询字符串提供程序将使用你传入的区域性设置这两个值。 例如，仅设置区域性将同时设置 <code>Culture</code> 和 <code>UICulture</code>：</p>
<pre><code>http://localhost:5000/?culture=es-MX
</code></pre>
<h3 id="no-loccookierequestcultureprovider">CookieRequestCultureProvider</h3>
<p>通常，生产应用将提供一种机制来使用 ASP.NET Core 区域性 cookie 设置区域性。 若要创建 cookie，请使用 <code>MakeCookieValue</code> 方法。</p>
<p><code>CookieRequestCultureProvider</code> <code>DefaultCookieName</code> 将返回用来跟踪用户首选区域性信息的默认 cookie 名称。 默认的 cookie 名称为 <code>.AspNetCore.Culture</code>。</p>
<p>cookie 格式为 <code>c=%LANGCODE%|uic=%LANGCODE%</code>，其中 <code>c</code> 是 <code>Culture</code>，<code>uic</code> 是 <code>UICulture</code>，例如：</p>
<pre><code>c=en-UK|uic=en-US
</code></pre>
<p>如果仅指定其中一个区域性信息和 UI 区域性，则指定的区域性将同时用于区域性信息和 UI 区域性。</p>
<h3 id="the-accept-language-http-header">接受语言 HTTP 标题</h3>
<p><a href="https://www.w3.org/International/questions/qa-accept-lang-locales">接受语言标题</a>在大多数浏览器中可设置，最初用于指定用户的语言。 此设置指示浏览器已设置为发送或已从基础操作系统继承的内容。 浏览器请求的接受语言 HTTP 标题不是检测用户首选语言的可靠方法（请参阅 <a href="https://www.w3.org/International/questions/qa-lang-priorities.en.php">Setting language preferences in a browser</a>（在浏览器中设置首选项）。 生产应用应包括一种用户可以自定义区域性选择的方法。</p>
<h3 id="set-the-accept-language-http-header-in-ie">在 IE 中设置接受语言 HTTP 标题</h3>
<ol>
<li><p>在齿轮图标中，点击“Internet 选项”。</p>
</li>
<li><p>点击“语言”。</p>
<p><img src="localization/_static/lang.png" alt="Internet 选项"></p>
</li>
<li><p>点击“设置语言首选项”。</p>
</li>
<li><p>点击“添加语言”。</p>
</li>
<li><p>添加语言。</p>
</li>
<li><p>点击语言，然后点击“向上移动”。</p>
</li>
</ol>
<h3 id="use-a-custom-provider">使用自定义提供程序</h3>
<p>假设你想要让客户在数据库中存储其语言和区域性。 你可以编写一个提供程序来查找用户的这些值。 下面的代码演示如何添加自定义提供程序：</p>
<pre><code class="lang-csharp">private const string enUSCulture = &quot;en-US&quot;;

services.Configure&lt;RequestLocalizationOptions&gt;(options =&gt;
{
    var supportedCultures = new[]
    {
        new CultureInfo(enUSCulture),
        new CultureInfo(&quot;fr&quot;)
    };

    options.DefaultRequestCulture = new RequestCulture(culture: enUSCulture, uiCulture: enUSCulture);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;

    options.AddInitialRequestCultureProvider(new CustomRequestCultureProvider(async context =&gt;
    {
        // My custom request culture logic
        return new ProviderCultureResult(&quot;en&quot;);
    }));
});
</code></pre>
<p>使用 <code>RequestLocalizationOptions</code> 添加或删除本地化提供程序。</p>
<h3 id="set-the-culture-programmatically">以编程方式设置区域性</h3>
<p><a href="https://github.com/aspnet/entropy">GitHub</a> 上的示例项目 Localization.StarterWeb 包含设置 <code>Culture</code> 的 UI。 Views/Shared/_SelectLanguagePartial.cshtml 文件允许你从支持的区域性列表中选择区域性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Views/Shared/_SelectLanguagePartial.cshtml 文件添加到了布局文件的 <code>footer</code> 部分，使它将可供所有视图使用：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>SetLanguage</code> 方法可设置区域性 cookie。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>不能将 _SelectLanguagePartial.cshtml 插入此项目的示例代码。 <a href="https://github.com/aspnet/entropy">GitHub</a> 上的 Localization.StarterWeb 项目包含的代码可通过<a href="dependency-injection.html">依赖项注入</a>容器将 <code>RequestLocalizationOptions</code> 流到 Razor 部分。</p>
<h2 id="model-binding-route-data-and-query-strings">模型绑定路由数据和查询字符串</h2>
<p>请参阅<a class="xref" href="../mvc/models/model-binding.html#glob">模型绑定路由数据和查询字符串的全球化行为</a>。</p>
<h2 id="globalization-and-localization-terms">全球化和本地化术语</h2>
<p>本地化应用的过程还要求基本了解现代软件开发中常用的相关字符集，以及与之相关的问题。 尽管所有计算机将文本都存储为数字（代码），但不同的系统使用不同的数字存储相同的文本。 本地化过程是指针对特定区域性/区域设置转换应用的用户界面 (UI)。</p>
<p><a href="/dotnet/standard/globalization-localization/localizability-review">本地化性</a>是一个中间过程，用于验证全球化应用是否准备好进行本地化。</p>
<p>区域性名称的 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 格式为 <code>&lt;languagecode2&gt;-&lt;country/regioncode2&gt;</code>，其中 <code>&lt;languagecode2&gt;</code> 是语言代码，<code>&lt;country/regioncode2&gt;</code> 是子区域性代码。 例如，<code>es-CL</code> 表示西班牙语（智利），<code>en-US</code> 表示英语（美国），而 <code>en-AU</code> 表示英语（澳大利亚）。 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 是一个与语言相关的 ISO 639 双小写字母的区域性代码和一个与国家/地区相关的 ISO 3166 双大写字母子区域性代码的组合。 请参阅 <a href="https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)">https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)</a>。</p>
<p>国际化常缩写为“I18N”。 缩写采用第一个和最后一个字母以及它们之间的字母数，因此 18 代表第一个字母“I”和最后一个“N”之间的字母数。 这同样适用于全球化 (G11N) 和本地化 (L10N)。</p>
<p>术语：</p>
<ul>
<li>全球化 (G11N)：使应用支持不同语言和区域的过程。</li>
<li>本地化 (L10N)：针对给定语言和区域自定义应用的过程。</li>
<li>国际化 (I18N)：介绍了全球化和本地化。</li>
<li>区域性：它是一种语言和区域（可选）。</li>
<li>非特定区域性：具有指定语言但不具有区域的区域性。 （例如，“en”，“es”）</li>
<li>特定区域性：具有指定语言和区域的区域性。 （例如，“en-US”，“en-GB”，“es-CL”）</li>
<li>父区域性：包含特定区域性的非特定区域性。 （例如，“en”是“en-US”和“en-GB”的父区域性）</li>
<li>区域设置：区域设置与区域性相同。</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>可能无法在小数字段中输入十进制逗号。 若要使 <a href="https://jqueryvalidation.org/">jQuery 验证</a>支持使用逗号（“,”）表示小数点的的非英语区域设置，以及支持非美国英语日期格式，必须执行使应用全球化的步骤。 有关添加十进制逗号的说明，<a href="https://github.com/dotnet/AspNetCore.Docs/issues/4076#issuecomment-326590420">请参阅 GitHub 问题 4076</a>。</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>在 ASP.NET Core 3.0 之前，如果请求的区域性不受支持，Web 应用将写入每个请求的一个类型为 <code>LogLevel.Warning</code> 的日志。 记录每个请求的一个 <code>LogLevel.Warning</code> 可以生成包含冗余信息的大型日志文件。 此行为已在 ASP.NET 3.0 中进行了更改。 <code>RequestLocalizationMiddleware</code> 写入类型为 <code>LogLevel.Debug</code> 的日志，这会减小生产日志的大小。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="troubleshoot-aspnet-core-localization.html">对 ASP.NET Core 本地化进行故障排除</a></li>
<li>本文所用的 <a href="https://github.com/aspnet/Entropy/tree/master/samples/Localization.StarterWeb">Localization.StarterWeb 项目</a>。</li>
<li><a href="/dotnet/standard/globalization-localization/index">对 .NET 应用程序进行全球化和本地化</a></li>
<li><a href="/dotnet/framework/resources/working-with-resx-files-programmatically">.resx 文件中的资源</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=MultilingualAppToolkit.MultilingualAppToolkit-18308">Microsoft 多语言应用工具包</a></li>
<li><a href="http://hishambinateya.com/localization-and-generics">本地化与泛型</a></li>
</ul>
</div>
<div range="&lt; aspnetcore-3.0">
<p>作者：<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://twitter.com/damien_bod">Damien Bowden</a>、<a href="https://twitter.com/bartmax">Bart Calixto</a>、<a href="https://afana.me/">Nadeem Afana</a> 和 <a href="https://twitter.com/hishambinateya">Hisham Bin Ateya</a></p>
<p>多语言网站使网站可以覆盖更广泛的受众。 ASP.NET Core 提供的服务和中间件可将网站本地化为不同的语言和文化。</p>
<p>国际化涉及<a href="/dotnet/api/system.globalization">全球化</a>和<a href="/dotnet/standard/globalization-localization/localization">本地化</a>。 全球化是设计支持不同区域性的应用程序的过程。 全球化添加了对一组有关特定地理区域的已定义语言脚本的输入、显示和输出支持。</p>
<p>本地化是将已经针对可本地化性进行处理的全球化应用调整为特定的区域性/区域设置的过程。 有关详细信息，请参阅本文档邻近末尾的全球化和本地化术语。</p>
<p>应用本地化涉及以下内容：</p>
<ol>
<li>使应用内容可本地化</li>
<li>为支持的语言和区域性提供本地化资源</li>
<li>实施策略，为每个请求选择语言/区域性</li>
</ol>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/localization/sample/Localization">查看或下载示例代码</a>（<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="make-the-apps-content-localizable">使应用内容可本地化</h2>
<p>已为 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer&gt; 和 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer%601&gt; 设置架构，可以为开发本地化应用提高工作效率。 <code>IStringLocalizer</code> 使用 &lt;xref:System.Resources.ResourceManager&gt; 和 &lt;xref:System.Resources.ResourceReader&gt; 在运行时提供特定于区域性的资源。 接口具有一个索引器和一个用于返回本地化字符串的 <code>IEnumerable</code>。 <code>IStringLocalizer</code> 不要求在资源文件中存储默认语言字符串。 你可以开发针对本地化的应用，且无需在开发初期创建资源资源文件。 下面的代码演示如何针对本地化包装字符串“About Title”。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，<code>IStringLocalizer&lt;T&gt;</code> 实现来源于<a href="dependency-injection.html">依赖关系注入</a>。 如果找不到“About Title”的本地化值，则返回索引器键，即字符串“About Title”。 可将默认语言文本字符串保留在应用中并将它们包装在本地化工具中，以便你可集中精力开发应用。 你使用默认语言开发应用，并针对本地化步骤进行准备，而无需首先创建默认资源文件。 或者，你可以使用传统方法，并提供键以检索默认语言字符串。 对于许多开发者而言，不具有默认语言 .resx 文件且简单包装字符串文本的新工作流可以减少本地化应用的开销。 其他开发者将首选传统工作流，因为它可以更轻松地使用较长字符串文本，更轻松地更新本地化字符串。</p>
<p>对包含 HTML 的资源使用 <code>IHtmlLocalizer&lt;T&gt;</code> 实现。 <code>IHtmlLocalizer</code> 对资源字符串中格式化的参数进行 HTML 编码，但不对资源字符串本身进行 HTML 编码。 在下面突出显示的示例中，仅 <code>name</code> 参数的值被 HTML 编码。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>最低程度，你可以从<a href="dependency-injection.html">依赖关系注入</a>获取 <code>IStringLocalizerFactory</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>上面的代码演示了这两种工厂创建方法。</p>
<p>可以按控制器、区域对本地化字符串分区，或只有一个容器。 在示例应用中，名为 <code>SharedResource</code> 的虚拟类用于共享资源。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>某些开发者使用 <code>Startup</code> 类，以包含全局或共享字符串。 在下面的示例中，使用 <code>InfoController</code> 和 <code>SharedResource</code> 本地化工具：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="view-localization">视图本地化</h2>
<p><code>IViewLocalizer</code> 服务可为<a class="xref" href="../mvc/views/overview.html">视图</a>提供本地化字符串。 <code>ViewLocalizer</code> 类可实现此接口，并从视图文件路径找到资源位置。 下面的代码演示如何使用 <code>IViewLocalizer</code> 的默认实现：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>IViewLocalizer</code> 的默认实现可根据视图的文件名查找资源文件。 没有使用全局共享资源文件的选项。 <code>ViewLocalizer</code> 使用 <code>IHtmlLocalizer</code> 实现本地化工具，因此 Razor 不会对本地化字符串进行 HTML 编码。 你可以参数化资源字符串，<code>IViewLocalizer</code> 将对参数进行 HTML 编码，但不会对资源字符串进行。 请考虑以下 Razor 标记：</p>
<pre><code class="lang-cshtml">@Localizer[&quot;&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;&quot;, UserManager.GetUserName(User)]
</code></pre>
<p>法语资源文件可以包含以下信息：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>“值”</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;</code></td>
<td><code>&lt;i&gt;Bonjour&lt;/i&gt; &lt;b&gt;{0} !&lt;/b&gt;</code></td>
</tr>
</tbody>
</table>
<p>呈现的视图可能包含资源文件中的 HTML 标记。</p>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>若要在视图中使用共享资源文件，请注入 <code>IHtmlLocalizer&lt;T&gt;</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="dataannotations-localization">DataAnnotations 本地化</h2>
<p>DataAnnotations 错误消息已使用 <code>IStringLocalizer&lt;T&gt;</code> 本地化。 使用选项 <code>ResourcesPath = &quot;Resources&quot;</code>，<code>RegisterViewModel</code> 中的错误消息可以存储在以下路径之一：</p>
<ul>
<li><em>Resources/ViewModels.Account.RegisterViewModel.fr.resx</em></li>
<li><em>Resources/ViewModels/Account/RegisterViewModel.fr.resx</em></li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在 ASP.NET Core MVC 1.1.0 和更高版本中，非验证属性已经进行了本地化。 ASP.NET Core MVC 1.0 不会为非验证属性查找本地化字符串。</p>
<p><a name="one-resource-string-multiple-classes"></a></p>
<h3 id="using-one-resource-string-for-multiple-classes">对多个类使用一个资源字符串</h3>
<p>下面的代码演示如何针对具有多个类的验证属性使用一个资源字符串：</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc()
        .AddDataAnnotationsLocalization(options =&gt; {
            options.DataAnnotationLocalizerProvider = (type, factory) =&gt;
                factory.Create(typeof(SharedResource));
        });
}
</code></pre>
<p>在上面的代码中，<code>SharedResource</code> 是对应于存储验证消息的 resx 的类。 使用此方法，DataAnnotations 将仅使用 <code>SharedResource</code>，而不是每个类的资源。</p>
<h2 id="provide-localized-resources-for-the-languages-and-cultures-you-support">为支持的语言和区域性提供本地化资源</h2>
<h3 id="supportedcultures-and-supporteduicultures">SupportedCultures 和 SupportedUICultures</h3>
<p>ASP.NET Core 允许指定两个区域性值，<code>SupportedCultures</code> 和 <code>SupportedUICultures</code>。 <code>SupportedCultures</code> 的 <a href="/dotnet/api/system.globalization.cultureinfo">CultureInfo</a> 对象可决定区域性相关函数的结果，如日期、时间、数字和货币格式等。 <code>SupportedCultures</code> 确定文本的排序顺序、大小写约定和字符串比较。 请参阅 <a href="/dotnet/api/system.stringcomparer.currentculture#System_StringComparer_CurrentCulture">CultureInfo.CurrentCulture</a> 详细了解服务器如何获取区域性。 <code>SupportedUICultures</code> 可确定按 <a href="/dotnet/api/system.resources.resourcemanager">ResourceManager</a> 来查找哪些转换字符串（位于 .resx 文件）。 <code>ResourceManager</code> 只需查找 <code>CurrentUICulture</code> 决定的区域性特定字符串。 .NET 中的每个线程都具有 <code>CurrentCulture</code> 和 <code>CurrentUICulture</code> 对象。 呈现区域性相关函数时，ASP.NET Core 可检查这些值。 例如，如果当前线程的区域性设置为“en-US”（英语，美国），<code>DateTime.Now.ToLongDateString()</code> 将显示“Thursday, February 18, 2016”，但如果 <code>CurrentCulture</code> 设置为“es-ES”（西班牙语，西班牙），则输出将为“jueves，18 de febrero de 2016”。</p>
<h2 id="resource-files">资源文件</h2>
<p>资源文件是将可本地化的字符串与代码分离的有用机制。 非默认语言的转换字符串在 .resx 资源文件中单独显示。 例如，你可能想要创建包含转换字符串、名为 Welcome.es.resx 的西班牙语资源文件。 “es”是西班牙语的语言代码。 要在 Visual Studio 中创建此资源文件，请支持以下操作：</p>
<ol>
<li><p>在“解决方案资源管理器”中，右键单击将包含资源文件的文件夹 &gt;“添加”&gt;“新项”  。</p>
<p><img src="localization/_static/newi.png" alt="嵌套的上下文菜单：在“解决方案资源管理器”中，“资源”可打开上下文菜单。 “添加”可打开第二个上下文菜单，突出显示“新项”命令。"></p>
</li>
<li><p>在“搜索已安装的模板”框中，输入“资源”并命名该文件。</p>
<p><img src="localization/_static/res.png" alt="“添加新项”对话框"></p>
</li>
<li><p>在“名称”列中输入键值（本机字符串），在“值”列中输入转换字符串 。</p>
<p><img src="localization/_static/hola.png" alt="Welcome.es.resx 文件（西班牙语版 Welcome 资源文件）的单词 Hello 位于“名称”列，Hola（西班牙语版 Hello）位于“值”列"></p>
<p>Visual Studio 将显示 Welcome.es.resx 文件。</p>
<p><img src="localization/_static/se.png" alt="显示 Welcome Spanish (es) 资源文件的解决方案资源管理器"></p>
</li>
</ol>
<h2 id="resource-file-naming">资源文件命名</h2>
<p>资源名称是类的完整类型名称减去程序集名称。 例如，类 <code>LocalizationWebsite.Web.Startup</code> 的主要程序集为 <code>LocalizationWebsite.Web.dll</code> 的项目中的法语资源将命名为 Startup.fr.resx。 类 <code>LocalizationWebsite.Web.Controllers.HomeController</code> 的资源将命名为 Controllers.HomeController.fr.resx。 如果目标类的命名空间与将需要完整类型名称的程序集名称不同。 例如，在示例项目中，类型 <code>ExtraNamespace.Tools</code> 的资源将命名为 ExtraNamespace.Tools.fr.resx。</p>
<p>在示例项目中，<code>ConfigureServices</code> 方法将 <code>ResourcesPath</code> 设置为“资源”，因此主控制器的法语资源文件的项目相对路径是 Resources/Controllers.HomeController.fr.resx。 或者，你可以使用文件夹组织资源文件。 对于主控制器，该路径将为 Resources/Controllers/HomeController.fr.resx。 如果不使用 <code>ResourcesPath</code> 选项，.resx 文件将转到项目的基目录中。 <code>HomeController</code> 的资源文件将命名为 Controllers.HomeController.fr.resx。 是选择使用圆点还是路径命名约定，具体取决于你想如何组织资源文件。</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>圆点或路径命名</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resources/Controllers.HomeController.fr.resx</td>
<td>圆点</td>
</tr>
<tr>
<td>Resources/Controllers/HomeController.fr.resx</td>
<td>路径</td>
</tr>
</tbody>
</table>
<p>Razor 视图中使用 <code>@inject IViewLocalizer</code> 的资源文件遵循类似的模式。 可以使用圆点命名或路径命名约定对视图的资源文件进行命名。 Razor 视图资源文件可模拟其关联视图文件的路径。 假设我们将 <code>ResourcesPath</code> 设置为“Resources”，与 <em>Views/Home/About.cshtml</em> 视图关联的法语资源文件可能是下面其中之一 ：</p>
<ul>
<li><p>Resources/Views/Home/About.fr.resx</p>
</li>
<li><p>Resources/Views.Home.About.fr.resx</p>
</li>
</ul>
<p>如果不使用 <code>ResourcesPath</code> 选项，视图的 .resx 文件将位于视图所在的文件夹。</p>
<h3 id="rootnamespaceattribute">RootNamespaceAttribute</h3>
<p><a href="/dotnet/api/microsoft.extensions.localization.rootnamespaceattribute?view=aspnetcore-2.1">RootNamespace</a> 属性在程序集的根命名空间不同于程序集名称时，提供程序集的根命名空间。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>当项目名称不是有效的 .NET 标识符时，可能会发生这种情况。 例如，<code>my-project-name.csproj</code> 将使用根命名空间 <code>my_project_name</code> 和导致此错误的程序集名称 <code>my-project-name</code>。</p>
</div>
<p>如果程序集的根命名空间不同于程序集名称：</p>
<ul>
<li>默认情况下无法进行本地化。</li>
<li>因程序集内搜索资源的方式导致本地化失败。 <code>RootNamespace</code> 是生成时间值，不可用于正在执行的进程。</li>
</ul>
<p>如果 <code>RootNamespace</code> 不同于 <code>AssemblyName</code>，请在 AssemblyInfo.cs 中包括以下内容（参数值替换为实际值）：</p>
<pre><code class="lang-csharp">using System.Reflection;
using Microsoft.Extensions.Localization;

[assembly: ResourceLocation(&quot;Resource Folder Name&quot;)]
[assembly: RootNamespace(&quot;App Root Namespace&quot;)]
</code></pre>
<p>上述代码可成功解析 resx 文件。</p>
<h2 id="culture-fallback-behavior">区域性回退行为</h2>
<p>在搜索资源时，本地化会进行“区域性回退”。 从所请求的区域性开始，如果未能找到，则还原至该区域性的父区域性。 另外，<a href="/dotnet/api/system.globalization.cultureinfo.parent">CultureInfo.Parent</a> 属性代表父区域性。 这通常（但并不是总是）意味着从 ISO 中移除区域签名。 例如，墨西哥的西班牙语方言为“es-MX”。 它具备一个父级“es”西班牙，没有特别指定国家/地区。</p>
<p>假设你的站点接收到了一个区域性为“fr-CA”的“Welcome”资源的请求。 本地化系统按顺序查找以下资源，并选择第一个匹配项：</p>
<ul>
<li><em>Welcome.fr-CA.resx</em></li>
<li><em>Welcome.fr.resx</em></li>
<li><em>Welcome.resx</em>（如果 <code>NeutralResourcesLanguage</code> 为“fr-CA”）</li>
</ul>
<p>例如，如果删除了“.fr”区域性指示符，而且已将区域性设置为“法语”，将读取默认资源文件，并本地化字符串。 对于不满足所请求区域性的情况，资源管理器可指定默认资源或回退资源。 缺少适用于请求区域性的资源时，如果只想返回键，不得具有默认资源文件。</p>
<h3 id="generate-resource-files-with-visual-studio">使用 Visual Studio 生成资源文件</h3>
<p>如果在 Visual Studio 中创建文件名没有区域性的资源文件（例如 Welcome.resx），Visual Studio 将创建一个 C# 类，并且具有每个字符串的属性。 这通常不是你想在 ASP.NET Core 中使用的。 你通常没有默认的 .resx 资源文件（没有区域性名称的 .resx 文件） 。 建议创建具有区域性名称（例如 Welcome.fr.resx）的 .resx 文件 。 创建具有区域性名称的 .resx 文件时，Visual Studio 不会生成类文件。</p>
<h3 id="add-other-cultures">添加其他区域性</h3>
<p>每个语言和区域性组合（除默认语言外）都需要唯一资源文件。 通过新建 ISO 语言代码属于名称一部分的资源文件，为不同的区域性和区域设置创建资源文件（例如，en-us、fr-ca 和 en-gb）  。 这些 ISO 编码位于文件名和 .resx 文件扩展之间，如 Welcome.es-MX.resx（西班牙语/墨西哥） 。</p>
<h2 id="implement-a-strategy-to-select-the-languageculture-for-each-request">实施策略，为每个请求选择语言/区域性</h2>
<h3 id="configure-localization">配置本地化</h3>
<p>通过 <code>Startup.ConfigureServices</code> 方法配置本地化：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<ul>
<li><p><code>AddLocalization</code> 将本地化服务添加到服务容器。 上面的代码还将资源路径设置为“Resources”。</p>
</li>
<li><p><code>AddViewLocalization</code> 添加对本地化视图文件的支持。 在此示例视图中，本地化基于视图文件后缀。 例如，Index.fr.cshtml 文件中的“fr”。</p>
</li>
<li><p><code>AddDataAnnotationsLocalization</code> 添加通过 <code>IStringLocalizer</code> 抽象对本地化 <code>DataAnnotations</code> 验证消息的支持。</p>
</li>
</ul>
<h3 id="localization-middleware">本地化中间件</h3>
<p>在本地化<a class="xref" href="middleware/index.html">中间件</a>中设置有关请求的当前区域性。 在 <code>Startup.Configure</code> 方法中启用本地化中间件。 必须在中间件前面配置本地化中间件，它可能检查请求区域性（例如，<code>app.UseMvcWithDefaultRoute()</code>）。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><p>若要查看翻译为非英语语言的代码注释，请在 <a href="https://github.com/MicrosoftDocs/feedback/issues/2515">此 GitHub 讨论问题</a>中告诉我们。</p>

<p><code>UseRequestLocalization</code> 初始化 <code>RequestLocalizationOptions</code> 对象。 在每个请求上，枚举了 <code>RequestLocalizationOptions</code> 的 <code>RequestCultureProvider</code> 列表，使用了可成功决定请求区域性的第一个提供程序。 默认提供程序来自 <code>RequestLocalizationOptions</code> 类：</p>
<ol>
<li><code>QueryStringRequestCultureProvider</code></li>
<li><code>CookieRequestCultureProvider</code></li>
<li><code>AcceptLanguageHeaderRequestCultureProvider</code></li>
</ol>
<p>默认列表从最具体到最不具体排序。 在本文的后面部分，我们将了解如何更改顺序，甚至添加一个自定义区域性提供程序。 如果没有一个提供程序可以确定请求区域性，则使用 <code>DefaultRequestCulture</code>。</p>
<h3 id="querystringrequestcultureprovider">QueryStringRequestCultureProvider</h3>
<p>某些应用将使用查询字符串来设置<a href="https://docs.microsoft.com/dotnet/api/system.globalization.cultureinfo?view=netcore-3.1">https://docs.microsoft.com/dotnet/api/system.globalization.cultureinfo?view=netcore-3.1</a>。 对于使用 cookie 或接受语言标题方法的应用，向 URL 添加查询字符串有助于调试和测试代码。 默认情况下，<code>QueryStringRequestCultureProvider</code> 注册为 <code>RequestCultureProvider</code> 列表中的第一个本地化提供程序。 传递查询字符串参数 <code>culture</code> 和 <code>ui-culture</code>。 下面的示例将特定区域性（语言和区域）设置为“西班牙语/墨西哥”：</p>
<pre><code>http://localhost:5000/?culture=es-MX&amp;ui-culture=es-MX
</code></pre>
<p>如果仅传入两种区域性之一（<code>culture</code> 或 <code>ui-culture</code>，查询字符串提供程序将使用你传入的区域性设置这两个值。 例如，仅设置区域性将同时设置 <code>Culture</code> 和 <code>UICulture</code>：</p>
<pre><code>http://localhost:5000/?culture=es-MX
</code></pre>
<h3 id="no-loccookierequestcultureprovider">CookieRequestCultureProvider</h3>
<p>通常，生产应用将提供一种机制来使用 ASP.NET Core 区域性 cookie 设置区域性。 若要创建 cookie，请使用 <code>MakeCookieValue</code> 方法。</p>
<p><code>CookieRequestCultureProvider</code> <code>DefaultCookieName</code> 将返回用来跟踪用户首选区域性信息的默认 cookie 名称。 默认的 cookie 名称为 <code>.AspNetCore.Culture</code>。</p>
<p>cookie 格式为 <code>c=%LANGCODE%|uic=%LANGCODE%</code>，其中 <code>c</code> 是 <code>Culture</code>，<code>uic</code> 是 <code>UICulture</code>，例如：</p>
<pre><code>c=en-UK|uic=en-US
</code></pre>
<p>如果仅指定其中一个区域性信息和 UI 区域性，则指定的区域性将同时用于区域性信息和 UI 区域性。</p>
<h3 id="the-accept-language-http-header">接受语言 HTTP 标题</h3>
<p><a href="https://www.w3.org/International/questions/qa-accept-lang-locales">接受语言标题</a>在大多数浏览器中可设置，最初用于指定用户的语言。 此设置指示浏览器已设置为发送或已从基础操作系统继承的内容。 浏览器请求的接受语言 HTTP 标题不是检测用户首选语言的可靠方法（请参阅 <a href="https://www.w3.org/International/questions/qa-lang-priorities.en.php">Setting language preferences in a browser</a>（在浏览器中设置首选项）。 生产应用应包括一种用户可以自定义区域性选择的方法。</p>
<h3 id="set-the-accept-language-http-header-in-ie">在 IE 中设置接受语言 HTTP 标题</h3>
<ol>
<li><p>在齿轮图标中，点击“Internet 选项”。</p>
</li>
<li><p>点击“语言”。</p>
<p><img src="localization/_static/lang.png" alt="Internet 选项"></p>
</li>
<li><p>点击“设置语言首选项”。</p>
</li>
<li><p>点击“添加语言”。</p>
</li>
<li><p>添加语言。</p>
</li>
<li><p>点击语言，然后点击“向上移动”。</p>
</li>
</ol>
<h3 id="use-a-custom-provider">使用自定义提供程序</h3>
<p>假设你想要让客户在数据库中存储其语言和区域性。 你可以编写一个提供程序来查找用户的这些值。 下面的代码演示如何添加自定义提供程序：</p>
<pre><code class="lang-csharp">private const string enUSCulture = &quot;en-US&quot;;

services.Configure&lt;RequestLocalizationOptions&gt;(options =&gt;
{
    var supportedCultures = new[]
    {
        new CultureInfo(enUSCulture),
        new CultureInfo(&quot;fr&quot;)
    };

    options.DefaultRequestCulture = new RequestCulture(culture: enUSCulture, uiCulture: enUSCulture);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;

    options.RequestCultureProviders.Insert(0, new CustomRequestCultureProvider(async context =&gt;
    {
        // My custom request culture logic
        return new ProviderCultureResult(&quot;en&quot;);
    }));
});
</code></pre>
<p>使用 <code>RequestLocalizationOptions</code> 添加或删除本地化提供程序。</p>
<h3 id="set-the-culture-programmatically">以编程方式设置区域性</h3>
<p><a href="https://github.com/aspnet/entropy">GitHub</a> 上的示例项目 Localization.StarterWeb 包含设置 <code>Culture</code> 的 UI。 Views/Shared/_SelectLanguagePartial.cshtml 文件允许你从支持的区域性列表中选择区域性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Views/Shared/_SelectLanguagePartial.cshtml 文件添加到了布局文件的 <code>footer</code> 部分，使它将可供所有视图使用：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>SetLanguage</code> 方法可设置区域性 cookie。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>不能将 _SelectLanguagePartial.cshtml 插入此项目的示例代码。 <a href="https://github.com/aspnet/entropy">GitHub</a> 上的 Localization.StarterWeb 项目包含的代码可通过<a href="dependency-injection.html">依赖项注入</a>容器将 <code>RequestLocalizationOptions</code> 流到 Razor 部分。</p>
<h2 id="model-binding-route-data-and-query-strings">模型绑定路由数据和查询字符串</h2>
<p>请参阅<a class="xref" href="../mvc/models/model-binding.html#glob">模型绑定路由数据和查询字符串的全球化行为</a>。</p>
<h2 id="globalization-and-localization-terms">全球化和本地化术语</h2>
<p>本地化应用的过程还要求基本了解现代软件开发中常用的相关字符集，以及与之相关的问题。 尽管所有计算机将文本都存储为数字（代码），但不同的系统使用不同的数字存储相同的文本。 本地化过程是指针对特定区域性/区域设置转换应用的用户界面 (UI)。</p>
<p><a href="/dotnet/standard/globalization-localization/localizability-review">本地化性</a>是一个中间过程，用于验证全球化应用是否准备好进行本地化。</p>
<p>区域性名称的 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 格式为 <code>&lt;languagecode2&gt;-&lt;country/regioncode2&gt;</code>，其中 <code>&lt;languagecode2&gt;</code> 是语言代码，<code>&lt;country/regioncode2&gt;</code> 是子区域性代码。 例如，<code>es-CL</code> 表示西班牙语（智利），<code>en-US</code> 表示英语（美国），而 <code>en-AU</code> 表示英语（澳大利亚）。 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 是一个与语言相关的 ISO 639 双小写字母的区域性代码和一个与国家/地区相关的 ISO 3166 双大写字母子区域性代码的组合。 请参阅 <a href="https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)">https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)</a>。</p>
<p>国际化常缩写为“I18N”。 缩写采用第一个和最后一个字母以及它们之间的字母数，因此 18 代表第一个字母“I”和最后一个“N”之间的字母数。 这同样适用于全球化 (G11N) 和本地化 (L10N)。</p>
<p>术语：</p>
<ul>
<li>全球化 (G11N)：使应用支持不同语言和区域的过程。</li>
<li>本地化 (L10N)：针对给定语言和区域自定义应用的过程。</li>
<li>国际化 (I18N)：介绍了全球化和本地化。</li>
<li>区域性：它是一种语言和区域（可选）。</li>
<li>非特定区域性：具有指定语言但不具有区域的区域性。 （例如，“en”，“es”）</li>
<li>特定区域性：具有指定语言和区域的区域性。 （例如，“en-US”，“en-GB”，“es-CL”）</li>
<li>父区域性：包含特定区域性的非特定区域性。 （例如，“en”是“en-US”和“en-GB”的父区域性）</li>
<li>区域设置：区域设置与区域性相同。</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>可能无法在小数字段中输入十进制逗号。 若要使 <a href="https://jqueryvalidation.org/">jQuery 验证</a>支持使用逗号（“,”）表示小数点的的非英语区域设置，以及支持非美国英语日期格式，必须执行使应用全球化的步骤。 有关添加十进制逗号的说明，<a href="https://github.com/dotnet/AspNetCore.Docs/issues/4076#issuecomment-326590420">请参阅 GitHub 问题 4076</a>。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="troubleshoot-aspnet-core-localization.html">对 ASP.NET Core 本地化进行故障排除</a></li>
<li>本文所用的 <a href="https://github.com/aspnet/Entropy/tree/master/samples/Localization.StarterWeb">Localization.StarterWeb 项目</a>。</li>
<li><a href="/dotnet/standard/globalization-localization/index">对 .NET 应用程序进行全球化和本地化</a></li>
<li><a href="/dotnet/framework/resources/working-with-resx-files-programmatically">.resx 文件中的资源</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=MultilingualAppToolkit.MultilingualAppToolkit-18308">Microsoft 多语言应用工具包</a></li>
<li><a href="http://hishambinateya.com/localization-and-generics">本地化与泛型</a></li>
</ul>
</div>
<!-- ASP.NET Core 5.x starts here -->
<div range="&gt; aspnetcore-3.1">
<p>作者：<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://twitter.com/damien_bod">Damien Bowden</a>、<a href="https://twitter.com/bartmax">Bart Calixto</a>、<a href="https://afana.me/">Nadeem Afana</a> 和 <a href="https://twitter.com/hishambinateya">Hisham Bin Ateya</a></p>
<p>多语言网站使网站可以覆盖更广泛的受众。 ASP.NET Core 提供的服务和中间件可将网站本地化为不同的语言和文化。</p>
<p>国际化涉及<a href="/dotnet/api/system.globalization">全球化</a>和<a href="/dotnet/standard/globalization-localization/localization">本地化</a>。 全球化是设计支持不同区域性的应用程序的过程。 全球化添加了对一组有关特定地理区域的已定义语言脚本的输入、显示和输出支持。</p>
<p>本地化是将已经针对可本地化性进行处理的全球化应用调整为特定的区域性/区域设置的过程。 有关详细信息，请参阅本文档邻近末尾的全球化和本地化术语。</p>
<p>应用本地化涉及以下内容：</p>
<ol>
<li>使应用内容可本地化</li>
<li>为支持的语言和区域性提供本地化资源</li>
<li>实施策略，为每个请求选择语言/区域性</li>
</ol>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/localization/sample/2.x/">查看或下载示例代码</a>（<a class="xref" href="../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）</p>
<h2 id="make-the-apps-content-localizable">使应用内容可本地化</h2>
<p>已为 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer&gt; 和 &lt;xref:Microsoft.Extensions.Localization.IStringLocalizer%601&gt; 设置架构，可以为开发本地化应用提高工作效率。 <code>IStringLocalizer</code> 使用 &lt;xref:System.Resources.ResourceManager&gt; 和 &lt;xref:System.Resources.ResourceReader&gt; 在运行时提供特定于区域性的资源。 接口具有一个索引器和一个用于返回本地化字符串的 <code>IEnumerable</code>。 <code>IStringLocalizer</code> 不要求在资源文件中存储默认语言字符串。 你可以开发针对本地化的应用，且无需在开发初期创建资源资源文件。 下面的代码演示如何针对本地化包装字符串“About Title”。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，<code>IStringLocalizer&lt;T&gt;</code> 实现来源于<a href="dependency-injection.html">依赖关系注入</a>。 如果找不到“About Title”的本地化值，则返回索引器键，即字符串“About Title”。 可将默认语言文本字符串保留在应用中并将它们包装在本地化工具中，以便你可集中精力开发应用。 你使用默认语言开发应用，并针对本地化步骤进行准备，而无需首先创建默认资源文件。 或者，你可以使用传统方法，并提供键以检索默认语言字符串。 对于许多开发者而言，不具有默认语言 .resx 文件且简单包装字符串文本的新工作流可以减少本地化应用的开销。 其他开发者将首选传统工作流，因为它可以更轻松地使用较长字符串文本，更轻松地更新本地化字符串。</p>
<p>对包含 HTML 的资源使用 <code>IHtmlLocalizer&lt;T&gt;</code> 实现。 <code>IHtmlLocalizer</code> 对资源字符串中格式化的参数进行 HTML 编码，但不对资源字符串本身进行 HTML 编码。 在下面突出显示的示例中，仅 <code>name</code> 参数的值被 HTML 编码。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>最低程度，你可以从<a href="dependency-injection.html">依赖关系注入</a>获取 <code>IStringLocalizerFactory</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>上面的代码演示了这两种工厂创建方法。</p>
<p>可以按控制器、区域对本地化字符串分区，或只有一个容器。 在示例应用中，名为 <code>SharedResource</code> 的虚拟类用于共享资源。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>某些开发者使用 <code>Startup</code> 类，以包含全局或共享字符串。 在下面的示例中，使用 <code>InfoController</code> 和 <code>SharedResource</code> 本地化工具：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="view-localization">视图本地化</h2>
<p><code>IViewLocalizer</code> 服务可为<a class="xref" href="../mvc/views/overview.html">视图</a>提供本地化字符串。 <code>ViewLocalizer</code> 类可实现此接口，并从视图文件路径找到资源位置。 下面的代码演示如何使用 <code>IViewLocalizer</code> 的默认实现：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>IViewLocalizer</code> 的默认实现可根据视图的文件名查找资源文件。 没有使用全局共享资源文件的选项。 <code>ViewLocalizer</code> 使用 <code>IHtmlLocalizer</code> 实现本地化工具，因此 Razor 不会对本地化字符串进行 HTML 编码。 你可以参数化资源字符串，<code>IViewLocalizer</code> 将对参数进行 HTML 编码，但不会对资源字符串进行。 请考虑以下 Razor 标记：</p>
<pre><code class="lang-cshtml">@Localizer[&quot;&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;&quot;, UserManager.GetUserName(User)]
</code></pre>
<p>法语资源文件可以包含以下信息：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>“值”</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;i&gt;Hello&lt;/i&gt; &lt;b&gt;{0}!&lt;/b&gt;</code></td>
<td><code>&lt;i&gt;Bonjour&lt;/i&gt; &lt;b&gt;{0} !&lt;/b&gt;</code></td>
</tr>
</tbody>
</table>
<p>呈现的视图可能包含资源文件中的 HTML 标记。</p>
<div class="NOTE">
<h5>Note</h5>
<p>通常，仅本地化文本，而不是 HTML。</p>
</div>
<p>若要在视图中使用共享资源文件，请注入 <code>IHtmlLocalizer&lt;T&gt;</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="dataannotations-localization">DataAnnotations 本地化</h2>
<p>DataAnnotations 错误消息已使用 <code>IStringLocalizer&lt;T&gt;</code> 本地化。 使用选项 <code>ResourcesPath = &quot;Resources&quot;</code>，<code>RegisterViewModel</code> 中的错误消息可以存储在以下路径之一：</p>
<ul>
<li><em>Resources/ViewModels.Account.RegisterViewModel.fr.resx</em></li>
<li><em>Resources/ViewModels/Account/RegisterViewModel.fr.resx</em></li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在 ASP.NET Core MVC 1.1.0 和更高版本中，非验证属性已经进行了本地化。 ASP.NET Core MVC 1.0 不会为非验证属性查找本地化字符串。</p>
<p><a name="one-resource-string-multiple-classes"></a></p>
<h3 id="using-one-resource-string-for-multiple-classes">对多个类使用一个资源字符串</h3>
<p>下面的代码演示如何针对具有多个类的验证属性使用一个资源字符串：</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc()
        .AddDataAnnotationsLocalization(options =&gt; {
            options.DataAnnotationLocalizerProvider = (type, factory) =&gt;
                factory.Create(typeof(SharedResource));
        });
}
</code></pre>
<p>在上面的代码中，<code>SharedResource</code> 是对应于存储验证消息的 resx 的类。 使用此方法，DataAnnotations 将仅使用 <code>SharedResource</code>，而不是每个类的资源。</p>
<h2 id="provide-localized-resources-for-the-languages-and-cultures-you-support">为支持的语言和区域性提供本地化资源</h2>
<h3 id="supportedcultures-and-supporteduicultures">SupportedCultures 和 SupportedUICultures</h3>
<p>ASP.NET Core 允许指定两个区域性值，<code>SupportedCultures</code> 和 <code>SupportedUICultures</code>。 <code>SupportedCultures</code> 的 <a href="/dotnet/api/system.globalization.cultureinfo">CultureInfo</a> 对象可决定区域性相关函数的结果，如日期、时间、数字和货币格式等。 <code>SupportedCultures</code> 确定文本的排序顺序、大小写约定和字符串比较。 请参阅 <a href="/dotnet/api/system.stringcomparer.currentculture#System_StringComparer_CurrentCulture">CultureInfo.CurrentCulture</a> 详细了解服务器如何获取区域性。 <code>SupportedUICultures</code> 可确定按 <a href="/dotnet/api/system.resources.resourcemanager">ResourceManager</a> 来查找哪些转换字符串（位于 .resx 文件）。 <code>ResourceManager</code> 只需查找 <code>CurrentUICulture</code> 决定的区域性特定字符串。 .NET 中的每个线程都具有 <code>CurrentCulture</code> 和 <code>CurrentUICulture</code> 对象。 呈现区域性相关函数时，ASP.NET Core 可检查这些值。 例如，如果当前线程的区域性设置为“en-US”（英语，美国），<code>DateTime.Now.ToLongDateString()</code> 将显示“Thursday, February 18, 2016”，但如果 <code>CurrentCulture</code> 设置为“es-ES”（西班牙语，西班牙），则输出将为“jueves，18 de febrero de 2016”。</p>
<h2 id="resource-files">资源文件</h2>
<p>资源文件是将可本地化的字符串与代码分离的有用机制。 非默认语言的转换字符串在 .resx 资源文件中单独显示。 例如，你可能想要创建包含转换字符串、名为 Welcome.es.resx 的西班牙语资源文件。 “es”是西班牙语的语言代码。 要在 Visual Studio 中创建此资源文件，请支持以下操作：</p>
<ol>
<li><p>在“解决方案资源管理器”中，右键单击将包含资源文件的文件夹 &gt;“添加”&gt;“新项”  。</p>
<p><img src="localization/_static/newi.png" alt="嵌套的上下文菜单：在“解决方案资源管理器”中，“资源”可打开上下文菜单。 “添加”可打开第二个上下文菜单，突出显示“新项”命令。"></p>
</li>
<li><p>在“搜索已安装的模板”框中，输入“资源”并命名该文件。</p>
<p><img src="localization/_static/res.png" alt="“添加新项”对话框"></p>
</li>
<li><p>在“名称”列中输入键值（本机字符串），在“值”列中输入转换字符串 。</p>
<p><img src="localization/_static/hola.png" alt="Welcome.es.resx 文件（西班牙语版 Welcome 资源文件）的单词 Hello 位于“名称”列，Hola（西班牙语版 Hello）位于“值”列"></p>
<p>Visual Studio 将显示 Welcome.es.resx 文件。</p>
<p><img src="localization/_static/se.png" alt="显示 Welcome Spanish (es) 资源文件的解决方案资源管理器"></p>
</li>
</ol>
<h2 id="resource-file-naming">资源文件命名</h2>
<p>资源名称是类的完整类型名称减去程序集名称。 例如，类 <code>LocalizationWebsite.Web.Startup</code> 的主要程序集为 <code>LocalizationWebsite.Web.dll</code> 的项目中的法语资源将命名为 Startup.fr.resx。 类 <code>LocalizationWebsite.Web.Controllers.HomeController</code> 的资源将命名为 Controllers.HomeController.fr.resx。 如果目标类的命名空间与将需要完整类型名称的程序集名称不同。 例如，在示例项目中，类型 <code>ExtraNamespace.Tools</code> 的资源将命名为 ExtraNamespace.Tools.fr.resx。</p>
<p>在示例项目中，<code>ConfigureServices</code> 方法将 <code>ResourcesPath</code> 设置为“资源”，因此主控制器的法语资源文件的项目相对路径是 Resources/Controllers.HomeController.fr.resx。 或者，你可以使用文件夹组织资源文件。 对于主控制器，该路径将为 Resources/Controllers/HomeController.fr.resx。 如果不使用 <code>ResourcesPath</code> 选项，.resx 文件将转到项目的基目录中。 <code>HomeController</code> 的资源文件将命名为 Controllers.HomeController.fr.resx。 是选择使用圆点还是路径命名约定，具体取决于你想如何组织资源文件。</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>圆点或路径命名</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resources/Controllers.HomeController.fr.resx</td>
<td>圆点</td>
</tr>
<tr>
<td>Resources/Controllers/HomeController.fr.resx</td>
<td>路径</td>
</tr>
</tbody>
</table>
<p>Razor 视图中使用 <code>@inject IViewLocalizer</code> 的资源文件遵循类似的模式。 可以使用圆点命名或路径命名约定对视图的资源文件进行命名。 Razor 视图资源文件可模拟其关联视图文件的路径。 假设我们将 <code>ResourcesPath</code> 设置为“Resources”，与 <em>Views/Home/About.cshtml</em> 视图关联的法语资源文件可能是下面其中之一 ：</p>
<ul>
<li><p>Resources/Views/Home/About.fr.resx</p>
</li>
<li><p>Resources/Views.Home.About.fr.resx</p>
</li>
</ul>
<p>如果不使用 <code>ResourcesPath</code> 选项，视图的 .resx 文件将位于视图所在的文件夹。</p>
<h3 id="rootnamespaceattribute">RootNamespaceAttribute</h3>
<p><a href="/dotnet/api/microsoft.extensions.localization.rootnamespaceattribute?view=aspnetcore-2.1">RootNamespace</a> 属性在程序集的根命名空间不同于程序集名称时，提供程序集的根命名空间。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>当项目名称不是有效的 .NET 标识符时，可能会发生这种情况。 例如，<code>my-project-name.csproj</code> 将使用根命名空间 <code>my_project_name</code> 和导致此错误的程序集名称 <code>my-project-name</code>。</p>
</div>
<p>如果程序集的根命名空间不同于程序集名称：</p>
<ul>
<li>默认情况下无法进行本地化。</li>
<li>因程序集内搜索资源的方式导致本地化失败。 <code>RootNamespace</code> 是生成时间值，不可用于正在执行的进程。</li>
</ul>
<p>如果 <code>RootNamespace</code> 不同于 <code>AssemblyName</code>，请在 AssemblyInfo.cs 中包括以下内容（参数值替换为实际值）：</p>
<pre><code class="lang-csharp">using System.Reflection;
using Microsoft.Extensions.Localization;

[assembly: ResourceLocation(&quot;Resource Folder Name&quot;)]
[assembly: RootNamespace(&quot;App Root Namespace&quot;)]
</code></pre>
<p>上述代码可成功解析 resx 文件。</p>
<h2 id="culture-fallback-behavior">区域性回退行为</h2>
<p>在搜索资源时，本地化会进行“区域性回退”。 从所请求的区域性开始，如果未能找到，则还原至该区域性的父区域性。 另外，<a href="/dotnet/api/system.globalization.cultureinfo.parent">CultureInfo.Parent</a> 属性代表父区域性。 这通常（但并不是总是）意味着从 ISO 中移除区域签名。 例如，墨西哥的西班牙语方言为“es-MX”。 它具备一个父级“es”西班牙，没有特别指定国家/地区。</p>
<p>假设你的站点接收到了一个区域性为“fr-CA”的“Welcome”资源的请求。 本地化系统按顺序查找以下资源，并选择第一个匹配项：</p>
<ul>
<li><em>Welcome.fr-CA.resx</em></li>
<li><em>Welcome.fr.resx</em></li>
<li><em>Welcome.resx</em>（如果 <code>NeutralResourcesLanguage</code> 为“fr-CA”）</li>
</ul>
<p>例如，如果删除了“.fr”区域性指示符，而且已将区域性设置为“法语”，将读取默认资源文件，并本地化字符串。 对于不满足所请求区域性的情况，资源管理器可指定默认资源或回退资源。 缺少适用于请求区域性的资源时，如果只想返回键，不得具有默认资源文件。</p>
<h3 id="generate-resource-files-with-visual-studio">使用 Visual Studio 生成资源文件</h3>
<p>如果在 Visual Studio 中创建文件名没有区域性的资源文件（例如 Welcome.resx），Visual Studio 将创建一个 C# 类，并且具有每个字符串的属性。 这通常不是你想在 ASP.NET Core 中使用的。 你通常没有默认的 .resx 资源文件（没有区域性名称的 .resx 文件） 。 建议创建具有区域性名称（例如 Welcome.fr.resx）的 .resx 文件 。 创建具有区域性名称的 .resx 文件时，Visual Studio 不会生成类文件。</p>
<h3 id="add-other-cultures">添加其他区域性</h3>
<p>每个语言和区域性组合（除默认语言外）都需要唯一资源文件。 通过新建 ISO 语言代码属于名称一部分的资源文件，为不同的区域性和区域设置创建资源文件（例如，en-us、fr-ca 和 en-gb）  。 这些 ISO 编码位于文件名和 .resx 文件扩展之间，如 Welcome.es-MX.resx（西班牙语/墨西哥） 。</p>
<h2 id="implement-a-strategy-to-select-the-languageculture-for-each-request">实施策略，为每个请求选择语言/区域性</h2>
<h3 id="configure-localization">配置本地化</h3>
<p>通过 <code>Startup.ConfigureServices</code> 方法配置本地化：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<ul>
<li><p><code>AddLocalization</code> 将本地化服务添加到服务容器。 上面的代码还将资源路径设置为“Resources”。</p>
</li>
<li><p><code>AddViewLocalization</code> 添加对本地化视图文件的支持。 在此示例视图中，本地化基于视图文件后缀。 例如，Index.fr.cshtml 文件中的“fr”。</p>
</li>
<li><p><code>AddDataAnnotationsLocalization</code> 添加通过 <code>IStringLocalizer</code> 抽象对本地化 <code>DataAnnotations</code> 验证消息的支持。</p>
</li>
</ul>
<h3 id="localization-middleware">本地化中间件</h3>
<p>在本地化<a class="xref" href="middleware/index.html">中间件</a>中设置有关请求的当前区域性。 在 <code>Startup.Configure</code> 方法中启用本地化中间件。 必须在中间件前面配置本地化中间件，它可能检查请求区域性（例如，<code>app.UseMvcWithDefaultRoute()</code>）。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><p>若要查看翻译为非英语语言的代码注释，请在 <a href="https://github.com/MicrosoftDocs/feedback/issues/2515">此 GitHub 讨论问题</a>中告诉我们。</p>

<p><code>UseRequestLocalization</code> 初始化 <code>RequestLocalizationOptions</code> 对象。 在每个请求上，枚举了 <code>RequestLocalizationOptions</code> 的 <code>RequestCultureProvider</code> 列表，使用了可成功决定请求区域性的第一个提供程序。 默认提供程序来自 <code>RequestLocalizationOptions</code> 类：</p>
<ol>
<li><code>QueryStringRequestCultureProvider</code></li>
<li><code>CookieRequestCultureProvider</code></li>
<li><code>AcceptLanguageHeaderRequestCultureProvider</code></li>
</ol>
<p>默认列表从最具体到最不具体排序。 在本文的后面部分，我们将了解如何更改顺序，甚至添加一个自定义区域性提供程序。 如果没有一个提供程序可以确定请求区域性，则使用 <code>DefaultRequestCulture</code>。</p>
<h3 id="querystringrequestcultureprovider">QueryStringRequestCultureProvider</h3>
<p>某些应用将使用查询字符串来设置&lt;xref:System.Globalization.CultureInfo&gt;。 对于使用 cookie 或接受语言标题方法的应用，向 URL 添加查询字符串有助于调试和测试代码。 默认情况下，<code>QueryStringRequestCultureProvider</code> 注册为 <code>RequestCultureProvider</code> 列表中的第一个本地化提供程序。 传递查询字符串参数 <code>culture</code> 和 <code>ui-culture</code>。 下面的示例将特定区域性（语言和区域）设置为“西班牙语/墨西哥”：</p>
<pre><code>http://localhost:5000/?culture=es-MX&amp;ui-culture=es-MX
</code></pre>
<p>如果仅传入两种区域性之一（<code>culture</code> 或 <code>ui-culture</code>，查询字符串提供程序将使用你传入的区域性设置这两个值。 例如，仅设置区域性将同时设置 <code>Culture</code> 和 <code>UICulture</code>：</p>
<pre><code>http://localhost:5000/?culture=es-MX
</code></pre>
<h3 id="no-loccookierequestcultureprovider">CookieRequestCultureProvider</h3>
<p>通常，生产应用将提供一种机制来使用 ASP.NET Core 区域性 cookie 设置区域性。 若要创建 cookie，请使用 <code>MakeCookieValue</code> 方法。</p>
<p><code>CookieRequestCultureProvider</code> <code>DefaultCookieName</code> 将返回用来跟踪用户首选区域性信息的默认 cookie 名称。 默认的 cookie 名称为 <code>.AspNetCore.Culture</code>。</p>
<p>cookie 格式为 <code>c=%LANGCODE%|uic=%LANGCODE%</code>，其中 <code>c</code> 是 <code>Culture</code>，<code>uic</code> 是 <code>UICulture</code>，例如：</p>
<pre><code>c=en-UK|uic=en-US
</code></pre>
<p>如果仅指定其中一个区域性信息和 UI 区域性，则指定的区域性将同时用于区域性信息和 UI 区域性。</p>
<h3 id="the-accept-language-http-header">接受语言 HTTP 标题</h3>
<p><a href="https://www.w3.org/International/questions/qa-accept-lang-locales">接受语言标题</a>在大多数浏览器中可设置，最初用于指定用户的语言。 此设置指示浏览器已设置为发送或已从基础操作系统继承的内容。 浏览器请求的接受语言 HTTP 标题不是检测用户首选语言的可靠方法（请参阅 <a href="https://www.w3.org/International/questions/qa-lang-priorities.en.php">Setting language preferences in a browser</a>（在浏览器中设置首选项）。 生产应用应包括一种用户可以自定义区域性选择的方法。</p>
<h3 id="set-the-accept-language-http-header-in-ie">在 IE 中设置接受语言 HTTP 标题</h3>
<ol>
<li><p>在齿轮图标中，点击“Internet 选项”。</p>
</li>
<li><p>点击“语言”。</p>
<p><img src="localization/_static/lang.png" alt="Internet 选项"></p>
</li>
<li><p>点击“设置语言首选项”。</p>
</li>
<li><p>点击“添加语言”。</p>
</li>
<li><p>添加语言。</p>
</li>
<li><p>点击语言，然后点击“向上移动”。</p>
</li>
</ol>
<h3 id="the-content-language-http-header">Content-Language HTTP 标头</h3>
<p><a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Language">Content-Language</a> 实体标头：</p>
<ul>
<li>用于描述面向受众的语言。</li>
<li>允许用户根据用户的首选语言来区分。</li>
</ul>
<p>实体标头用于 HTTP 请求和响应。</p>
<p>可通过设置属性 <code>ApplyCurrentCultureToResponseHeaders</code> 来添加 <code>Content-Language</code> 标头。</p>
<p>添加 <code>Content-Language</code> 标头：</p>
<ul>
<li>允许 RequestLocalizationMiddleware 使用 <code>CurrentUICulture</code> 设置 <code>Content-Language</code> 标头。</li>
<li>无需显式设置响应标头 <code>Content-Language</code>。</li>
</ul>
<pre><code class="lang-csharp">app.UseRequestLocalization(new RequestLocalizationOptions
{
    ApplyCurrentCultureToResponseHeaders = true
});
</code></pre>
<h3 id="use-a-custom-provider">使用自定义提供程序</h3>
<p>假设你想要让客户在数据库中存储其语言和区域性。 你可以编写一个提供程序来查找用户的这些值。 下面的代码演示如何添加自定义提供程序：</p>
<pre><code class="lang-csharp">private const string enUSCulture = &quot;en-US&quot;;

services.Configure&lt;RequestLocalizationOptions&gt;(options =&gt;
{
    var supportedCultures = new[]
    {
        new CultureInfo(enUSCulture),
        new CultureInfo(&quot;fr&quot;)
    };

    options.DefaultRequestCulture = new RequestCulture(culture: enUSCulture, uiCulture: enUSCulture);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;

    options.AddInitialRequestCultureProvider(new CustomRequestCultureProvider(async context =&gt;
    {
        // My custom request culture logic
        return new ProviderCultureResult(&quot;en&quot;);
    }));
});
</code></pre>
<p>使用 <code>RequestLocalizationOptions</code> 添加或删除本地化提供程序。</p>
<h3 id="set-the-culture-programmatically">以编程方式设置区域性</h3>
<p><a href="https://github.com/aspnet/entropy">GitHub</a> 上的示例项目 Localization.StarterWeb 包含设置 <code>Culture</code> 的 UI。 Views/Shared/_SelectLanguagePartial.cshtml 文件允许你从支持的区域性列表中选择区域性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Views/Shared/_SelectLanguagePartial.cshtml 文件添加到了布局文件的 <code>footer</code> 部分，使它将可供所有视图使用：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>SetLanguage</code> 方法可设置区域性 cookie。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>不能将 _SelectLanguagePartial.cshtml 插入此项目的示例代码。 <a href="https://github.com/aspnet/entropy">GitHub</a> 上的 Localization.StarterWeb 项目包含的代码可通过<a href="dependency-injection.html">依赖项注入</a>容器将 <code>RequestLocalizationOptions</code> 流到 Razor 部分。</p>
<h2 id="model-binding-route-data-and-query-strings">模型绑定路由数据和查询字符串</h2>
<p>请参阅<a class="xref" href="../mvc/models/model-binding.html#glob">模型绑定路由数据和查询字符串的全球化行为</a>。</p>
<h2 id="globalization-and-localization-terms">全球化和本地化术语</h2>
<p>本地化应用的过程还要求基本了解现代软件开发中常用的相关字符集，以及与之相关的问题。 尽管所有计算机将文本都存储为数字（代码），但不同的系统使用不同的数字存储相同的文本。 本地化过程是指针对特定区域性/区域设置转换应用的用户界面 (UI)。</p>
<p><a href="/dotnet/standard/globalization-localization/localizability-review">本地化性</a>是一个中间过程，用于验证全球化应用是否准备好进行本地化。</p>
<p>区域性名称的 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 格式为 <code>&lt;languagecode2&gt;-&lt;country/regioncode2&gt;</code>，其中 <code>&lt;languagecode2&gt;</code> 是语言代码，<code>&lt;country/regioncode2&gt;</code> 是子区域性代码。 例如，<code>es-CL</code> 表示西班牙语（智利），<code>en-US</code> 表示英语（美国），而 <code>en-AU</code> 表示英语（澳大利亚）。 <a href="https://www.ietf.org/rfc/rfc4646.txt">RFC 4646</a> 是一个与语言相关的 ISO 639 双小写字母的区域性代码和一个与国家/地区相关的 ISO 3166 双大写字母子区域性代码的组合。 请参阅 <a href="https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)">https://docs.microsoft.com/previous-versions/commerce-server/ee825488(v=cs.20)</a>。</p>
<p>国际化常缩写为“I18N”。 缩写采用第一个和最后一个字母以及它们之间的字母数，因此 18 代表第一个字母“I”和最后一个“N”之间的字母数。 这同样适用于全球化 (G11N) 和本地化 (L10N)。</p>
<p>术语：</p>
<ul>
<li>全球化 (G11N)：使应用支持不同语言和区域的过程。</li>
<li>本地化 (L10N)：针对给定语言和区域自定义应用的过程。</li>
<li>国际化 (I18N)：介绍了全球化和本地化。</li>
<li>区域性：它是一种语言和区域（可选）。</li>
<li>非特定区域性：具有指定语言但不具有区域的区域性。 （例如，“en”，“es”）</li>
<li>特定区域性：具有指定语言和区域的区域性。 （例如，“en-US”，“en-GB”，“es-CL”）</li>
<li>父区域性：包含特定区域性的非特定区域性。 （例如，“en”是“en-US”和“en-GB”的父区域性）</li>
<li>区域设置：区域设置与区域性相同。</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>可能无法在小数字段中输入十进制逗号。 若要使 <a href="https://jqueryvalidation.org/">jQuery 验证</a>支持使用逗号（“,”）表示小数点的的非英语区域设置，以及支持非美国英语日期格式，必须执行使应用全球化的步骤。 有关添加十进制逗号的说明，<a href="https://github.com/dotnet/AspNetCore.Docs/issues/4076#issuecomment-326590420">请参阅 GitHub 问题 4076</a>。</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>在 ASP.NET Core 3.0 之前，如果请求的区域性不受支持，Web 应用将写入每个请求的一个类型为 <code>LogLevel.Warning</code> 的日志。 记录每个请求的一个 <code>LogLevel.Warning</code> 可以生成包含冗余信息的大型日志文件。 此行为已在 ASP.NET 3.0 中进行了更改。 <code>RequestLocalizationMiddleware</code> 写入类型为 <code>LogLevel.Debug</code> 的日志，这会减小生产日志的大小。</p>
</div>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="troubleshoot-aspnet-core-localization.html">对 ASP.NET Core 本地化进行故障排除</a></li>
<li>本文所用的 <a href="https://github.com/aspnet/Entropy/tree/master/samples/Localization.StarterWeb">Localization.StarterWeb 项目</a>。</li>
<li><a href="/dotnet/standard/globalization-localization/index">对 .NET 应用程序进行全球化和本地化</a></li>
<li><a href="/dotnet/framework/resources/working-with-resx-files-programmatically">.resx 文件中的资源</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=MultilingualAppToolkit.MultilingualAppToolkit-18308">Microsoft 多语言应用工具包</a></li>
<li><a href="http://hishambinateya.com/localization-and-generics">本地化与泛型</a></li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
