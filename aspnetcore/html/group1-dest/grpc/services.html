<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#21019;&#24314; gRPC &#26381;&#21153;&#21644;&#26041;&#27861; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#21019;&#24314; gRPC &#26381;&#21153;&#21644;&#26041;&#27861; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="grpc/services">
<h1 id="create-grpc-services-and-methods">创建 gRPC 服务和方法</h1>

<p>作者：<a href="https://twitter.com/jamesnk">James Newton-King</a></p>
<p>本文档介绍如何以 C# 创建 gRPC 服务和方法。 主题包括：</p>
<ul>
<li>如何在 .proto 文件中定义服务和方法。</li>
<li>使用 gRPC C# 工具生成的代码。</li>
<li>实现 gRPC 服务和方法。</li>
</ul>
<h2 id="create-new-grpc-services">创建新的 gRPC 服务</h2>
<p><a class="xref" href="basics.html">使用 C# 的 gRPC 服务</a>介绍了 gRPC 的 API 开发协定优先方法。 在 .proto 文件中定义服务和消息。 然后，C# 工具从 .proto 文件生成代码。 对于服务器端资产，将为每个服务生成一个抽象基类型，同时为所有消息生成类。</p>
<p>以下 .proto 文件：</p>
<ul>
<li>定义 <code>Greeter</code> 服务。</li>
<li><code>Greeter</code> 服务定义 <code>SayHello</code> 调用。</li>
<li><code>SayHello</code> 发送 <code>HelloRequest</code> 消息并接收 <code>HelloReply</code> 消息</li>
</ul>
<pre><code class="lang-protobuf">syntax = &quot;proto3&quot;;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
</code></pre>
<p>C# 工具生成 C# <code>GreeterBase</code> 基类型：</p>
<pre><code class="lang-csharp">public abstract partial class GreeterBase
{
    public virtual Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)
    {
        throw new RpcException(new Status(StatusCode.Unimplemented, &quot;&quot;));
    }
}

public class HelloRequest
{
    public string Name { get; set; }
}

public class HelloReply
{
    public string Message { get; set; }
}
</code></pre>
<p>默认情况下，生成的 <code>GreeterBase</code> 不执行任何操作。 它的虚拟 <code>SayHello</code> 方法会将 <code>UNIMPLEMENTED</code> 错误返回到调用它的任何客户端。 为了使服务有用，应用必须创建 <code>GreeterBase</code> 的具体实现：</p>
<pre><code class="lang-csharp">public class GreeterService : GreeterBase
{
    public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)
    {
        return Task.FromResult(new HelloRequest { Message = $&quot;Hello {request.Name}&quot; });
    }
}
</code></pre>
<p>服务实现已注册到应用。 如果服务由 ASP.NET Core gRPC 托管，则应使用 <code>MapGrpcService</code> 方法将其添加到路由管道。</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapGrpcService&lt;GreeterService&gt;();
});
</code></pre>
<p>有关更多信息，请参见 <a class="xref" href="aspnetcore.html">使用 ASP.NET Core 的 gRPC 服务</a> 。</p>
<h2 id="implement-grpc-methods">实现 gRPC 方法</h2>
<p>gRPC 服务可以有不同类型的方法。 服务发送和接收消息的方式取决于所定义的方法的类型。 gRPC 方法类型如下：</p>
<ul>
<li>一元</li>
<li>服务器流式处理</li>
<li>客户端流式处理</li>
<li>双向流式处理</li>
</ul>
<p>流式处理调用是使用 <code>stream</code> 关键字在 .proto 文件中指定的。 <code>stream</code> 可以放置在调用的请求消息和/或响应消息中。</p>
<pre><code class="lang-protobuf">syntax = &quot;proto3&quot;;

service ExampleService {
  // Unary
  rpc UnaryCall (ExampleRequest) returns (ExampleResponse);

  // Server streaming
  rpc StreamingFromServer (ExampleRequest) returns (stream ExampleResponse);

  // Client streaming
  rpc StreamingFromClient (stream ExampleRequest) returns (ExampleResponse);

  // Bi-directional streaming
  rpc StreamingBothWays (stream ExampleRequest) returns (stream ExampleResponse);
}
</code></pre>
<p>每个调用类型都有不同的方法签名。 在具体实现中替代从抽象基本服务类型生成的方法，可确保使用正确的参数和返回类型。</p>
<h3 id="unary-method">一元方法</h3>
<p>一元方法以参数的形式获取请求消息，并返回响应。 返回响应时，一元调用完成。</p>
<pre><code class="lang-csharp">public override Task&lt;ExampleResponse&gt; UnaryCall(ExampleRequest request,
    ServerCallContext context)
{
    var response = new ExampleResponse();
    return Task.FromResult(response);
}
</code></pre>
<p>一元调用与 <a class="xref" href="../web-api/index.html">Web API 控制器上的操作</a>最为相似。 gRPC 方法与操作的一个重要区别是，gRPC 方法无法将请求的某些部分绑定到不同的方法参数。 对于传入请求数据，gRPC 方法始终有一个消息参数。 通过在请求消息中设置多个值字段，仍可以将多个值发送到 gRPC 服务：</p>
<pre><code class="lang-protobuf">message ExampleRequest {
    int pageIndex = 1;
    int pageSize = 2;
    bool isDescending = 3;
}
</code></pre>
<h3 id="server-streaming-method">服务器流式处理方法</h3>
<p>服务器流式处理方法以参数的形式获取请求消息。 由于可以将多个消息流式传输回调用方，因此可使用 <code>responseStream.WriteAsync</code> 发送响应消息。 当方法返回时，服务器流式处理调用完成。</p>
<pre><code class="lang-csharp">public override async Task StreamingFromServer(ExampleRequest request,
    IServerStreamWriter&lt;ExampleResponse&gt; responseStream, ServerCallContext context)
{
    for (var i = 0; i &lt; 5; i++)
    {
        await responseStream.WriteAsync(new ExampleResponse());
        await Task.Delay(TimeSpan.FromSeconds(1));
    }
}
</code></pre>
<p>服务器流式处理方法启动后，客户端无法发送其他消息或数据。 某些流式处理方法设计为永久运行。 对于连续流式处理方法，客户端可以在不再需要调用时将其取消。 当发生取消时，客户端会将信号发送到服务器，并引发 <a href="xref:System.Threading.CancellationToken">ServerCallContext.CancellationToken</a>。 应在服务器上通过异步方法使用 <code>CancellationToken</code> 标记，以实现以下目的：</p>
<ul>
<li>所有异步工作都与流式处理调用一起取消。</li>
<li>该方法快速退出。</li>
</ul>
<pre><code class="lang-csharp">public override async Task StreamingFromServer(ExampleRequest request,
    IServerStreamWriter&lt;ExampleResponse&gt; responseStream, ServerCallContext context)
{
    while (!context.CancellationToken.IsCancellationRequested)
    {
        await responseStream.WriteAsync(new ExampleResponse());
        await Task.Delay(TimeSpan.FromSeconds(1), context.CancellationToken);
    }
}
</code></pre>
<h3 id="client-streaming-method">客户端流式处理方法</h3>
<p>客户端流式处理方法在该方法没有接收消息的情况下启动。 <code>requestStream</code> 参数用于从客户端读取消息。 返回响应消息时，客户端流式处理调用完成：</p>
<pre><code class="lang-csharp">public override async Task&lt;ExampleResponse&gt; StreamingFromClient(
    IAsyncStreamReader&lt;ExampleRequest&gt; requestStream, ServerCallContext context)
{
    while (await requestStream.MoveNext())
    {
        var message = requestStream.Current;
        // ...
    }
    return new ExampleResponse();
}
</code></pre>
<p>如果使用 C# 8 或更高版本，则可使用 <code>await foreach</code> 语法来读取消息。 <code>IAsyncStreamReader&lt;T&gt;.ReadAllAsync()</code> 扩展方法读取请求数据流中的所有消息：</p>
<pre><code class="lang-csharp">public override async Task&lt;ExampleResponse&gt; StreamingFromClient(
    IAsyncStreamReader&lt;ExampleRequest&gt; requestStream, ServerCallContext context)
{
    await foreach (var message in requestStream.ReadAllAsync())
    {
        // ...
    }
    return new ExampleResponse();
}
</code></pre>
<h3 id="bi-directional-streaming-method">双向流式处理方法</h3>
<p>双向流式处理方法在该方法没有接收到消息的情况下启动。 <code>requestStream</code> 参数用于从客户端读取消息。 该方法可选择使用 <code>responseStream.WriteAsync</code> 发送消息。 当方法返回时，双向流式处理调用完成：</p>
<pre><code class="lang-csharp">public override async Task StreamingBothWays(IAsyncStreamReader&lt;ExampleRequest&gt; requestStream,
    IServerStreamWriter&lt;ExampleResponse&gt; responseStream, ServerCallContext context)
{
    await foreach (var message in requestStream.ReadAllAsync())
    {
        await responseStream.WriteAsync(new ExampleResponse());
    }
}
</code></pre>
<p>前面的代码：</p>
<ul>
<li>发送每个请求的响应。</li>
<li>是双向流式处理的基本用法。</li>
</ul>
<p>可以支持更复杂的方案，例如同时读取请求和发送响应：</p>
<pre><code class="lang-csharp">public override async Task StreamingBothWays(IAsyncStreamReader&lt;ExampleRequest&gt; requestStream,
    IServerStreamWriter&lt;ExampleResponse&gt; responseStream, ServerCallContext context)
{
    // Read requests in a background task.
    var readTask = Task.Run(async () =&gt;
    {
        await foreach (var message in requestStream.ReadAllAsync())
        {
            // Process request.
        }
    });
    
    // Send responses until the client signals that it is complete.
    while (!readTask.IsCompleted)
    {
        await responseStream.WriteAsync(new ExampleResponse());
        await Task.Delay(TimeSpan.FromSeconds(1), context.CancellationToken);
    }
}
</code></pre>
<p>在双向流式处理方法中，客户端和服务可在任何时间互相发送消息。 双向方法的最佳实现根据需求而有所不同。</p>
<h2 id="access-grpc-request-headers">访问 gRPC 请求标头</h2>
<p>请求消息并不是客户端将数据发送到 gRPC 服务的唯一方法。 标头值在使用 <code>ServerCallContext.RequestHeaders</code> 的服务中可用。</p>
<pre><code class="lang-csharp">public override Task&lt;ExampleResponse&gt; UnaryCall(ExampleRequest request, ServerCallContext context)
{
    var userAgent = context.RequestHeaders.GetValue(&quot;user-agent&quot;);
    // ...

    return Task.FromResult(new ExampleResponse());
}
</code></pre>
<h2 id="additional-resources">其他资源</h2>
<ul>
<li><a class="xref" href="basics.html">使用 C# 的 gRPC 服务</a></li>
<li><a class="xref" href="client.html">使用 .NET 客户端调用 gRPC 服务</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
