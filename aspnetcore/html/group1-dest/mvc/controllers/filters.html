<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ASP.NET Core &#20013;&#30340;&#31579;&#36873;&#22120; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ASP.NET Core &#20013;&#30340;&#31579;&#36873;&#22120; ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="mvc/controllers/filters">
<h1 id="filters-in-aspnet-core">ASP.NET Core 中的筛选器</h1>

<div range="&gt;= aspnetcore-3.0">
<p>作者：<a href="https://github.com/serpent5">Kirk Larkin</a>、<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://github.com/tdykstra/">Tom Dykstra</a> 和 <a href="https://ardalis.com/">Steve Smith</a></p>
<p>通过使用 ASP.NET Core 中的筛选器，可在请求处理管道中的特定阶段之前或之后运行代码。</p>
<p>内置筛选器处理任务，例如：</p>
<ul>
<li>授权（防止用户访问未获授权的资源）。</li>
<li>响应缓存（对请求管道进行短路出路，以便返回缓存的响应）。</li>
</ul>
<p>可以创建自定义筛选器，用于处理横切关注点。 横切关注点的示例包括错误处理、缓存、配置、授权和日志记录。  筛选器可以避免复制代码。 例如，错误处理异常筛选器可以合并错误处理。</p>
<p>本文档适用于 Razor 具有视图的页面、API 控制器和控制器。 筛选器不直接与<a class="xref" href="../../blazor/components/index.html"> Razor 组件</a>一起使用。 筛选器只能在以下情况下间接影响组件：</p>
<ul>
<li>该组件嵌入在页面或视图中。</li>
<li>页面或控制器/视图使用此筛选器。</li>
</ul>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/3.1sample">查看或下载示例</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）。</p>
<h2 id="how-filters-work">筛选器的工作原理</h2>
<p>筛选器在 ASP.NET Core 操作调用管道  （有时称为筛选器管道  ）内运行。 筛选器管道在 ASP.NET Core 选择了要执行的操作之后运行。</p>
<p><img src="filters/_static/filter-pipeline-1.png" alt="请求通过其他中间件、路由中间件、操作选择和操作调用管道进行处理。 请求处理继续往回通过操作选择、路由中间件和各种其他中间件，变成发送到客户端的响应。"></p>
<h3 id="filter-types">筛选器类型</h3>
<p>每种筛选器类型都在筛选器管道中的不同阶段执行：</p>
<ul>
<li><p><a href="#authorization-filters">授权筛选器</a>最先运行，用于确定是否已针对请求为用户授权。 如果请求未获授权，授权筛选器可以让管道短路。</p>
</li>
<li><p><a href="#resource-filters">资源筛选器</a>：</p>
<ul>
<li>授权后运行。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter.OnResourceExecuting*&gt; 在筛选器管道的其余阶段之前运行代码。 例如，<code>OnResourceExecuting</code> 在模型绑定之前运行代码。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter.OnResourceExecuted*&gt; 在管道的其余阶段完成之后运行代码。</li>
</ul>
</li>
<li><p><a href="#action-filters">操作筛选器</a>：</p>
<ul>
<li>在调用操作方法之前和之后立即运行代码。</li>
<li>可以更改传递到操作中的参数。</li>
<li>可以更改从操作返回的结果。</li>
<li>页面 <strong>不</strong> 支持 Razor 。</li>
</ul>
</li>
<li><p><a href="#exception-filters">异常筛选器</a>在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。</p>
</li>
<li><p><a href="#result-filters">结果筛选器</a>在执行操作结果之前和之后立即运行代码。 仅当操作方法成功执行时，它们才会运行。 对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。</p>
</li>
</ul>
<p>下图展示了筛选器类型在筛选器管道中的交互方式。</p>
<p><img src="filters/_static/filter-pipeline-2.png" alt="请求通过授权过滤器、资源过滤器、模型绑定、操作过滤器、操作执行和操作结果转换、异常过滤器、结果过滤器和结果执行进行处理。 返回时，请求仅由结果过滤器和资源过滤器进行处理，变成发送到客户端的响应。"></p>
<h2 id="implementation">实现</h2>
<p>筛选器通过不同的接口定义支持同步和异步实现。</p>
<p>同步筛选器在其管道阶段之前和之后运行代码。 例如，&lt;xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuting*&gt; 在调用操作方法之前调用。 &lt;xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuted*&gt; 在操作方法返回之后调用。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在上面的代码中， <a href="https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/mvc/controllers/filters/3.1sample/FiltersSample/Helper/MyDebug.cs">MyDebug</a> 是 <a href="https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/mvc/controllers/filters/3.1sample/FiltersSample/Helper/MyDebug.cs">示例下载</a>中的实用工具函数。</p>
<p>异步筛选器定义 <code>On-Stage-ExecutionAsync</code> 方法。 例如，&lt;xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecutionAsync*&gt;：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，<code>SampleAsyncActionFilter</code> 具有执行操作方法的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate&gt; (<code>next</code>)。</p>
<h3 id="multiple-filter-stages">多个筛选器阶段</h3>
<p>可以在单个类中实现多个筛选器阶段的接口。 例如，&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt; 类可实现：</p>
<ul>
<li>同步：&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IActionFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter&gt;</li>
<li>异步：&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncActionFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResultFilter&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IOrderedFilter&gt;</li>
</ul>
<p>筛选器接口的同步和异步版本任意实现一个，而不是同时实现 。 运行时会先查看筛选器是否实现了异步接口，如果是，则调用该接口。 如果不是，则调用同步接口的方法。 如果在一个类中同时实现异步和同步接口，则仅调用异步方法。 当使用抽象类（如 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt; ）时，仅重写每个筛选器类型的同步方法或异步方法。</p>
<h3 id="built-in-filter-attributes">内置筛选器属性</h3>
<p>ASP.NET Core 包含许多可子类化和自定义的基于属性的内置筛选器。 例如，以下结果筛选器会向响应添加标头：</p>
<p><a name="add-header-attribute"></a></p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>通过使用属性，筛选器可接收参数，如前面的示例所示。 将 <code>AddHeaderAttribute</code> 添加到控制器或操作方法，并指定 HTTP 标头的名称和值：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用 <a href="https://developer.mozilla.org/docs/Learn/Common_questions/What_are_browser_developer_tools">浏览器开发人员工具</a> 等工具来检查标头。 在响应标头下，将显示 <code>author: Rick Anderson</code>。</p>
<p>以下代码实现了 <code>ActionFilterAttribute</code>：</p>
<ul>
<li>从配置系统读取标题和名称。 与前面的示例不同，以下代码不需要将筛选器参数添加到代码中。</li>
<li>将标题和名称添加到响应标头。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用<a class="xref" href="../../fundamentals/configuration/options.html">选项模式</a>从<a class="xref" href="../../fundamentals/configuration/index.html">配置系统</a>中提供配置选项。 例如，从 <em>appsettings.json</em> 文件：</p>
<pre><code class="lang-json">{
    &quot;Position&quot;: {
        &quot;Title&quot;: &quot;编辑器&quot;,
        &quot;Name&quot;: &quot;Joe Smith&quot;
    },
    &quot;Logging&quot;: {
        &quot;LogLevel&quot;: {
            &quot;Default&quot;: &quot;Information&quot;,
            &quot;Microsoft&quot;: &quot;Warning&quot;,
            &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
        }
    },
    &quot;AllowedHosts&quot;: &quot;*&quot;
}
</code></pre>
<p>在 <code>StartUp.ConfigureServices</code> 中：</p>
<ul>
<li><code>PositionOptions</code> 类已通过 <code>&quot;Position&quot;</code> 配置区域添加到服务容器。</li>
<li><code>MyActionFilterAttribute</code> 已添加到服务容器。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码显示 <code>PositionOptions</code> 类：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码将 <code>MyActionFilterAttribute</code> 应用于 <code>Index2</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在 <strong>Response Headers</strong> <code>author: Rick Anderson</code> <code>Editor: Joe Smith</code> 调用终结点时，将显示 &quot;响应标头&quot;、和 <code>Sample/Index2</code> 。</p>
<p>下面的代码将 <code>MyActionFilterAttribute</code> 和应用于 <code>AddHeaderAttribute</code> Razor 页面：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>筛选器不能应用于 Razor 页面处理程序方法。 它们可以应用于 Razor 页面模型或全局应用。</p>
<p>多种筛选器接口具有相应属性，这些属性可用作自定义实现的基类。</p>
<p>筛选器属性：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ExceptionFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.FormatFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt;</li>
</ul>
<h2 id="filter-scopes-and-order-of-execution">筛选器作用域和执行顺序</h2>
<p>可以将筛选器添加到管道中的以下三个 <em>范围</em> 之一：</p>
<ul>
<li>在控制器操作上使用属性。 筛选器属性不能应用于 Razor 页面处理程序方法。</li>
<li>在控制器或页上使用特性 Razor 。</li>
<li>针对所有控制器、操作和页面全局 Razor 显示，如以下代码所示：</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="default-order-of-execution">默认执行顺序</h3>
<p>当管道的某个特定阶段有多个筛选器时，作用域可确定筛选器执行的默认顺序。  全局筛选器涵盖类筛选器，类筛选器又涵盖方法筛选器。</p>
<p>在筛选器嵌套模式下，筛选器的 after  代码会按照与 before  代码相反的顺序运行。 筛选器序列：</p>
<ul>
<li>全局筛选器的 before  代码。
<ul>
<li>控制器 <em>before</em> 和 Razor 页面筛选器的前代码。
<ul>
<li>操作方法筛选器的 before  代码。</li>
<li>操作方法筛选器的 after  代码。</li>
</ul>
</li>
<li>控制器 <em>after</em> 和 Razor 页面筛选器后的代码。</li>
</ul>
</li>
<li>全局筛选器的 after  代码。</li>
</ul>
<p>下面的示例阐释了为同步操作筛选器调用筛选器方法的顺序。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">序列</th>
<th style="text-align: center;">筛选器作用域</th>
<th style="text-align: center;">筛选器方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">控制器或 Razor 页面</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">控制器或 Razor 页面</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
</tbody>
</table>
<h3 id="controller-level-filters">控制器级别筛选器</h3>
<p>继承自 &lt;xref:Microsoft.AspNetCore.Mvc.Controller&gt; 基类的每个控制器包括 <a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuting*">Controller.OnActionExecuting</a>、<a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecutionAsync*">Controller.OnActionExecutionAsync</a> 和 <a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuted*">Controller.OnActionExecuted</a>
<code>OnActionExecuted</code> 方法。 这些方法：</p>
<ul>
<li>覆盖为给定操作运行的筛选器。</li>
<li><code>OnActionExecuting</code> 在所有操作筛选器之前调用。</li>
<li><code>OnActionExecuted</code> 在所有操作筛选器之后调用。</li>
<li><code>OnActionExecutionAsync</code> 在所有操作筛选器之前调用。 <code>next</code> 之后的筛选器中的代码在操作方法之后运行。</li>
</ul>
<p>例如，在下载示例中，启动时全局应用 <code>MySampleActionFilter</code>。</p>
<p><code>TestController</code>：</p>
<ul>
<li>将 <code>SampleActionFilterAttribute</code> (<code>[SampleActionFilter]</code>) 应用于 <code>FilterTest2</code> 操作。</li>
<li>重写 <code>OnActionExecuting</code> 和 <code>OnActionExecuted</code>。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><p><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs">MyDisplayRouteInfo</a> 由 <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo">Rick.Docs.Samples.RouteInfo</a> NuGet 包提供，会显示路由信息。</p>
<!-- test via  webBuilder.UseStartup<Startup>(); -->
<p>导航到 <code>https://localhost:5001/Test/FilterTest2</code> 运行以下代码：</p>
<ul>
<li><code>TestController.OnActionExecuting</code>
<ul>
<li><code>MySampleActionFilter.OnActionExecuting</code>
<ul>
<li><code>SampleActionFilterAttribute.OnActionExecuting</code>
<ul>
<li><code>TestController.FilterTest2</code></li>
</ul>
</li>
<li><code>SampleActionFilterAttribute.OnActionExecuted</code></li>
</ul>
</li>
<li><code>MySampleActionFilter.OnActionExecuted</code></li>
</ul>
</li>
<li><code>TestController.OnActionExecuted</code></li>
</ul>
<p>控制器级别筛选器将 <a href="https://github.com/dotnet/AspNetCore/blob/master/src/Mvc/Mvc.Core/src/Filters/ControllerActionFilter.cs#L15-L17">Order</a> 属性设置为 <code>int.MinValue</code>。 控制器级别筛选器无法设置为在将筛选器应用于方法之后运行  。 在下一节对 Order 进行了介绍。</p>
<p>有关 Razor 页面，请 <a class="xref" href="../../razor-pages/filter.html#implement-razor-page-filters-by-overriding-filter-methods">参阅 Razor 通过重写筛选器方法实现页面筛选器</a>。</p>
<h3 id="overriding-the-default-order">重写默认顺序</h3>
<p>可以通过实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IOrderedFilter&gt; 来重写默认执行序列。 <code>IOrderedFilter</code> 公开了 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IOrderedFilter.Order&gt; 属性来确定执行顺序，该属性优先于作用域。 具有较低的 <code>Order</code> 值的筛选器：</p>
<ul>
<li>在具有较高的 <code>Order</code> 值的筛选器之前运行 before  代码。</li>
<li>在具有较高的 <code>Order</code> 值的筛选器之后运行 after  代码。</li>
</ul>
<p>使用构造函数参数设置了 <code>Order</code> 属性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>请考虑以下控制器中的两个操作筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在 <code>StartUp.ConfigureServices</code> 中添加了全局筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>3 个筛选器按下列顺序运行：</p>
<ul>
<li><code>Test2Controller.OnActionExecuting</code>
<ul>
<li><code>MySampleActionFilter.OnActionExecuting</code>
<ul>
<li><code>MyAction2FilterAttribute.OnActionExecuting</code>
<ul>
<li><code>Test2Controller.FilterTest2</code></li>
</ul>
</li>
<li><code>MyAction2FilterAttribute.OnResultExecuting</code></li>
</ul>
</li>
<li><code>MySampleActionFilter.OnActionExecuted</code></li>
</ul>
</li>
<li><code>Test2Controller.OnActionExecuted</code></li>
</ul>
<p>在确定筛选器的运行顺序时，<code>Order</code> 属性重写作用域。 先按顺序对筛选器排序，然后使用作用域消除并列问题。 所有内置筛选器实现 <code>IOrderedFilter</code> 并将默认 <code>Order</code> 值设为 0。 如前所述，控制器级别筛选器将 <a href="https://github.com/dotnet/AspNetCore/blob/master/src/Mvc/Mvc.Core/src/Filters/ControllerActionFilter.cs#L15-L17">Order</a> 属性设置为 <code>int.MinValue</code>。对于内置筛选器，作用域会确定顺序，除非将 <code>Order</code> 设为非零值。</p>
<p>在前面的代码中，<code>MySampleActionFilter</code> 具有全局作用域，因此它在具有控制器作用域的 <code>MyAction2FilterAttribute</code> 之前运行。 若要首先运行 <code>MyAction2FilterAttribute</code>，请将顺序设置为 <code>int.MinValue</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>若要首先运行全局筛选器 <code>MySampleActionFilter</code>，请将 <code>Order</code> 设置为 <code>int.MinValue</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="cancellation-and-short-circuiting">取消和设置短路</h2>
<p>通过设置提供给筛选器方法的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResourceExecutingContext&gt; 参数上的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResourceExecutingContext.Result&gt; 属性，可以使筛选器管道短路。 例如，以下资源筛选器将阻止执行管道的其余阶段：</p>
<p><a name="short-circuiting-resource-filter"></a></p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在下面的代码中，<code>ShortCircuitingResourceFilter</code> 和 <code>AddHeader</code> 筛选器都以 <code>SomeResource</code> 操作方法为目标。 <code>ShortCircuitingResourceFilter</code>：</p>
<ul>
<li>先运行，因为它是资源筛选器且 <code>AddHeader</code> 是操作筛选器。</li>
<li>对管道的其余部分进行短路处理。</li>
</ul>
<p>这样 <code>AddHeader</code> 筛选器就不会为 <code>SomeResource</code> 操作运行。 如果这两个筛选器都应用于操作方法级别，只要 <code>ShortCircuitingResourceFilter</code> 先运行，此行为就不会变。 先运行 <code>ShortCircuitingResourceFilter</code>（考虑到它的筛选器类型），或显式使用 <code>Order</code> 属性。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="dependency-injection">依赖项注入</h2>
<p>可按类型或实例添加筛选器。 如果添加实例，该实例将用于每个请求。 如果添加类型，则将激活该类型。 激活类型的筛选器意味着：</p>
<ul>
<li>将为每个请求创建一个实例。</li>
<li><a class="xref" href="../../fundamentals/dependency-injection.html">依赖关系注入</a> (DI) 将填充所有构造函数依赖项。</li>
</ul>
<p>如果将筛选器作为属性实现并直接添加到控制器类或操作方法中，则该筛选器不能由<a class="xref" href="../../fundamentals/dependency-injection.html">依赖关系注入</a> (DI) 提供构造函数依赖项。 无法由 DI 提供构造函数依赖项，因为：</p>
<ul>
<li>属性在应用时必须提供自己的构造函数参数。</li>
<li>这是属性工作原理上的限制。</li>
</ul>
<p>以下筛选器支持从 DI 提供的构造函数依赖项：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt;</li>
<li>在属性上实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。</li>
</ul>
<p>可以将前面的筛选器应用于控制器或操作方法：</p>
<p>可以从 DI 获取记录器。 但是，避免创建和使用筛选器仅用于日志记录。 <a class="xref" href="../../fundamentals/logging/index.html">内置框架日志记录</a>通常提供日志记录所需的内容。 添加到筛选器的日志记录：</p>
<ul>
<li>应重点关注业务域问题或特定于筛选器的行为。</li>
<li>不应记录操作或其他框架事件  。 内置筛选器记录操作和框架事件。</li>
</ul>
<h3 id="servicefilterattribute">ServiceFilterAttribute</h3>
<p>在 <code>ConfigureServices</code> 中注册服务筛选器实现类型。 &lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 可从 DI 检索筛选器实例。</p>
<p>以下代码显示 <code>AddHeaderResultServiceFilter</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，<code>AddHeaderResultServiceFilter</code> 将添加到 DI 容器中：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，<code>ServiceFilter</code> 属性将从 DI 中检索 <code>AddHeaderResultServiceFilter</code> 筛选器的实例：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用 <code>ServiceFilterAttribute</code> 时，<a href="xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute.IsReusable">ServiceFilterAttribute.IsReusable</a> 设置：</p>
<ul>
<li><p>提供以下提示：筛选器实例可能在其创建的请求范围之外被重用。  ASP.NET Core 运行时不保证：</p>
<ul>
<li>将创建筛选器的单一实例。</li>
<li>稍后不会从 DI 容器重新请求筛选器。</li>
</ul>
</li>
<li><p>不应与依赖于生命周期不同于单一实例的服务的筛选器一起使用。</p>
</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。 <code>IFilterFactory</code> 公开用于创建 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt; 实例的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法。 <code>CreateInstance</code> 从 DI 中加载指定的类型。</p>
<h3 id="typefilterattribute">TypeFilterAttribute</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt; 与 &lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 类似，但不会直接从 DI 容器解析其类型。 它使用 &lt;xref:Microsoft.Extensions.DependencyInjection.ObjectFactory?displayProperty=fullName&gt; 对类型进行实例化。</p>
<p>因为不会直接从 DI 容器解析 <code>TypeFilterAttribute</code> 类型：</p>
<ul>
<li>使用 <code>TypeFilterAttribute</code> 引用的类型不需要注册在 DI 容器中。  它们具备由 DI 容器实现的依赖项。</li>
<li><code>TypeFilterAttribute</code> 可以选择为类型接受构造函数参数。</li>
</ul>
<p>使用 <code>TypeFilterAttribute</code> 时，<a href="xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute.IsReusable">TypeFilterAttribute.IsReusable</a> 设置：</p>
<ul>
<li><p>提供提示：筛选器实例可能在其创建的请求范围之外被重用。  ASP.NET Core 运行时不保证将创建筛选器的单一实例。</p>
</li>
<li><p>不应与依赖于生命周期不同于单一实例的服务的筛选器一起使用。</p>
</li>
</ul>
<p>下面的示例演示如何使用 <code>TypeFilterAttribute</code> 将参数传递到类型：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><!-- 
https://localhost:5001/home/hi?name=joe
VS debug window shows 
FiltersSample.Filters.LogConstantFilter:Information: Method 'Hi' called
-->
<h2 id="authorization-filters">授权筛选器</h2>
<p>授权筛选器：</p>
<ul>
<li>是筛选器管道中运行的第一个筛选器。</li>
<li>控制对操作方法的访问。</li>
<li>具有在它之前的执行的方法，但没有之后执行的方法。</li>
</ul>
<p>自定义授权筛选器需要自定义授权框架。 建议配置授权策略或编写自定义授权策略，而不是编写自定义筛选器。 内置授权筛选器：</p>
<ul>
<li>调用授权系统。</li>
<li>不授权请求。</li>
</ul>
<p>不会在授权筛选器中引发异常  ：</p>
<ul>
<li>不会处理异常。</li>
<li>异常筛选器不会处理异常。</li>
</ul>
<p>在授权筛选器出现异常时请小心应对。</p>
<p>详细了解<a class="xref" href="../../security/authorization/introduction.html">授权</a>。</p>
<h2 id="resource-filters">资源筛选器</h2>
<p>资源筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResourceFilter&gt; 接口。</li>
<li>执行会覆盖筛选器管道的绝大部分。</li>
<li>只有 <a href="#authorization-filters">授权筛选器</a> 才会在资源筛选器之前运行。</li>
</ul>
<p>如果要使大部分管道短路，资源筛选器会很有用。 例如，如果缓存命中，则缓存筛选器可以绕开管道的其余阶段。</p>
<p>资源筛选器示例：</p>
<ul>
<li><p>之前显示的<a href="#short-circuiting-resource-filter">短路资源筛选器</a>。</p>
</li>
<li><p><a href="https://github.com/aspnet/Entropy/blob/rel/2.0.0-preview2/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs">DisableFormValueModelBindingAttribute</a>：</p>
<ul>
<li>可以防止模型绑定访问表单数据。</li>
<li>用于上传大型文件，以防止表单数据被读入内存。</li>
</ul>
</li>
</ul>
<h2 id="action-filters">操作筛选器</h2>
<p>操作筛选器 <strong>不适用于</strong> Razor 页面。 Razor 页面支持 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IPageFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncPageFilter&gt; 。 有关详细信息，请参阅 <a class="xref" href="../../razor-pages/filter.html">Razor Pages 的筛选方法</a>。</p>
<p>操作筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IActionFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncActionFilter&gt; 接口。</li>
<li>它们的执行围绕着操作方法的执行。</li>
</ul>
<p>以下代码显示示例操作筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext&gt; 提供以下属性：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.ActionArguments&gt; - 用于读取操作方法的输入。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Controller&gt; - 用于处理控制器实例。</li>
<li>&lt;xref:System.Web.Mvc.ActionExecutingContext.Result&gt; - 设置 <code>Result</code> 会使操作方法和后续操作筛选器的执行短路。</li>
</ul>
<p>在操作方法中引发异常：</p>
<ul>
<li>防止运行后续筛选器。</li>
<li>与设置 <code>Result</code> 不同，结果被视为失败而不是成功。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext&gt; 提供 <code>Controller</code> 和 <code>Result</code> 以及以下属性：</p>
<ul>
<li><p>&lt;xref:System.Web.Mvc.ActionExecutedContext.Canceled&gt; - 如果操作执行已被另一个筛选器设置短路，则为 true。</p>
</li>
<li><p>&lt;xref:System.Web.Mvc.ActionExecutedContext.Exception&gt; - 如果操作或之前运行的操作筛选器引发了异常，则为非 NULL 值。 将此属性设置为 null：</p>
<ul>
<li>有效地处理异常。</li>
<li>执行 <code>Result</code>，从操作方法中将它返回。</li>
</ul>
</li>
</ul>
<p>对于 <code>IAsyncActionFilter</code>，一个向 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate&gt; 的调用可以达到以下目的：</p>
<ul>
<li>执行所有后续操作筛选器和操作方法。</li>
<li>返回 <code>ActionExecutedContext</code>。</li>
</ul>
<p>若要设置短路，可将 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.Result?displayProperty=fullName&gt; 分配到某个结果实例，并且不调用 <code>next</code> (<code>ActionExecutionDelegate</code>)。</p>
<p>该框架提供一个可子类化的抽象 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt;。</p>
<p><code>OnActionExecuting</code> 操作筛选器可用于：</p>
<ul>
<li>验证模型状态。</li>
<li>如果状态无效，则返回错误。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>使用特性批注的控制器 <code>[ApiController]</code> 自动验证模型状态并返回400响应。 有关详细信息，请参阅<a class="xref" href="../../web-api/index.html#automatic-http-400-responses">自动 HTTP 400 响应</a>。</p>
</div>
<p><code>OnActionExecuted</code> 方法在操作方法之后运行：</p>
<ul>
<li><p>可通过 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Result&gt; 属性查看和处理操作结果。</p>
</li>
<li><p>如果操作执行已被另一个筛选器设置短路，则 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Canceled&gt; 设置为 true。</p>
</li>
<li><p>如果操作或后续操作筛选器引发了异常，则 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Exception&gt; 设置为非 NULL 值。 将 <code>Exception</code> 设置为 null：</p>
<ul>
<li>有效地处理异常。</li>
<li>执行 <code>ActionExecutedContext.Result</code>，从操作方法中将它正常返回。</li>
</ul>
</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="exception-filters">异常筛选器</h2>
<p>异常筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IExceptionFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncExceptionFilter&gt;。</li>
<li>可用于实现常见的错误处理策略。</li>
</ul>
<p>下面的异常筛选器示例使用自定义错误视图，显示在开发应用时发生的异常的相关详细信息：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码测试异常筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>异常筛选器：</p>
<ul>
<li>没有之前和之后的事件。</li>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IExceptionFilter.OnException*&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncExceptionFilter.OnExceptionAsync*&gt;。</li>
<li>处理在 Razor 页或控制器创建、 <a class="xref" href="../models/model-binding.html">模型绑定</a>、操作筛选器或操作方法中发生的未经处理的异常。</li>
<li>不要 <strong>捕获资源</strong> 筛选器、结果筛选器或 MVC 结果执行中发生的异常。</li>
</ul>
<p>若要处理异常，请将 &lt;xref:System.Web.Mvc.ExceptionContext.ExceptionHandled&gt; 属性设置为 <code>true</code>，或编写响应。 这将停止传播异常。 异常筛选器无法将异常转变为“成功”。 只有操作筛选器才能执行该转变。</p>
<p>异常筛选器：</p>
<ul>
<li>非常适合捕获发生在操作中的异常。</li>
<li>并不像错误处理中间件那么灵活。</li>
</ul>
<p>建议使用中间件处理异常。 基于所调用的操作方法，仅当错误处理不同时，才使用异常筛选器  。 例如，应用可能具有用于 API 终结点和视图/HTML 的操作方法。 API 终结点可能返回 JSON 形式的错误信息，而基于视图的操作可能返回 HTML 形式的错误页。</p>
<h2 id="result-filters">结果筛选器</h2>
<p>结果筛选器：</p>
<ul>
<li>实现接口：
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResultFilter&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAlwaysRunResultFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncAlwaysRunResultFilter&gt;</li>
</ul>
</li>
<li>它们的执行围绕着操作结果的执行。</li>
</ul>
<h3 id="iresultfilter-and-iasyncresultfilter">IResultFilter 和 IAsyncResultFilter</h3>
<p>以下代码显示一个添加 HTTP 标头的结果筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>要执行的结果类型取决于所执行的操作。 返回视图的操作会将所有 Razor 处理作为要执行的 &lt;xref:Microsoft.AspNetCore.Mvc.ViewResult&gt; 的一部分。 API 方法可能会将某些序列化操作作为结果执行的一部分。 详细了解 <a class="xref" href="actions.html">操作结果</a>。</p>
<p>仅当操作或操作筛选器生成操作结果时，才会执行结果筛选器。 不会在以下情况下执行结果筛选器：</p>
<ul>
<li>授权筛选器或资源筛选器使管道短路。</li>
<li>异常筛选器通过生成操作结果来处理异常。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter.OnResultExecuting*?displayProperty=fullName&gt; 方法可以将 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext.Cancel?displayProperty=fullName&gt; 设置为 <code>true</code>，使操作结果和后续结果筛选器的执行短路。 设置短路时写入响应对象，以免生成空响应。 如果在 <code>IResultFilter.OnResultExecuting</code> 中引发异常，则会导致：</p>
<ul>
<li>阻止操作结果和后续筛选器的执行。</li>
<li>结果被视为失败而不是成功。</li>
</ul>
<p>当 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter.OnResultExecuted*?displayProperty=fullName&gt; 方法运行时，响应可能已发送到客户端。 如果响应已发送到客户端，则无法更改。</p>
<p>如果操作结果执行已被另一个筛选器设置短路，则 <code>ResultExecutedContext.Canceled</code> 设置为 <code>true</code>。</p>
<p>如果操作结果或后续结果筛选器引发了异常，则 <code>ResultExecutedContext.Exception</code> 设置为非 NULL 值。 将 <code>Exception</code> 设置为 NULL 可有效地处理异常，并防止在管道的后续阶段引发该异常。 处理结果筛选器中出现的异常时，没有可靠的方法来将数据写入响应。 如果在操作结果引发异常时标头已刷新到客户端，则没有任何可靠的机制可用于发送失败代码。</p>
<p>对于 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResultFilter&gt;，通过调用 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutionDelegate&gt; 上的 <code>await next</code> 可执行所有后续结果筛选器和操作结果。 若要设置短路，请将 <a href="xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext.Cancel">ResultExecutingContext.Cancel</a> 设置为 <code>true</code>，并且不调用 <code>ResultExecutionDelegate</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>该框架提供一个可子类化的抽象 <code>ResultFilterAttribute</code>。 前面所示的 <a href="#add-header-attribute">AddHeaderAttribute</a> 类是一种结果筛选器属性。</p>
<h3 id="ialwaysrunresultfilter-and-iasyncalwaysrunresultfilter">IAlwaysRunResultFilter 和 IAsyncAlwaysRunResultFilter</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAlwaysRunResultFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncAlwaysRunResultFilter&gt; 接口声明了一个针对所有操作结果运行的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter&gt; 实现。 这包括由以下对象生成的操作结果：</p>
<ul>
<li>设置短路的授权筛选器和资源筛选器。</li>
<li>异常筛选器。</li>
</ul>
<p>例如，以下筛选器始终运行并在内容协商失败时设置具有“422 无法处理的实体”  状态代码的操作结果 (&lt;xref:Microsoft.AspNetCore.Mvc.ObjectResult&gt;)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="ifilterfactory">IFilterFactory</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt;。 因此，<code>IFilterFactory</code> 实例可在筛选器管道中的任意位置用作 <code>IFilterMetadata</code> 实例。 当运行时准备调用筛选器时，它会尝试将其转换为 <code>IFilterFactory</code>。 如果转换成功，则调用 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法来创建将调用的 <code>IFilterMetadata</code> 实例。 这提供了一种很灵活的设计，因为无需在应用启动时显式设置精确的筛选器管道。</p>
<p>可以使用自定义属性实现来实现 <code>IFilterFactory</code> 作为另一种创建筛选器的方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中应用了筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>通过运行<a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/3.1sample">下载示例</a>来测试前面的代码：</p>
<ul>
<li>调用 F12 开发人员工具。</li>
<li>导航到 <code>https://localhost:5001/Sample/HeaderWithFactory</code>。</li>
</ul>
<p>F12 开发人员工具显示示例代码添加的以下响应标头：</p>
<ul>
<li><strong>作者：</strong><code>Rick Anderson</code></li>
<li><strong>globaladdheader:</strong> <code>Result filter added to MvcOptions.Filters</code></li>
<li><strong>内部：</strong><code>My header</code></li>
</ul>
<p>前面的代码创建 <strong>internal:</strong> <code>My header</code> 响应标头。</p>
<h3 id="ifilterfactory-implemented-on-an-attribute">在属性上实现 IFilterFactory</h3>
<!-- Review 
This section needs to be rewritten.
What's a non-named attribute?
-->
<p>实现 <code>IFilterFactory</code> 的筛选器可用于以下筛选器：</p>
<ul>
<li>不需要传递参数。</li>
<li>具备需要由 DI 填充的构造函数依赖项。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。 <code>IFilterFactory</code> 公开用于创建 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt; 实例的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法。 <code>CreateInstance</code> 从服务容器 (DI) 中加载指定的类型。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码显示应用 <code>[SampleActionFilter]</code> 的三种方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，使用 <code>[SampleActionFilter]</code> 修饰方法是应用 <code>SampleActionFilter</code> 的首选方法。</p>
<h2 id="using-middleware-in-the-filter-pipeline">在筛选器管道中使用中间件</h2>
<p>资源筛选器的工作方式与<a class="xref" href="../../fundamentals/middleware/index.html">中间件</a>类似，即涵盖管道中的所有后续执行。 但筛选器又不同于中间件，它们是运行时的一部分，这意味着它们有权访问上下文和构造。</p>
<p>若要将中间件用作筛选器，可创建一个具有 <code>Configure</code> 方法的类型，该方法可指定要注入到筛选器管道的中间件。 下面的示例使用本地化中间件为请求建立当前区域性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用 &lt;xref:Microsoft.AspNetCore.Mvc.MiddlewareFilterAttribute&gt; 运行中间件：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>中间件筛选器与资源筛选器在筛选器管道的相同阶段运行，即，在模型绑定之前以及管道的其余阶段之后。</p>
<h2 id="next-actions">后续操作</h2>
<ul>
<li>请参阅 <a class="xref" href="../../razor-pages/filter.html">筛选 Razor 页面的方法</a>。</li>
<li>若要尝试使用筛选器，请<a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/3.1sample">下载、测试并修改 GitHub 示例</a>。</li>
</ul>
</div>
<div range="&lt; aspnetcore-3.0">
<p>作者：<a href="https://github.com/serpent5">Kirk Larkin</a>、<a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>、<a href="https://github.com/tdykstra/">Tom Dykstra</a> 和 <a href="https://ardalis.com/">Steve Smith</a></p>
<p>通过使用 ASP.NET Core 中的筛选器，可在请求处理管道中的特定阶段之前或之后运行代码。</p>
<p>内置筛选器处理任务，例如：</p>
<ul>
<li>授权（防止用户访问未获授权的资源）。</li>
<li>响应缓存（对请求管道进行短路出路，以便返回缓存的响应）。</li>
</ul>
<p>可以创建自定义筛选器，用于处理横切关注点。 横切关注点的示例包括错误处理、缓存、配置、授权和日志记录。  筛选器可以避免复制代码。 例如，错误处理异常筛选器可以合并错误处理。</p>
<p>本文档适用于 Razor 具有视图的页面、API 控制器和控制器。</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/sample">查看或下载示例</a>（<a class="xref" href="../../introduction-to-aspnet-core.html#how-to-download-a-sample">如何下载</a>）。</p>
<h2 id="how-filters-work">筛选器的工作原理</h2>
<p>筛选器在 ASP.NET Core 操作调用管道  （有时称为筛选器管道  ）内运行。  筛选器管道在 ASP.NET Core 选择了要执行的操作之后运行。</p>
<p><img src="filters/_static/filter-pipeline-1.png" alt="请求通过其他中间件、路由中间件、操作选择和 ASP.NET Core 操作调用管道进行处理。 请求处理继续往回通过操作选择、路由中间件和各种其他中间件，变成发送到客户端的响应。"></p>
<h3 id="filter-types">筛选器类型</h3>
<p>每种筛选器类型都在筛选器管道中的不同阶段执行：</p>
<ul>
<li><p><a href="#authorization-filters">授权筛选器</a>最先运行，用于确定是否已针对请求为用户授权。 如果请求未获授权，授权筛选器可以让管道短路。</p>
</li>
<li><p><a href="#resource-filters">资源筛选器</a>：</p>
<ul>
<li>授权后运行。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter.OnResourceExecuting*&gt; 可以在筛选器管道的其余阶段之前运行代码。 例如，<code>OnResourceExecuting</code> 可以在模型绑定之前运行代码。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter.OnResourceExecuted*&gt; 可以在管道的其余阶段完成之后运行代码。</li>
</ul>
</li>
<li><p><a href="#action-filters">操作筛选器</a>可以在调用单个操作方法之前和之后立即运行代码。 它们可用于处理传入某个操作的参数以及从该操作返回的结果。 页面 <strong>不</strong> 支持操作筛选器 Razor 。</p>
</li>
<li><p><a href="#exception-filters">异常筛选器</a>用于在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。</p>
</li>
<li><p><a href="#result-filters">结果筛选器</a>可以在执行单个操作结果之前和之后立即运行代码。 仅当操作方法成功执行时，它们才会运行。 对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。</p>
</li>
</ul>
<p>下图展示了筛选器类型在筛选器管道中的交互方式。</p>
<p><img src="filters/_static/filter-pipeline-2.png" alt="请求通过授权过滤器、资源过滤器、模型绑定、操作过滤器、操作执行和操作结果转换、异常过滤器、结果过滤器和结果执行进行处理。 返回时，请求仅由结果过滤器和资源过滤器进行处理，变成发送到客户端的响应。"></p>
<h2 id="implementation">实现</h2>
<p>筛选器通过不同的接口定义支持同步和异步实现。</p>
<p>同步筛选器可以在其管道阶段之前 (<code>On-Stage-Executing</code>) 和之后 (<code>On-Stage-Executed</code>) 运行代码。 例如，<code>OnActionExecuting</code> 在调用操作方法之前调用。 <code>OnActionExecuted</code> 在操作方法返回之后调用。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>异步筛选器定义 <code>On-Stage-ExecutionAsync</code> 方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，<code>SampleAsyncActionFilter</code> 具有执行操作方法的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate&gt; (<code>next</code>)。  每个 <code>On-Stage-ExecutionAsync</code> 方法采用执行筛选器的管道阶段的 <code>FilterType-ExecutionDelegate</code>。</p>
<h3 id="multiple-filter-stages">多个筛选器阶段</h3>
<p>可以在单个类中实现多个筛选器阶段的接口。 例如，&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt; 类实现 <code>IActionFilter</code>、<code>IResultFilter</code> 及其异步等效接口。</p>
<p>筛选器接口的同步和异步版本任意实现一个，而不是同时实现 。 运行时会先查看筛选器是否实现了异步接口，如果是，则调用该接口。 如果不是，则调用同步接口的方法。 如果在一个类中同时实现异步和同步接口，则仅调用异步方法。 使用抽象类时（如 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt;），将为每种筛选器类型仅重写同步方法或仅重写异步方法。</p>
<h3 id="built-in-filter-attributes">内置筛选器属性</h3>
<p>ASP.NET Core 包含许多可子类化和自定义的基于属性的内置筛选器。 例如，以下结果筛选器会向响应添加标头：</p>
<p><a name="add-header-attribute"></a></p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>通过使用属性，筛选器可接收参数，如前面的示例所示。 将 <code>AddHeaderAttribute</code> 添加到控制器或操作方法，并指定 HTTP 标头的名称和值：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><!-- `https://localhost:5001/Sample` -->
<p>多种筛选器接口具有相应属性，这些属性可用作自定义实现的基类。</p>
<p>筛选器属性：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ExceptionFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.FormatFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt;</li>
</ul>
<h2 id="filter-scopes-and-order-of-execution">筛选器作用域和执行顺序</h2>
<p>可以将筛选器添加到管道中的以下三个 <em>范围</em> 之一：</p>
<ul>
<li>在操作上使用属性。</li>
<li>在控制器上使用属性。</li>
<li>所有控制器和操作的全局筛选器，如下面的代码所示：</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>前面的代码使用 <a href="xref:Microsoft.AspNetCore.Mvc.MvcOptions.Filters">MvcOptions.Filters</a> 集合全局添加三个筛选器。</p>
<h3 id="default-order-of-execution">默认执行顺序</h3>
<p>当有同一类型的多个筛选器时，作用域可确定筛选器执行的默认顺序  。  全局筛选器涵盖类筛选器。 类筛选器涵盖方法筛选器。</p>
<p>在筛选器嵌套模式下，筛选器的 after  代码会按照与 before  代码相反的顺序运行。 筛选器序列：</p>
<ul>
<li>全局筛选器的 before  代码。
<ul>
<li>控制器筛选器的 before  代码。
<ul>
<li>操作方法筛选器的 before  代码。</li>
<li>操作方法筛选器的 after  代码。</li>
</ul>
</li>
<li>控制器筛选器的 after  代码。</li>
</ul>
</li>
<li>全局筛选器的 after  代码。</li>
</ul>
<p>下面的示例阐释了为同步操作筛选器调用筛选器方法的顺序。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">序列</th>
<th style="text-align: center;">筛选器作用域</th>
<th style="text-align: center;">筛选器方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">控制器</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">控制器</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
</tbody>
</table>
<p>此序列显示：</p>
<ul>
<li>方法筛选器已嵌套在控制器筛选器中。</li>
<li>控制器筛选器已嵌套在全局筛选器中。</li>
</ul>
<h3 id="controller-and-no-locrazor-page-level-filters">控制器和 Razor 页级筛选器</h3>
<p>继承自 &lt;xref:Microsoft.AspNetCore.Mvc.Controller&gt; 基类的每个控制器包括 <a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuting*">Controller.OnActionExecuting</a>、<a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecutionAsync*">Controller.OnActionExecutionAsync</a> 和 <a href="xref:Microsoft.AspNetCore.Mvc.Controller.OnActionExecuted*">Controller.OnActionExecuted</a>
<code>OnActionExecuted</code> 方法。 这些方法：</p>
<ul>
<li>覆盖为给定操作运行的筛选器。</li>
<li><code>OnActionExecuting</code> 在所有操作筛选器之前调用。</li>
<li><code>OnActionExecuted</code> 在所有操作筛选器之后调用。</li>
<li><code>OnActionExecutionAsync</code> 在所有操作筛选器之前调用。 <code>next</code> 之后的筛选器中的代码在操作方法之后运行。</li>
</ul>
<p>例如，在下载示例中，启动时全局应用 <code>MySampleActionFilter</code>。</p>
<p><code>TestController</code>：</p>
<ul>
<li>将 <code>SampleActionFilterAttribute</code> (<code>[SampleActionFilter]</code>) 应用于 <code>FilterTest2</code> 操作。</li>
<li>重写 <code>OnActionExecuting</code> 和 <code>OnActionExecuted</code>。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>导航到 <code>https://localhost:5001/Test/FilterTest2</code> 运行以下代码：</p>
<ul>
<li><code>TestController.OnActionExecuting</code>
<ul>
<li><code>MySampleActionFilter.OnActionExecuting</code>
<ul>
<li><code>SampleActionFilterAttribute.OnActionExecuting</code>
<ul>
<li><code>TestController.FilterTest2</code></li>
</ul>
</li>
<li><code>SampleActionFilterAttribute.OnActionExecuted</code></li>
</ul>
</li>
<li><code>MySampleActionFilter.OnActionExecuted</code></li>
</ul>
</li>
<li><code>TestController.OnActionExecuted</code></li>
</ul>
<p>有关 Razor 页面，请 <a class="xref" href="../../razor-pages/filter.html#implement-razor-page-filters-by-overriding-filter-methods">参阅 Razor 通过重写筛选器方法实现页面筛选器</a>。</p>
<h3 id="overriding-the-default-order">重写默认顺序</h3>
<p>可以通过实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IOrderedFilter&gt; 来重写默认执行序列。 <code>IOrderedFilter</code> 公开了 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IOrderedFilter.Order&gt; 属性来确定执行顺序，该属性优先于作用域。 具有较低的 <code>Order</code> 值的筛选器：</p>
<ul>
<li>在具有较高的 <code>Order</code> 值的筛选器之前运行 before  代码。</li>
<li>在具有较高的 <code>Order</code> 值的筛选器之后运行 after  代码。</li>
</ul>
<p>可以使用构造函数参数设置 <code>Order</code> 属性：</p>
<pre><code class="lang-csharp">[MyFilter(Name = &quot;Controller Level Attribute&quot;, Order=1)]
</code></pre>
<p>请考虑前面示例中所示的 3 个相同操作筛选器。 如果控制器和全局筛选器的 <code>Order</code> 属性分别设置为 1 和 2，则会反转执行顺序。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">序列</th>
<th style="text-align: center;">筛选器作用域</th>
<th style="text-align: center;"><code>Order</code> 属性</th>
<th style="text-align: center;">筛选器方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">控制器</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><code>OnActionExecuting</code></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">全球</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">控制器</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">方法</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><code>OnActionExecuted</code></td>
</tr>
</tbody>
</table>
<p>在确定筛选器的运行顺序时，<code>Order</code> 属性重写作用域。 先按顺序对筛选器排序，然后使用作用域消除并列问题。 所有内置筛选器实现 <code>IOrderedFilter</code> 并将默认 <code>Order</code> 值设为 0。 对于内置筛选器，作用域会确定顺序，除非将 <code>Order</code> 设为非零值。</p>
<h2 id="cancellation-and-short-circuiting">取消和设置短路</h2>
<p>通过设置提供给筛选器方法的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResourceExecutingContext&gt; 参数上的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResourceExecutingContext.Result&gt; 属性，可以使筛选器管道短路。 例如，以下资源筛选器将阻止执行管道的其余阶段：</p>
<p><a name="short-circuiting-resource-filter"></a></p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在下面的代码中，<code>ShortCircuitingResourceFilter</code> 和 <code>AddHeader</code> 筛选器都以 <code>SomeResource</code> 操作方法为目标。 <code>ShortCircuitingResourceFilter</code>：</p>
<ul>
<li>先运行，因为它是资源筛选器且 <code>AddHeader</code> 是操作筛选器。</li>
<li>对管道的其余部分进行短路处理。</li>
</ul>
<p>这样 <code>AddHeader</code> 筛选器就不会为 <code>SomeResource</code> 操作运行。 如果这两个筛选器都应用于操作方法级别，只要 <code>ShortCircuitingResourceFilter</code> 先运行，此行为就不会变。 先运行 <code>ShortCircuitingResourceFilter</code>（考虑到它的筛选器类型），或显式使用 <code>Order</code> 属性。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="dependency-injection">依赖项注入</h2>
<p>可按类型或实例添加筛选器。 如果添加实例，该实例将用于每个请求。 如果添加类型，则将激活该类型。 激活类型的筛选器意味着：</p>
<ul>
<li>将为每个请求创建一个实例。</li>
<li><a class="xref" href="../../fundamentals/dependency-injection.html">依赖关系注入</a> (DI) 将填充所有构造函数依赖项。</li>
</ul>
<p>如果将筛选器作为属性实现并直接添加到控制器类或操作方法中，则该筛选器不能由<a class="xref" href="../../fundamentals/dependency-injection.html">依赖关系注入</a> (DI) 提供构造函数依赖项。 无法由 DI 提供构造函数依赖项，因为：</p>
<ul>
<li>属性在应用时必须提供自己的构造函数参数。</li>
<li>这是属性工作原理上的限制。</li>
</ul>
<p>以下筛选器支持从 DI 提供的构造函数依赖项：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt;</li>
<li>在属性上实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。</li>
</ul>
<p>可以将前面的筛选器应用于控制器或操作方法：</p>
<p>可以从 DI 获取记录器。 但是，避免创建和使用筛选器仅用于日志记录。 <a class="xref" href="../../fundamentals/logging/index.html">内置框架日志记录</a>通常提供日志记录所需的内容。 添加到筛选器的日志记录：</p>
<ul>
<li>应重点关注业务域问题或特定于筛选器的行为。</li>
<li>不应记录操作或其他框架事件  。 内置筛选器记录操作和框架事件。</li>
</ul>
<h3 id="servicefilterattribute">ServiceFilterAttribute</h3>
<p>在 <code>ConfigureServices</code> 中注册服务筛选器实现类型。 &lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 可从 DI 检索筛选器实例。</p>
<p>以下代码显示 <code>AddHeaderResultServiceFilter</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，<code>AddHeaderResultServiceFilter</code> 将添加到 DI 容器中：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在以下代码中，<code>ServiceFilter</code> 属性将从 DI 中检索 <code>AddHeaderResultServiceFilter</code> 筛选器的实例：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用 <code>ServiceFilterAttribute</code> 时，<a href="xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute.IsReusable">ServiceFilterAttribute.IsReusable</a> 设置：</p>
<ul>
<li><p>提供以下提示：筛选器实例可能在其创建的请求范围之外被重用。  ASP.NET Core 运行时不保证：</p>
<ul>
<li>将创建筛选器的单一实例。</li>
<li>稍后不会从 DI 容器重新请求筛选器。</li>
</ul>
</li>
<li><p>不应与依赖于生命周期不同于单一实例的服务的筛选器一起使用。</p>
</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。 <code>IFilterFactory</code> 公开用于创建 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt; 实例的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法。 <code>CreateInstance</code> 从 DI 中加载指定的类型。</p>
<h3 id="typefilterattribute">TypeFilterAttribute</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt; 与 &lt;xref:Microsoft.AspNetCore.Mvc.ServiceFilterAttribute&gt; 类似，但不会直接从 DI 容器解析其类型。 它使用 &lt;xref:Microsoft.Extensions.DependencyInjection.ObjectFactory?displayProperty=fullName&gt; 对类型进行实例化。</p>
<p>因为不会直接从 DI 容器解析 <code>TypeFilterAttribute</code> 类型：</p>
<ul>
<li>使用 <code>TypeFilterAttribute</code> 引用的类型不需要注册在 DI 容器中。  它们具备由 DI 容器实现的依赖项。</li>
<li><code>TypeFilterAttribute</code> 可以选择为类型接受构造函数参数。</li>
</ul>
<p>使用 <code>TypeFilterAttribute</code> 时，<a href="xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute.IsReusable">TypeFilterAttribute.IsReusable</a> 设置：</p>
<ul>
<li><p>提供提示：筛选器实例可能在其创建的请求范围之外被重用。  ASP.NET Core 运行时不保证将创建筛选器的单一实例。</p>
</li>
<li><p>不应与依赖于生命周期不同于单一实例的服务的筛选器一起使用。</p>
</li>
</ul>
<p>下面的示例演示如何使用 <code>TypeFilterAttribute</code> 将参数传递到类型：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><!-- 
https://localhost:5001/home/hi?name=joe
VS debug window shows 
FiltersSample.Filters.LogConstantFilter:Information: Method 'Hi' called
-->
<h2 id="authorization-filters">授权筛选器</h2>
<p>授权筛选器：</p>
<ul>
<li>是筛选器管道中运行的第一个筛选器。</li>
<li>控制对操作方法的访问。</li>
<li>具有在它之前的执行的方法，但没有之后执行的方法。</li>
</ul>
<p>自定义授权筛选器需要自定义授权框架。 建议配置授权策略或编写自定义授权策略，而不是编写自定义筛选器。 内置授权筛选器：</p>
<ul>
<li>调用授权系统。</li>
<li>不授权请求。</li>
</ul>
<p>不会在授权筛选器中引发异常  ：</p>
<ul>
<li>不会处理异常。</li>
<li>异常筛选器不会处理异常。</li>
</ul>
<p>在授权筛选器出现异常时请小心应对。</p>
<p>详细了解<a class="xref" href="../../security/authorization/introduction.html">授权</a>。</p>
<h2 id="resource-filters">资源筛选器</h2>
<p>资源筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResourceFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResourceFilter&gt; 接口。</li>
<li>执行会覆盖筛选器管道的绝大部分。</li>
<li>只有 <a href="#authorization-filters">授权筛选器</a> 才会在资源筛选器之前运行。</li>
</ul>
<p>如果要使大部分管道短路，资源筛选器会很有用。 例如，如果缓存命中，则缓存筛选器可以绕开管道的其余阶段。</p>
<p>资源筛选器示例：</p>
<ul>
<li><p>之前显示的<a href="#short-circuiting-resource-filter">短路资源筛选器</a>。</p>
</li>
<li><p><a href="https://github.com/aspnet/Entropy/blob/rel/2.0.0-preview2/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs">DisableFormValueModelBindingAttribute</a>：</p>
<ul>
<li>可以防止模型绑定访问表单数据。</li>
<li>用于上传大型文件，以防止表单数据被读入内存。</li>
</ul>
</li>
</ul>
<h2 id="action-filters">操作筛选器</h2>
<div class="IMPORTANT">
<h5>Important</h5>
<p>操作筛选器 <strong>不适用于</strong> Razor 页面。 Razor 页面支持 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IPageFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncPageFilter&gt; 。 有关详细信息，请参阅 <a class="xref" href="../../razor-pages/filter.html">Razor Pages 的筛选方法</a>。</p>
</div>
<p>操作筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IActionFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncActionFilter&gt; 接口。</li>
<li>它们的执行围绕着操作方法的执行。</li>
</ul>
<p>以下代码显示示例操作筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext&gt; 提供以下属性：</p>
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.ActionArguments&gt; - 用于读取操作方法的输入。</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Controller&gt; - 用于处理控制器实例。</li>
<li>&lt;xref:System.Web.Mvc.ActionExecutingContext.Result&gt; - 设置 <code>Result</code> 会使操作方法和后续操作筛选器的执行短路。</li>
</ul>
<p>在操作方法中引发异常：</p>
<ul>
<li>防止运行后续筛选器。</li>
<li>与设置 <code>Result</code> 不同，结果被视为失败而不是成功。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext&gt; 提供 <code>Controller</code> 和 <code>Result</code> 以及以下属性：</p>
<ul>
<li><p>&lt;xref:System.Web.Mvc.ActionExecutedContext.Canceled&gt; - 如果操作执行已被另一个筛选器设置短路，则为 true。</p>
</li>
<li><p>&lt;xref:System.Web.Mvc.ActionExecutedContext.Exception&gt; - 如果操作或之前运行的操作筛选器引发了异常，则为非 NULL 值。 将此属性设置为 null：</p>
<ul>
<li>有效地处理异常。</li>
<li>执行 <code>Result</code>，从操作方法中将它返回。</li>
</ul>
</li>
</ul>
<p>对于 <code>IAsyncActionFilter</code>，一个向 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutionDelegate&gt; 的调用可以达到以下目的：</p>
<ul>
<li>执行所有后续操作筛选器和操作方法。</li>
<li>返回 <code>ActionExecutedContext</code>。</li>
</ul>
<p>若要设置短路，可将 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.Result?displayProperty=fullName&gt; 分配到某个结果实例，并且不调用 <code>next</code> (<code>ActionExecutionDelegate</code>)。</p>
<p>该框架提供一个可子类化的抽象 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute&gt;。</p>
<p><code>OnActionExecuting</code> 操作筛选器可用于：</p>
<ul>
<li>验证模型状态。</li>
<li>如果状态无效，则返回错误。</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><code>OnActionExecuted</code> 方法在操作方法之后运行：</p>
<ul>
<li><p>可通过 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Result&gt; 属性查看和处理操作结果。</p>
</li>
<li><p>如果操作执行已被另一个筛选器设置短路，则 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Canceled&gt; 设置为 true。</p>
</li>
<li><p>如果操作或后续操作筛选器引发了异常，则 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext.Exception&gt; 设置为非 NULL 值。 将 <code>Exception</code> 设置为 null：</p>
<ul>
<li>有效地处理异常。</li>
<li>执行 <code>ActionExecutedContext.Result</code>，从操作方法中将它正常返回。</li>
</ul>
</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h2 id="exception-filters">异常筛选器</h2>
<p>异常筛选器：</p>
<ul>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IExceptionFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncExceptionFilter&gt;。</li>
<li>可用于实现常见的错误处理策略。</li>
</ul>
<p>下面的异常筛选器示例使用自定义错误视图，显示在开发应用时发生的异常的相关详细信息：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>异常筛选器：</p>
<ul>
<li>没有之前和之后的事件。</li>
<li>实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IExceptionFilter.OnException*&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncExceptionFilter.OnExceptionAsync*&gt;。</li>
<li>处理在 Razor 页或控制器创建、 <a class="xref" href="../models/model-binding.html">模型绑定</a>、操作筛选器或操作方法中发生的未经处理的异常。</li>
<li>不要 <strong>捕获资源</strong> 筛选器、结果筛选器或 MVC 结果执行中发生的异常。</li>
</ul>
<p>若要处理异常，请将 &lt;xref:System.Web.Mvc.ExceptionContext.ExceptionHandled&gt; 属性设置为 <code>true</code>，或编写响应。 这将停止传播异常。 异常筛选器无法将异常转变为“成功”。 只有操作筛选器才能执行该转变。</p>
<p>异常筛选器：</p>
<ul>
<li>非常适合捕获发生在操作中的异常。</li>
<li>并不像错误处理中间件那么灵活。</li>
</ul>
<p>建议使用中间件处理异常。 基于所调用的操作方法，仅当错误处理不同时，才使用异常筛选器  。 例如，应用可能具有用于 API 终结点和视图/HTML 的操作方法。 API 终结点可能返回 JSON 形式的错误信息，而基于视图的操作可能返回 HTML 形式的错误页。</p>
<h2 id="result-filters">结果筛选器</h2>
<p>结果筛选器：</p>
<ul>
<li>实现接口：
<ul>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResultFilter&gt;</li>
<li>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAlwaysRunResultFilter&gt; 或 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncAlwaysRunResultFilter&gt;</li>
</ul>
</li>
<li>它们的执行围绕着操作结果的执行。</li>
</ul>
<h3 id="iresultfilter-and-iasyncresultfilter">IResultFilter 和 IAsyncResultFilter</h3>
<p>以下代码显示一个添加 HTTP 标头的结果筛选器：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>要执行的结果类型取决于所执行的操作。 返回视图的操作会将所有 Razor 处理作为要执行的 &lt;xref:Microsoft.AspNetCore.Mvc.ViewResult&gt; 的一部分。 API 方法可能会将某些序列化操作作为结果执行的一部分。 详细了解 <a class="xref" href="actions.html">操作结果</a>。</p>
<p>仅当操作或操作筛选器生成操作结果时，才会执行结果筛选器。 不会在以下情况下执行结果筛选器：</p>
<ul>
<li>授权筛选器或资源筛选器使管道短路。</li>
<li>异常筛选器通过生成操作结果来处理异常。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter.OnResultExecuting*?displayProperty=fullName&gt; 方法可以将 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext.Cancel?displayProperty=fullName&gt; 设置为 <code>true</code>，使操作结果和后续结果筛选器的执行短路。 设置短路时写入响应对象，以免生成空响应。 如果在 <code>IResultFilter.OnResultExecuting</code> 中引发异常，则会导致：</p>
<ul>
<li>阻止操作结果和后续筛选器的执行。</li>
<li>结果被视为失败而不是成功。</li>
</ul>
<p>当 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter.OnResultExecuted*?displayProperty=fullName&gt; 方法运行时，响应可能已发送到客户端。 如果响应已发送到客户端，则无法再更改。</p>
<p>如果操作结果执行已被另一个筛选器设置短路，则 <code>ResultExecutedContext.Canceled</code> 设置为 <code>true</code>。</p>
<p>如果操作结果或后续结果筛选器引发了异常，则 <code>ResultExecutedContext.Exception</code> 设置为非 NULL 值。 将 <code>Exception</code> 设置为 NULL 可有效地处理异常，并防止 ASP.NET Core 在管道的后续阶段重新引发该异常。 处理结果筛选器中出现的异常时，没有可靠的方法来将数据写入响应。 如果在操作结果引发异常时标头已刷新到客户端，则没有任何可靠的机制可用于发送失败代码。</p>
<p>对于 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncResultFilter&gt;，通过调用 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutionDelegate&gt; 上的 <code>await next</code> 可执行所有后续结果筛选器和操作结果。 若要设置短路，请将 <a href="xref:Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext.Cancel">ResultExecutingContext.Cancel</a> 设置为 <code>true</code>，并且不调用 <code>ResultExecutionDelegate</code>：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>该框架提供一个可子类化的抽象 <code>ResultFilterAttribute</code>。 前面所示的 <a href="#add-header-attribute">AddHeaderAttribute</a> 类是一种结果筛选器属性。</p>
<h3 id="ialwaysrunresultfilter-and-iasyncalwaysrunresultfilter">IAlwaysRunResultFilter 和 IAsyncAlwaysRunResultFilter</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAlwaysRunResultFilter&gt; 和 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncAlwaysRunResultFilter&gt; 接口声明了一个针对所有操作结果运行的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter&gt; 实现。 这包括由以下对象生成的操作结果：</p>
<ul>
<li>设置短路的授权筛选器和资源筛选器。</li>
<li>异常筛选器。</li>
</ul>
<p>例如，以下筛选器始终运行并在内容协商失败时设置具有“422 无法处理的实体”  状态代码的操作结果 (&lt;xref:Microsoft.AspNetCore.Mvc.ObjectResult&gt;)：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><h3 id="ifilterfactory">IFilterFactory</h3>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt;。 因此，<code>IFilterFactory</code> 实例可在筛选器管道中的任意位置用作 <code>IFilterMetadata</code> 实例。 当运行时准备调用筛选器时，它会尝试将其转换为 <code>IFilterFactory</code>。 如果转换成功，则调用 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法来创建将调用的 <code>IFilterMetadata</code> 实例。 这提供了一种很灵活的设计，因为无需在应用启动时显式设置精确的筛选器管道。</p>
<p>可以使用自定义属性实现来实现 <code>IFilterFactory</code> 作为另一种创建筛选器的方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>可以通过运行<a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/sample">下载示例</a>来测试前面的代码：</p>
<ul>
<li>调用 F12 开发人员工具。</li>
<li>导航到 <code>https://localhost:5001/Sample/HeaderWithFactory</code>。</li>
</ul>
<p>F12 开发人员工具显示示例代码添加的以下响应标头：</p>
<ul>
<li><strong>作者：</strong><code>Joe Smith</code></li>
<li><strong>globaladdheader:</strong> <code>Result filter added to MvcOptions.Filters</code></li>
<li><strong>内部：</strong><code>My header</code></li>
</ul>
<p>前面的代码创建 <strong>internal:</strong> <code>My header</code> 响应标头。</p>
<h3 id="ifilterfactory-implemented-on-an-attribute">在属性上实现 IFilterFactory</h3>
<!-- Review 
This section needs to be rewritten.
What's a non-named attribute?
-->
<p>实现 <code>IFilterFactory</code> 的筛选器可用于以下筛选器：</p>
<ul>
<li>不需要传递参数。</li>
<li>具备需要由 DI 填充的构造函数依赖项。</li>
</ul>
<p>&lt;xref:Microsoft.AspNetCore.Mvc.TypeFilterAttribute&gt; 可实现 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory&gt;。 <code>IFilterFactory</code> 公开用于创建 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata&gt; 实例的 &lt;xref:Microsoft.AspNetCore.Mvc.Filters.IFilterFactory.CreateInstance*&gt; 方法。 <code>CreateInstance</code> 从服务容器 (DI) 中加载指定的类型。</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>以下代码显示应用 <code>[SampleActionFilter]</code> 的三种方法：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>在前面的代码中，使用 <code>[SampleActionFilter]</code> 修饰方法是应用 <code>SampleActionFilter</code> 的首选方法。</p>
<h2 id="using-middleware-in-the-filter-pipeline">在筛选器管道中使用中间件</h2>
<p>资源筛选器的工作方式与<a class="xref" href="../../fundamentals/middleware/index.html">中间件</a>类似，即涵盖管道中的所有后续执行。 但筛选器又不同于中间件，它们是 ASP.NET Core 运行时的一部分，这意味着它们有权访问 ASP.NET Core 上下文和构造。</p>
<p>若要将中间件用作筛选器，可创建一个具有 <code>Configure</code> 方法的类型，该方法可指定要注入到筛选器管道的中间件。 下面的示例使用本地化中间件为请求建立当前区域性：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>使用 &lt;xref:Microsoft.AspNetCore.Mvc.MiddlewareFilterAttribute&gt; 运行中间件：</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>中间件筛选器与资源筛选器在筛选器管道的相同阶段运行，即，在模型绑定之前以及管道的其余阶段之后。</p>
<h2 id="next-actions">后续操作</h2>
<ul>
<li>请参阅 <a class="xref" href="../../razor-pages/filter.html">筛选 Razor 页面的方法</a>。</li>
<li>若要尝试使用筛选器，请<a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/mvc/controllers/filters/sample">下载、测试并修改 GitHub 示例</a>。</li>
</ul>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
